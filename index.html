<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHRONOPHAGE â€” The Time Devourer</title>
    <!-- V2: Google Fonts for HUD -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Bebas+Neue&family=Teko:wght@300;400;500;600;700&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #game-canvas {
            display: block;
        }

        /* UI Overlay */
        /* V3: UI Overlay layer system - sits above post-processing */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: #fff;
            z-index: 50; /* Above post-processing (4-7) but menus can go higher */
        }

        /* V2.9 Start Screen - Enhanced */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 0%, rgba(5, 5, 20, 0.95) 50%, rgba(0, 0, 0, 0.9) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            cursor: pointer;
            overflow: hidden;
        }

        /* V2.9 Decorative gears */
        #start-screen::before,
        #start-screen::after {
            content: '';
            position: absolute;
            border: 3px solid rgba(126, 184, 218, 0.1);
            border-radius: 50%;
            animation: spinGear 30s linear infinite;
        }

        #start-screen::before {
            width: 600px;
            height: 600px;
            top: -200px;
            right: -200px;
            border-width: 4px;
            border-style: dashed;
        }

        #start-screen::after {
            width: 500px;
            height: 500px;
            bottom: -150px;
            left: -150px;
            border-width: 3px;
            border-style: dotted;
            animation-direction: reverse;
            animation-duration: 25s;
        }

        @keyframes spinGear {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        /* V4: INSANE GRAPHICS - Enhanced Visual Effects */
        @keyframes pulseGlow {
            0%, 100% { filter: brightness(1) drop-shadow(0 0 10px currentColor); }
            50% { filter: brightness(1.3) drop-shadow(0 0 20px currentColor); }
        }

        @keyframes shakeIntense {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            10% { transform: translate(-3px, -2px) rotate(-0.5deg); }
            20% { transform: translate(3px, 2px) rotate(0.5deg); }
            30% { transform: translate(-2px, 3px) rotate(-0.3deg); }
            40% { transform: translate(2px, -3px) rotate(0.3deg); }
            50% { transform: translate(-3px, 1px) rotate(-0.5deg); }
            60% { transform: translate(3px, -1px) rotate(0.5deg); }
            70% { transform: translate(-1px, 3px) rotate(-0.2deg); }
            80% { transform: translate(1px, -3px) rotate(0.2deg); }
            90% { transform: translate(-2px, -2px) rotate(-0.4deg); }
        }

        @keyframes scanlines {
            0% { background-position: 0 0; }
            100% { background-position: 0 4px; }
        }

        /* V4: Kill streak announcements */
        #kill-streak-display {
            position: fixed;
            top: 20%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 3rem;
            font-weight: 900;
            color: #ff4444;
            text-shadow:
                0 0 20px #ff0000,
                0 0 40px #ff0000,
                0 0 60px #ff0000;
            opacity: 0;
            pointer-events: none;
            z-index: 110;
            transition: opacity 0.2s, transform 0.2s;
        }

        #kill-streak-display.visible {
            opacity: 1;
            animation: killStreakPop 0.5s ease-out;
        }

        @keyframes killStreakPop {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.2); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }

        /* V4: Enhanced chromatic aberration */
        #post-chromatic.intense {
            animation: chromaticPulse 0.1s ease-out;
        }

        @keyframes chromaticPulse {
            0% { filter: blur(0px); }
            50% { filter: blur(2px); }
            100% { filter: blur(0px); }
        }

        /* V4: Combat intensity vignette */
        #combat-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 45;
            background: radial-gradient(
                ellipse at center,
                transparent 0%,
                transparent 50%,
                rgba(255, 0, 0, 0.1) 80%,
                rgba(255, 0, 0, 0.3) 100%
            );
            opacity: 0;
            transition: opacity 0.3s;
        }

        /* V4: Scanline overlay for retro effect */
        #scanline-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 95;
            background: repeating-linear-gradient(
                0deg,
                rgba(0, 0, 0, 0.03) 0px,
                rgba(0, 0, 0, 0.03) 1px,
                transparent 1px,
                transparent 2px
            );
            opacity: 0.5;
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 5rem;
            font-weight: 900;
            letter-spacing: 0.8rem;
            color: #7eb8da;
            text-shadow:
                0 0 20px #4a90b8,
                0 0 40px #2a5a78,
                0 0 60px #1a3a58,
                0 0 80px rgba(74, 144, 184, 0.3);
            margin-bottom: 0.5rem;
            animation: titleGlow 3s ease-in-out infinite alternate;
            position: relative;
            z-index: 1;
        }

        @keyframes titleGlow {
            from {
                text-shadow: 0 0 20px #4a90b8, 0 0 40px #2a5a78, 0 0 60px #1a3a58;
            }
            to {
                text-shadow: 0 0 30px #6ab0d8, 0 0 60px #4a90b8, 0 0 90px #2a5a78;
            }
        }

        .subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.4rem;
            font-weight: 500;
            letter-spacing: 0.5rem;
            color: #d4af37;
            margin-bottom: 2.5rem;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.6);
            position: relative;
            z-index: 1;
        }

        /* V2.9 Decorative line */
        .subtitle::after {
            content: '';
            display: block;
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #d4af37, transparent);
            margin: 1rem auto 0;
        }

        .start-prompt {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.2rem;
            animation: promptPulse 2s ease-in-out infinite;
            position: relative;
            z-index: 1;
        }

        @keyframes promptPulse {
            0%, 100% {
                opacity: 0.7;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.02);
            }
        }

        .controls-info {
            font-family: 'Rajdhani', sans-serif;
            margin-top: 2rem;
            text-align: center;
            color: #888;
            font-size: 0.95rem;
            line-height: 2.2;
            font-weight: 500;
            position: relative;
            z-index: 1;
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem 2rem;
            border-radius: 8px;
            border: 1px solid rgba(126, 184, 218, 0.2);
        }

        /* V2.9 High score display */
        .high-score-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            color: #d4af37;
            margin-top: 1.5rem;
            letter-spacing: 0.1rem;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            position: relative;
            z-index: 1;
        }

        /* V2.9 Difficulty Selection - Enhanced */
        .difficulty-select {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem;
            position: relative;
            z-index: 1;
        }

        .difficulty-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #7eb8da;
            margin-bottom: 0.8rem;
            letter-spacing: 0.3rem;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(126, 184, 218, 0.3);
        }

        .difficulty-options {
            display: flex;
            gap: 1rem;
        }

        .difficulty-btn {
            font-family: 'Orbitron', sans-serif;
            padding: 0.8rem 1.4rem;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #444;
            color: #888;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.1rem;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .difficulty-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .difficulty-btn:hover::before {
            left: 100%;
        }

        .difficulty-btn:hover {
            border-color: #7eb8da;
            color: #7eb8da;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .difficulty-btn.selected {
            border-color: #d4af37;
            color: #d4af37;
            background: rgba(212, 175, 55, 0.15);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4), inset 0 0 10px rgba(212, 175, 55, 0.1);
            transform: translateY(-2px);
        }

        .difficulty-btn.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .difficulty-btn.locked:hover {
            border-color: #444;
            color: #888;
            transform: none;
            box-shadow: none;
        }

        .difficulty-btn.easy { border-color: #4a4; color: #6a6; }
        .difficulty-btn.easy:hover, .difficulty-btn.easy.selected { border-color: #6c6; color: #6c6; background: rgba(100, 200, 100, 0.15); box-shadow: 0 0 20px rgba(100, 200, 100, 0.3); }
        .difficulty-btn.normal { border-color: #7eb8da; color: #7eb8da; }
        .difficulty-btn.normal:hover, .difficulty-btn.normal.selected { border-color: #9ed; color: #9ed; background: rgba(126, 184, 218, 0.15); box-shadow: 0 0 20px rgba(126, 184, 218, 0.3); }
        .difficulty-btn.hard { border-color: #c64; color: #c86; }
        .difficulty-btn.hard:hover, .difficulty-btn.hard.selected { border-color: #f86; color: #f86; background: rgba(255, 136, 102, 0.15); box-shadow: 0 0 20px rgba(255, 136, 102, 0.3); }
        .difficulty-btn.nightmare { border-color: #a33; color: #c44; }
        .difficulty-btn.nightmare:hover:not(.locked), .difficulty-btn.nightmare.selected { border-color: #f44; color: #f44; background: rgba(255, 68, 68, 0.15); box-shadow: 0 0 20px rgba(255, 68, 68, 0.3); }

        .difficulty-desc {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            color: #777;
            margin-top: 0.8rem;
            text-align: center;
            max-width: 450px;
            min-height: 2.5em;
            font-style: italic;
        }

        /* V6: Graphics Quality Selector */
        .graphics-select {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 1.5rem;
            position: relative;
            z-index: 1;
        }

        .graphics-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 600;
            color: #6a9;
            margin-bottom: 0.5rem;
            letter-spacing: 0.2rem;
            text-transform: uppercase;
        }

        .graphics-options {
            display: flex;
            gap: 0.8rem;
        }

        .graphics-btn {
            font-family: 'Orbitron', sans-serif;
            padding: 0.5rem 1rem;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #444;
            color: #888;
            font-size: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.1rem;
            border-radius: 4px;
        }

        .graphics-btn:hover {
            border-color: #6a9;
            color: #6a9;
        }

        .graphics-btn.selected {
            border-color: #6c9;
            color: #6c9;
            background: rgba(102, 204, 153, 0.15);
            box-shadow: 0 0 15px rgba(102, 204, 153, 0.3);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* HUD Elements */
        /* V2 HUD Redesign with Google Fonts */
        /* V3: HUD Layer System - HUD is ALWAYS on top of all effects */
        #hud {
            display: none;
            font-family: 'Rajdhani', sans-serif;
            position: relative;
            z-index: 100; /* Always above vignette (5-7) and all other effects */
        }

        #hud.visible {
            display: block;
        }

        .hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        /* V2 Health/Stamina bars with labels */
        .bar-container {
            margin-bottom: 8px;
        }

        .bar-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            color: #888;
            letter-spacing: 0.15rem;
            margin-bottom: 2px;
            text-transform: uppercase;
        }

        .health-bar, .stamina-bar {
            width: 220px;
            height: 18px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .health-bar::before, .stamina-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: linear-gradient(180deg, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #2a6a88, #4a90b8, #7eb8da);
            transition: width 0.2s ease-out;
            box-shadow: 0 0 10px rgba(126, 184, 218, 0.5) inset;
        }

        .health-fill.regenerating {
            animation: regenPulse 0.8s ease-in-out infinite;
        }

        @keyframes regenPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(126, 184, 218, 0.5) inset; }
            50% { box-shadow: 0 0 20px rgba(100, 255, 150, 0.8) inset, 0 0 10px rgba(100, 255, 150, 0.5); }
        }

        .health-fill.critical {
            background: linear-gradient(90deg, #8a2020, #c44, #ff6666);
            animation: criticalPulse 0.5s ease-in-out infinite;
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #8a6a0a, #b8860b, #d4af37);
            transition: width 0.15s ease-out;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5) inset;
        }

        .bar-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            font-weight: 600;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 1;
        }

        .hud-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
        }

        .wave-display {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            font-weight: 400;
            color: #d4af37;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.6), 0 0 30px rgba(212, 175, 55, 0.3);
            letter-spacing: 0.15rem;
        }

        .wave-label {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 1rem;
            font-weight: 400;
            color: #888;
            letter-spacing: 0.2rem;
            text-transform: uppercase;
        }

        .time-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .hud-bottom-center {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .combo-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5rem;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.6), 2px 2px 4px rgba(0,0,0,0.5);
            transition: transform 0.1s, color 0.3s;
            letter-spacing: 0.1rem;
        }

        .combo-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: #888;
            letter-spacing: 0.2rem;
            text-transform: uppercase;
            margin-top: -5px;
        }

        .combo-display.hit {
            transform: scale(1.25);
            color: #d4af37;
        }

        .combo-display.high {
            color: #ffd700;
            text-shadow: 0 0 25px #ffd700, 0 0 50px rgba(212, 175, 55, 0.8);
        }

        .combo-display.max {
            color: #ff6600;
            text-shadow: 0 0 30px #ff6600, 0 0 60px #ffd700;
            animation: comboPulse 0.5s infinite;
        }

        @keyframes comboPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .charge-bar {
            width: 420px;
            height: 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 2px;
            margin-top: 15px;
            position: relative;
            overflow: hidden;
        }

        .charge-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: linear-gradient(180deg, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }

        .charge-fill {
            height: 100%;
            background: linear-gradient(90deg, #2a5a78, #4a90b8, #7eb8da, #d4af37);
            transition: width 0.2s ease-out;
            box-shadow: 0 0 10px rgba(126, 184, 218, 0.5) inset;
        }

        .charge-fill.full {
            animation: chargeFull 0.8s ease-in-out infinite;
        }

        @keyframes chargeFull {
            0%, 100% { box-shadow: 0 0 10px rgba(212, 175, 55, 0.5) inset; }
            50% { box-shadow: 0 0 20px rgba(212, 175, 55, 1) inset, 0 0 15px rgba(212, 175, 55, 0.8); }
        }

        .charge-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.65rem;
            font-weight: 600;
            color: #666;
            letter-spacing: 0.15rem;
            text-transform: uppercase;
            margin-top: 3px;
        }

        /* V2 Ability cooldown indicators */
        .ability-bar {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            justify-content: center;
        }

        .ability-slot {
            width: 55px;
            height: 55px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 6px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .ability-slot.ready {
            border-color: #7eb8da;
            box-shadow: 0 0 12px rgba(126, 184, 218, 0.6), inset 0 0 8px rgba(126, 184, 218, 0.2);
        }

        .ability-slot.active {
            border-color: #d4af37;
            box-shadow: 0 0 18px rgba(212, 175, 55, 0.9), inset 0 0 10px rgba(212, 175, 55, 0.3);
            animation: abilityPulse 0.5s infinite;
        }

        .ability-slot.insufficient {
            opacity: 0.4;
        }

        .ability-key {
            font-family: 'Orbitron', sans-serif;
            color: #888;
            font-size: 0.7rem;
            font-weight: 600;
            position: absolute;
            top: 3px;
            left: 5px;
        }

        .ability-cost {
            font-family: 'Rajdhani', sans-serif;
            color: #7eb8da;
            font-size: 0.65rem;
            font-weight: 600;
            position: absolute;
            bottom: 3px;
            right: 5px;
        }

        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(126, 184, 218, 0.4), rgba(126, 184, 218, 0.2));
            height: 0%;
            transition: height 0.1s;
            border-radius: 0 0 4px 4px;
        }

        .ability-icon {
            font-size: 1.6rem;
            z-index: 1;
        }

        @keyframes abilityPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.06); }
        }

        .hud-bottom-right {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
        }

        .score-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            letter-spacing: 0.05rem;
        }

        .score-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            color: #888;
            letter-spacing: 0.15rem;
            text-transform: uppercase;
        }

        /* V2 Weapon Display */
        .weapon-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .weapon-slot {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
            border-radius: 4px;
            transition: all 0.2s ease;
            opacity: 0.5;
        }

        .weapon-slot.active {
            opacity: 1;
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .weapon-icon {
            font-size: 1.5rem;
            width: 30px;
            text-align: center;
        }

        .weapon-info {
            display: flex;
            flex-direction: column;
        }

        .weapon-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: #fff;
        }

        .weapon-key {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.65rem;
            color: #666;
            letter-spacing: 0.1rem;
        }

        .weapon-ammo {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: #7eb8da;
            margin-left: auto;
        }

        /* Crosshair */
        /* V3: Crosshair always visible above effects */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
            z-index: 101; /* Above HUD (100) */
        }

        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair.visible {
            display: block;
        }

        /* V2.10 Game Over Screen - Enhanced */
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: background 1s, opacity 1s;
            overflow: hidden;
        }

        #game-over-screen.visible {
            display: flex;
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(180deg, rgba(20, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.95) 50%, rgba(20, 0, 0, 0.9) 100%);
            opacity: 1;
        }

        /* V2.10 Broken clock decoration */
        #game-over-screen::before {
            content: '';
            position: absolute;
            width: 400px;
            height: 400px;
            border: 4px dashed rgba(255, 68, 68, 0.15);
            border-radius: 50%;
            animation: brokenSpin 20s linear infinite;
        }

        @keyframes brokenSpin {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(100deg); }
            26% { transform: rotate(95deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
            76% { transform: rotate(265deg); }
            100% { transform: rotate(360deg); }
        }

        .game-over-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 4.5rem;
            font-weight: 900;
            letter-spacing: 0.5rem;
            color: #ff4444;
            text-shadow:
                0 0 20px #ff0000,
                0 0 40px #aa0000,
                0 0 60px rgba(255, 0, 0, 0.3);
            margin-bottom: 1rem;
            transform: scale(0);
            animation: gameOverAppear 0.5s ease-out forwards;
            animation-delay: 0.5s;
            position: relative;
            z-index: 1;
        }

        /* V2.10 Glitch effect on title */
        .game-over-title::after {
            content: "TIME'S UP";
            position: absolute;
            left: 2px;
            top: 0;
            color: #00ffff;
            opacity: 0;
            animation: glitch 3s infinite;
            animation-delay: 1.5s;
        }

        @keyframes glitch {
            0%, 90%, 100% { opacity: 0; transform: translateX(0); }
            92% { opacity: 0.5; transform: translateX(-5px); }
            94% { opacity: 0; transform: translateX(5px); }
            96% { opacity: 0.3; transform: translateX(-2px); }
        }

        @keyframes gameOverAppear {
            0% { transform: scale(0) rotate(-10deg); }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .final-score {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.2rem;
            font-weight: 700;
            color: #d4af37;
            margin-bottom: 0.5rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 1s;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .final-wave {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: #7eb8da;
            margin-bottom: 0.5rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 1.2s;
        }

        .final-difficulty {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #888;
            margin-bottom: 1.5rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 1.3s;
            text-transform: uppercase;
            letter-spacing: 0.25rem;
        }
        .final-difficulty.easy { color: #6c6; }
        .final-difficulty.normal { color: #9ed; }
        .final-difficulty.hard { color: #f86; }
        .final-difficulty.nightmare { color: #f44; }

        .nightmare-unlock-notice {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            color: #f44;
            text-shadow: 0 0 15px #f00;
            margin-bottom: 1rem;
            opacity: 0;
            animation: nightmareUnlock 1s ease-out forwards;
            animation-delay: 1.5s;
        }

        @keyframes nightmareUnlock {
            0% { opacity: 0; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.1); text-shadow: 0 0 30px #f00; }
            100% { opacity: 1; transform: scale(1); text-shadow: 0 0 15px #f00; }
        }

        .high-score-notice {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin-bottom: 1rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards, highScorePulse 1s ease-in-out infinite;
            animation-delay: 1.4s, 1.4s;
        }

        @keyframes highScorePulse {
            0%, 100% { text-shadow: 0 0 10px #ffd700; }
            50% { text-shadow: 0 0 20px #ffd700, 0 0 30px #d4af37; }
        }

        /* V2.10 Enhanced stats container */
        .stats-container {
            display: flex;
            gap: 40px;
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 1.6s;
            position: relative;
            z-index: 1;
            background: rgba(0, 0, 0, 0.3);
            padding: 1.5rem 2.5rem;
            border-radius: 8px;
            border: 1px solid rgba(126, 184, 218, 0.2);
        }

        .stat-item {
            text-align: center;
            padding: 0 1rem;
        }

        .stat-item:not(:last-child) {
            border-right: 1px solid rgba(126, 184, 218, 0.2);
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.4rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .stat-label {
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
            color: #7eb8da;
            text-transform: uppercase;
            letter-spacing: 0.15rem;
        }

        .restart-prompt {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: #888;
            letter-spacing: 0.15rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards, restartPulse 2s ease-in-out infinite;
            animation-delay: 2s, 2s;
            position: relative;
            z-index: 1;
        }

        @keyframes restartPulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* High Score Display on Start Screen */
        .high-score-display {
            margin-top: 2rem;
            text-align: center;
            color: #d4af37;
            font-size: 1rem;
        }

        .high-score-display span {
            color: #ffd700;
            font-size: 1.3rem;
        }

        /* Pause Screen */
        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #pause-screen.visible {
            display: flex;
        }

        .pause-title {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 4rem;
            color: #d4af37;
            margin-bottom: 2rem;
            letter-spacing: 0.3rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .pause-menu {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 300px;
            margin-bottom: 2rem;
        }

        .volume-control {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .volume-label {
            font-family: 'Rajdhani', sans-serif;
            color: #7eb8da;
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: 0.1rem;
            display: flex;
            justify-content: space-between;
        }

        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: rgba(126, 184, 218, 0.2);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #d4af37;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            transition: transform 0.1s;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #d4af37;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .pause-button {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 0.2rem;
            padding: 0.8rem 2rem;
            background: transparent;
            border: 2px solid #7eb8da;
            color: #7eb8da;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pause-button:hover {
            background: rgba(126, 184, 218, 0.2);
            border-color: #d4af37;
            color: #d4af37;
            transform: scale(1.05);
        }

        .pause-info {
            color: #666;
            font-size: 0.9rem;
            margin-top: 1.5rem;
        }

        /* V4 INFINITE: Shield Bar */
        .shield-bar {
            width: 180px;
            height: 16px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #00aaaa;
            border-radius: 3px;
            position: relative;
            overflow: hidden;
        }

        .shield-fill {
            height: 100%;
            background: linear-gradient(90deg, #00aaaa, #00ffff);
            transition: width 0.2s ease;
            box-shadow: inset 0 0 10px rgba(0, 255, 255, 0.5);
        }

        .shield-bar.broken .shield-fill {
            background: linear-gradient(90deg, #444, #666);
        }

        /* V4 INFINITE: Gold Display */
        .gold-display {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        .gold-icon-hud {
            font-size: 1rem;
        }

        /* V4 INFINITE: Inventory Screen */
        #inventory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 200;
        }

        #inventory-screen.visible {
            display: flex;
        }

        .inventory-container {
            width: 90%;
            max-width: 1000px;
            max-height: 90%;
            background: linear-gradient(180deg, rgba(20, 25, 40, 0.95), rgba(10, 15, 25, 0.98));
            border: 2px solid #3a4a6a;
            border-radius: 8px;
            padding: 20px;
            position: relative;
            overflow: hidden;
        }

        .inventory-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #3a4a6a;
            padding-bottom: 15px;
            margin-bottom: 20px;
        }

        .inventory-header h2 {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 2rem;
            color: #d4af37;
            letter-spacing: 0.2rem;
            margin: 0;
        }

        .inventory-gold, .shop-gold {
            display: flex;
            align-items: center;
            gap: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            color: #ffd700;
        }

        .inventory-close {
            background: transparent;
            border: 2px solid #666;
            color: #aaa;
            font-size: 1.5rem;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .inventory-close:hover {
            border-color: #ff4444;
            color: #ff4444;
        }

        .inventory-content {
            display: flex;
            gap: 30px;
            height: calc(100% - 80px);
        }

        /* Equipment Panel */
        .equipment-panel {
            width: 320px;
            flex-shrink: 0;
        }

        .equipment-panel h3, .backpack-panel h3 {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            color: #7eb8da;
            letter-spacing: 0.1rem;
            margin: 0 0 15px 0;
        }

        .equipment-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .equip-slot {
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #333;
            border-radius: 6px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .equip-slot:hover {
            border-color: #7eb8da;
            background: rgba(126, 184, 218, 0.1);
        }

        .equip-slot.has-item {
            border-color: #666;
        }

        .equip-slot.rarity-common { border-color: #9d9d9d; }
        .equip-slot.rarity-uncommon { border-color: #1eff00; }
        .equip-slot.rarity-rare { border-color: #0070dd; }
        .equip-slot.rarity-epic { border-color: #a335ee; }
        .equip-slot.rarity-legendary { border-color: #ff8000; box-shadow: 0 0 10px rgba(255, 128, 0, 0.3); }
        .equip-slot.rarity-temporal { border-color: #00ffff; box-shadow: 0 0 15px rgba(0, 255, 255, 0.4); animation: temporal-pulse 2s infinite; }

        @keyframes temporal-pulse {
            0%, 100% { box-shadow: 0 0 15px rgba(0, 255, 255, 0.4); }
            50% { box-shadow: 0 0 25px rgba(0, 255, 255, 0.7); }
        }

        .slot-icon {
            font-size: 1.8rem;
            opacity: 0.3;
        }

        .equip-slot.has-item .slot-icon {
            opacity: 1;
        }

        .slot-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.6rem;
            color: #666;
            text-transform: uppercase;
            margin-top: 4px;
        }

        .player-stats {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 15px;
        }

        .player-stats h4 {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.85rem;
            color: #d4af37;
            margin: 0 0 10px 0;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            color: #aaa;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .stat-row span:last-child {
            color: #7eb8da;
        }

        /* Backpack Panel */
        .backpack-panel {
            flex: 1;
        }

        .backpack-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .backpack-count {
            font-family: 'Rajdhani', sans-serif;
            color: #888;
            font-size: 0.9rem;
        }

        .backpack-controls {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
        }

        .sort-btn {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.75rem;
            padding: 5px 12px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid #444;
            color: #888;
            cursor: pointer;
            transition: all 0.2s;
        }

        .sort-btn:hover {
            border-color: #7eb8da;
            color: #7eb8da;
        }

        .backpack-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
            max-height: 400px;
            overflow-y: auto;
            padding: 5px;
        }

        .backpack-item {
            aspect-ratio: 1;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #333;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .backpack-item:hover {
            transform: scale(1.05);
            z-index: 1;
        }

        .backpack-item.rarity-common { border-color: #9d9d9d; }
        .backpack-item.rarity-uncommon { border-color: #1eff00; }
        .backpack-item.rarity-rare { border-color: #0070dd; }
        .backpack-item.rarity-epic { border-color: #a335ee; }
        .backpack-item.rarity-legendary { border-color: #ff8000; }
        .backpack-item.rarity-temporal { border-color: #00ffff; animation: temporal-pulse 2s infinite; }

        /* Item Tooltip */
        .item-tooltip {
            position: fixed;
            background: rgba(10, 15, 25, 0.98);
            border: 2px solid #4a5a7a;
            border-radius: 6px;
            padding: 15px;
            min-width: 250px;
            max-width: 300px;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            z-index: 1000;
            transition: opacity 0.15s ease;
        }

        .item-tooltip.visible {
            opacity: 1;
            visibility: visible;
        }

        .tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .tooltip-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: bold;
        }

        .tooltip-rarity {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            padding: 2px 8px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.5);
        }

        .tooltip-rarity.common { color: #9d9d9d; }
        .tooltip-rarity.uncommon { color: #1eff00; }
        .tooltip-rarity.rare { color: #0070dd; }
        .tooltip-rarity.epic { color: #a335ee; }
        .tooltip-rarity.legendary { color: #ff8000; }
        .tooltip-rarity.temporal { color: #00ffff; }

        .tooltip-type {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 10px;
        }

        .tooltip-stats {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            color: #7eb8da;
            margin-bottom: 10px;
        }

        .tooltip-stats div {
            padding: 2px 0;
        }

        .tooltip-ability {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.85rem;
            color: #d4af37;
            margin-bottom: 8px;
            font-style: italic;
        }

        .tooltip-flavor {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.75rem;
            color: #666;
            font-style: italic;
            margin-bottom: 10px;
        }

        .tooltip-value {
            display: flex;
            align-items: center;
            gap: 5px;
            font-family: 'Rajdhani', sans-serif;
            color: #ffd700;
            font-size: 0.9rem;
        }

        .tooltip-actions {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: space-between;
        }

        .action-hint {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            color: #555;
        }

        /* DEBUG: Wave Selector */
        .debug-wave-selector {
            margin-top: 30px;
            padding: 15px;
            background: rgba(255, 0, 0, 0.1);
            border: 1px solid #ff4444;
            border-radius: 8px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }

        .debug-label {
            font-family: 'Bebas Neue', sans-serif;
            color: #ff4444;
            font-size: 1rem;
            margin-bottom: 10px;
        }

        .debug-wave-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 5px;
        }

        .debug-wave-btn {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            padding: 8px 4px;
            background: rgba(40, 40, 40, 0.8);
            border: 1px solid #555;
            color: #aaa;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .debug-wave-btn:hover {
            background: rgba(255, 100, 100, 0.3);
            border-color: #ff4444;
            color: #fff;
        }

        .debug-wave-btn.boss-wave {
            background: rgba(100, 0, 100, 0.5);
            border-color: #a335ee;
            color: #a335ee;
        }

        .debug-wave-btn.boss-wave:hover {
            background: rgba(163, 53, 238, 0.4);
            color: #fff;
        }

        /* Victory Screen */
        #victory-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, rgba(0, 50, 100, 0.95) 0%, rgba(0, 0, 0, 0.98) 100%);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 400;
        }

        #victory-screen.visible {
            display: flex;
        }

        .victory-title {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 5rem;
            color: #ffd700;
            text-shadow: 0 0 50px rgba(255, 215, 0, 0.8),
                         0 0 100px rgba(255, 215, 0, 0.5);
            animation: victory-pulse 2s ease-in-out infinite;
            margin-bottom: 10px;
        }

        @keyframes victory-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .victory-subtitle {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.8rem;
            color: #00ffff;
            letter-spacing: 0.3rem;
            margin-bottom: 30px;
        }

        .victory-message {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 40px;
            text-align: center;
            max-width: 600px;
        }

        .victory-stats {
            display: flex;
            gap: 60px;
            margin-bottom: 50px;
        }

        .victory-prompt {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: #7eb8da;
            letter-spacing: 0.2rem;
            animation: pulse 2s ease-in-out infinite;
            cursor: pointer;
        }

        /* V4 INFINITE: Shop Screen */
        #shop-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.92);
            display: none;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            z-index: 200;
        }

        #shop-screen.visible {
            display: flex;
        }

        .shop-container {
            width: 90%;
            max-width: 900px;
            max-height: 90vh;
            overflow-y: auto;
            background: linear-gradient(180deg, rgba(30, 20, 40, 0.95), rgba(15, 10, 25, 0.98));
            border: 2px solid #6a4a8a;
            border-radius: 8px;
            padding: 30px;
            text-align: center;
        }

        .shop-header {
            margin-bottom: 30px;
        }

        .shop-header h2 {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            color: #a335ee;
            letter-spacing: 0.3rem;
            margin: 0 0 10px 0;
            text-shadow: 0 0 20px rgba(163, 53, 238, 0.5);
        }

        .shop-items {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 30px;
        }

        .shop-item {
            width: 180px;
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .shop-item:hover {
            transform: translateY(-5px);
            border-color: #a335ee;
            box-shadow: 0 5px 20px rgba(163, 53, 238, 0.3);
        }

        .shop-item.sold {
            opacity: 0.4;
            pointer-events: none;
        }

        .shop-item-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .shop-item-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: #fff;
            margin-bottom: 5px;
        }

        .shop-item-rarity {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            margin-bottom: 10px;
        }

        .shop-item-price {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            color: #ffd700;
        }

        .shop-item.cant-afford .shop-item-price {
            color: #ff4444;
        }

        .shop-item-type {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            color: #888;
            margin-bottom: 5px;
            text-transform: capitalize;
        }

        .shop-item-stats {
            margin: 10px 0;
            padding: 8px 0;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .shop-item-stat {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.75rem;
            color: #4ade80;
            margin: 3px 0;
        }

        .shop-item-ability {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            color: #fbbf24;
            font-style: italic;
            margin: 8px 0;
            padding: 5px;
            background: rgba(251, 191, 36, 0.1);
            border-radius: 4px;
        }

        .shop-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
        }

        .shop-btn {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 0.1rem;
            padding: 12px 30px;
            background: transparent;
            border: 2px solid #7eb8da;
            color: #7eb8da;
            cursor: pointer;
            transition: all 0.2s;
        }

        .shop-btn:hover {
            background: rgba(126, 184, 218, 0.2);
            border-color: #d4af37;
            color: #d4af37;
            transform: scale(1.05);
        }

        .shop-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Shop Inventory Section */
        .shop-inventory-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid rgba(126, 184, 218, 0.3);
        }

        .shop-inventory-section h3 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            color: #7eb8da;
            margin-bottom: 10px;
            text-align: center;
        }

        .shop-inventory-hint {
            font-size: 0.8rem;
            color: #888;
            font-family: 'Rajdhani', sans-serif;
        }

        .shop-inventory-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 8px;
            max-height: 150px;
            overflow-y: auto;
            padding: 10px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
        }

        .shop-inventory-item {
            width: 45px;
            height: 45px;
            background: rgba(20, 30, 40, 0.9);
            border: 2px solid #555;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.4rem;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
        }

        .shop-inventory-item:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .shop-inventory-item.rarity-common { border-color: #9d9d9d; }
        .shop-inventory-item.rarity-uncommon { border-color: #1eff00; }
        .shop-inventory-item.rarity-rare { border-color: #0070dd; }
        .shop-inventory-item.rarity-epic { border-color: #a335ee; }
        .shop-inventory-item.rarity-legendary { border-color: #ff8000; }
        .shop-inventory-item.rarity-temporal { border-color: #00ffff; }

        .shop-inventory-item .sell-value {
            position: absolute;
            bottom: -2px;
            right: -2px;
            font-size: 0.6rem;
            background: rgba(0, 0, 0, 0.8);
            color: #ffd700;
            padding: 1px 3px;
            border-radius: 3px;
        }

        /* V2.6 Post-Processing Overlays */
        #post-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(ellipse at center,
                transparent 0%,
                transparent 40%,
                rgba(0, 5, 15, 0.3) 70%,
                rgba(0, 5, 15, 0.7) 100%);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        /* Dynamic health-based red vignette overlay */
        #damage-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #damage-vignette.critical {
            animation: criticalPulse 0.8s ease-in-out infinite;
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: var(--damage-opacity, 0); }
            50% { opacity: calc(var(--damage-opacity, 0) * 1.3); }
        }

        #post-bloom {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
            background: radial-gradient(ellipse at center,
                rgba(126, 184, 218, 0.03) 0%,
                transparent 50%);
            mix-blend-mode: screen;
        }

        #post-chromatic {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        #post-chromatic.active {
            opacity: 1;
        }

        #post-chromatic::before,
        #post-chromatic::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #post-chromatic::before {
            box-shadow: inset 2px 0 0 rgba(255, 0, 0, 0.15);
        }

        #post-chromatic::after {
            box-shadow: inset -2px 0 0 rgba(0, 255, 255, 0.15);
        }

        #post-scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 7;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.03) 2px,
                rgba(0, 0, 0, 0.03) 4px
            );
            opacity: 0.5;
        }

        /* Game canvas with bloom filter */
        #game-canvas {
            filter: contrast(1.05) saturate(1.1);
        }

        #game-canvas.combat-active {
            filter: contrast(1.03) saturate(1.05) brightness(1.01);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- V2.6 Post-Processing Overlays -->
        <div id="post-bloom"></div>
        <div id="post-vignette"></div>
        <div id="damage-vignette"></div>
        <div id="post-chromatic"></div>
        <div id="post-scanlines"></div>

        <!-- V4: INSANE GRAPHICS - Additional Overlays -->
        <div id="kill-streak-display"></div>
        <div id="combat-vignette"></div>
        <div id="scanline-overlay"></div>

        <div id="ui-overlay">
            <!-- Start Screen -->
            <div id="start-screen">
                <div class="title">CHRONOPHAGE</div>
                <div class="subtitle">â€” THE TIME DEVOURER â€”</div>

                <!-- V2 Difficulty Selection -->
                <div class="difficulty-select">
                    <div class="difficulty-label">SELECT DIFFICULTY</div>
                    <div class="difficulty-options">
                        <button class="difficulty-btn easy" data-difficulty="easy">EASY</button>
                        <button class="difficulty-btn normal selected" data-difficulty="normal">NORMAL</button>
                        <button class="difficulty-btn hard" data-difficulty="hard">HARD</button>
                        <button class="difficulty-btn nightmare locked" data-difficulty="nightmare" title="Complete the game on Hard to unlock">ðŸ”’ NIGHTMARE</button>
                    </div>
                    <div class="difficulty-desc" id="difficulty-desc">Standard challenge. Balanced for most players.</div>
                </div>

                <!-- V6: Graphics Quality Selection -->
                <div class="graphics-select">
                    <div class="graphics-label">GRAPHICS QUALITY</div>
                    <div class="graphics-options">
                        <button class="graphics-btn" data-quality="low">LOW</button>
                        <button class="graphics-btn selected" data-quality="medium">MEDIUM</button>
                        <button class="graphics-btn" data-quality="high">HIGH</button>
                    </div>
                </div>

                <div class="start-prompt">[ CLICK TO BEGIN ]</div>
                <div class="controls-info">
                    WASD: Move &nbsp;&nbsp; MOUSE: Look &nbsp;&nbsp; SHIFT: Sprint<br>
                    SPACE: Dash &nbsp;&nbsp; LMB: Attack &nbsp;&nbsp; RMB: Heavy/Reload<br>
                    1/2/3: Switch Weapons &nbsp;&nbsp; Q/E/R: Temporal Abilities
                </div>
                <div class="high-score-display" id="high-score-display" style="display: none;">
                    HIGH SCORE: <span id="high-score-value">0</span>
                </div>

                <!-- DEBUG: Wave Selector (disable for release) -->
                <div class="debug-wave-selector" id="debug-wave-selector">
                    <div class="debug-label">DEBUG: Start at Wave</div>
                    <div class="debug-wave-grid" id="debug-wave-grid">
                        <!-- Wave buttons populated by JS -->
                    </div>
                </div>
            </div>

            <!-- Victory Screen -->
            <div id="victory-screen">
                <div class="victory-title">VICTORY</div>
                <div class="victory-subtitle">THE TIME EATER HAS BEEN VANQUISHED</div>
                <div class="victory-message">You have conquered all 5 Chronophages and saved the timestream!</div>
                <div class="victory-stats">
                    <div class="stat-item">
                        <div class="stat-value" id="victory-score">0</div>
                        <div class="stat-label">Final Score</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="victory-time">00:00</div>
                        <div class="stat-label">Total Time</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="victory-kills">0</div>
                        <div class="stat-label">Total Kills</div>
                    </div>
                </div>
                <div class="victory-prompt">[ CLICK TO RETURN TO MENU ]</div>
            </div>

            <!-- Game Over Screen -->
            <div id="game-over-screen">
                <div class="game-over-title">TIME'S UP</div>
                <div class="final-score">SCORE: <span id="final-score">0</span></div>
                <div class="final-wave">WAVE <span id="final-wave">1</span></div>
                <div class="final-difficulty normal" id="final-difficulty">NORMAL</div>
                <div class="nightmare-unlock-notice" id="nightmare-unlock" style="display: none;">â˜  NIGHTMARE MODE UNLOCKED â˜ </div>
                <div class="high-score-notice" id="new-high-score" style="display: none;">NEW HIGH SCORE!</div>
                <div class="stats-container">
                    <div class="stat-item">
                        <div class="stat-value" id="stat-time">00:00</div>
                        <div class="stat-label">Time Survived</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-kills">0</div>
                        <div class="stat-label">Enemies Slain</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-max-combo">0</div>
                        <div class="stat-label">Max Combo</div>
                    </div>
                </div>
                <div class="restart-prompt">[ CLICK TO PLAY AGAIN ]</div>
            </div>

            <!-- Pause Screen -->
            <div id="pause-screen">
                <div class="pause-title">PAUSED</div>
                <div class="pause-menu">
                    <div class="volume-control">
                        <div class="volume-label">
                            <span>MUSIC</span>
                            <span id="music-volume-value">100%</span>
                        </div>
                        <input type="range" class="volume-slider" id="music-volume" min="0" max="100" value="100">
                    </div>
                    <div class="volume-control">
                        <div class="volume-label">
                            <span>SFX</span>
                            <span id="sfx-volume-value">80%</span>
                        </div>
                        <input type="range" class="volume-slider" id="sfx-volume" min="0" max="100" value="80">
                    </div>
                </div>
                <div class="pause-buttons">
                    <button class="pause-button" id="resume-button">RESUME</button>
                    <button class="pause-button" id="quit-button">QUIT TO MENU</button>
                </div>
                <div class="pause-info">Press ESC to resume</div>
            </div>

            <!-- V4 INFINITE: Inventory Screen -->
            <div id="inventory-screen">
                <div class="inventory-container">
                    <div class="inventory-header">
                        <h2>INVENTORY</h2>
                        <div class="inventory-gold">
                            <span class="gold-icon">ðŸ’°</span>
                            <span id="inventory-gold">0</span>
                        </div>
                        <button class="inventory-close" id="inventory-close">âœ•</button>
                    </div>

                    <div class="inventory-content">
                        <!-- Equipment Panel (Left) -->
                        <div class="equipment-panel">
                            <h3>EQUIPMENT</h3>
                            <div class="equipment-grid">
                                <div class="equip-slot" data-slot="helmet" id="slot-helmet">
                                    <div class="slot-icon">ðŸŽ­</div>
                                    <div class="slot-label">HELMET</div>
                                </div>
                                <div class="equip-slot" data-slot="armor" id="slot-armor">
                                    <div class="slot-icon">ðŸ›¡</div>
                                    <div class="slot-label">ARMOR</div>
                                </div>
                                <div class="equip-slot" data-slot="boots" id="slot-boots">
                                    <div class="slot-icon">ðŸ‘¢</div>
                                    <div class="slot-label">BOOTS</div>
                                </div>
                                <div class="equip-slot" data-slot="sword" id="slot-sword">
                                    <div class="slot-icon">âš”</div>
                                    <div class="slot-label">SWORD</div>
                                </div>
                                <div class="equip-slot" data-slot="gun" id="slot-gun">
                                    <div class="slot-icon">ðŸ”«</div>
                                    <div class="slot-label">GUN</div>
                                </div>
                                <div class="equip-slot" data-slot="scythe" id="slot-scythe">
                                    <div class="slot-icon">âš°</div>
                                    <div class="slot-label">SCYTHE</div>
                                </div>
                                <div class="equip-slot" data-slot="shield" id="slot-shield">
                                    <div class="slot-icon">ðŸ”°</div>
                                    <div class="slot-label">SHIELD</div>
                                </div>
                                <div class="equip-slot" data-slot="trinket1" id="slot-trinket1">
                                    <div class="slot-icon">ðŸ’</div>
                                    <div class="slot-label">TRINKET</div>
                                </div>
                                <div class="equip-slot" data-slot="trinket2" id="slot-trinket2">
                                    <div class="slot-icon">ðŸ’</div>
                                    <div class="slot-label">TRINKET</div>
                                </div>
                            </div>

                            <div class="player-stats">
                                <h4>STATS</h4>
                                <div class="stat-row"><span>Damage:</span><span id="stat-damage">+0%</span></div>
                                <div class="stat-row"><span>Crit Chance:</span><span id="stat-crit">0%</span></div>
                                <div class="stat-row"><span>Attack Speed:</span><span id="stat-atkspd">+0%</span></div>
                                <div class="stat-row"><span>Armor:</span><span id="stat-armor">0</span></div>
                                <div class="stat-row"><span>Move Speed:</span><span id="stat-movespd">+0%</span></div>
                            </div>
                        </div>

                        <!-- Backpack Panel (Right) -->
                        <div class="backpack-panel">
                            <div class="backpack-header">
                                <h3>BACKPACK</h3>
                                <span class="backpack-count"><span id="backpack-used">0</span>/<span id="backpack-max">20</span></span>
                            </div>
                            <div class="backpack-controls">
                                <button class="sort-btn" data-sort="rarity">RARITY</button>
                                <button class="sort-btn" data-sort="type">TYPE</button>
                                <button class="sort-btn" data-sort="value">VALUE</button>
                            </div>
                            <div class="backpack-grid" id="backpack-grid">
                                <!-- Items populated by JS -->
                            </div>
                        </div>
                    </div>

                </div>
            </div>

            <!-- V4 INFINITE: Shop Screen -->
            <div id="shop-screen">
                <div class="shop-container">
                    <div class="shop-header">
                        <h2>TEMPORAL MERCHANT</h2>
                        <div class="shop-gold">
                            <span class="gold-icon">ðŸ’°</span>
                            <span id="shop-gold">0</span>
                        </div>
                    </div>
                    <div class="shop-items" id="shop-items">
                        <!-- Shop items populated by JS -->
                    </div>
                    <div class="shop-actions">
                        <button class="shop-btn" id="shop-reroll">REROLL (50ðŸ’°)</button>
                        <button class="shop-btn" id="shop-continue">CONTINUE</button>
                    </div>

                    <!-- Shop Inventory Section -->
                    <div class="shop-inventory-section">
                        <h3>YOUR INVENTORY <span class="shop-inventory-hint">(Right-click to sell)</span></h3>
                        <div class="shop-inventory-grid" id="shop-inventory-grid">
                            <!-- Inventory items populated by JS -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- HUD -->
            <div id="hud">
                <div class="hud-top-left">
                    <div class="bar-container">
                        <div class="bar-label">VITALITY</div>
                        <div class="health-bar">
                            <div class="health-fill" id="health-fill" style="width: 100%"></div>
                            <span class="bar-value" id="health-value">100</span>
                        </div>
                    </div>
                    <div class="bar-container">
                        <div class="bar-label">STAMINA</div>
                        <div class="stamina-bar">
                            <div class="stamina-fill" id="stamina-fill" style="width: 100%"></div>
                            <span class="bar-value" id="stamina-value">100</span>
                        </div>
                    </div>
                    <!-- V4 INFINITE: Shield Bar -->
                    <div class="bar-container" id="shield-bar-container">
                        <div class="bar-label">SHIELD</div>
                        <div class="shield-bar">
                            <div class="shield-fill" id="shield-fill" style="width: 100%"></div>
                            <span class="bar-value" id="shield-value">100</span>
                        </div>
                    </div>
                    <!-- V4 INFINITE: Gold Display -->
                    <div class="gold-display">
                        <span class="gold-icon-hud">ðŸ’°</span>
                        <span id="gold-value">0</span>
                    </div>
                </div>

                <div class="hud-top-right">
                    <div class="wave-label">WAVE</div>
                    <div class="wave-display"><span id="wave-number">1</span></div>
                    <div class="time-display" id="time-display">00:00</div>
                </div>

                <div class="hud-bottom-center">
                    <div class="combo-display">Ã—<span id="combo-count">0</span></div>
                    <div class="combo-label">COMBO</div>
                    <div class="charge-bar">
                        <div class="charge-fill" id="charge-fill" style="width: 0%"></div>
                    </div>
                    <div class="charge-label">TEMPORAL CHARGE</div>
                    <div class="ability-bar">
                        <div class="ability-slot" id="ability-q">
                            <div class="ability-cooldown" id="ability-q-cooldown"></div>
                            <span class="ability-key">Q</span>
                            <span class="ability-icon">âš¡</span>
                            <span class="ability-cost">25</span>
                        </div>
                        <div class="ability-slot" id="ability-e">
                            <div class="ability-cooldown" id="ability-e-cooldown"></div>
                            <span class="ability-key">E</span>
                            <span class="ability-icon">ðŸ‘»</span>
                            <span class="ability-cost">50</span>
                        </div>
                        <div class="ability-slot" id="ability-r">
                            <div class="ability-cooldown" id="ability-r-cooldown"></div>
                            <span class="ability-key">R</span>
                            <span class="ability-icon">â±</span>
                            <span class="ability-cost">75</span>
                        </div>
                    </div>
                </div>

                <div class="hud-bottom-right">
                    <div class="score-label">SCORE</div>
                    <div class="score-display"><span id="score-display">0</span></div>
                </div>

                <!-- V2 Weapon Display -->
                <div class="weapon-display">
                    <div class="weapon-slot active" id="weapon-blade" data-weapon="blade">
                        <span class="weapon-icon">âš”</span>
                        <div class="weapon-info">
                            <span class="weapon-name">TEMPORAL BLADE</span>
                            <span class="weapon-key">1 / SCROLL</span>
                        </div>
                    </div>
                    <div class="weapon-slot" id="weapon-pistol" data-weapon="pistol">
                        <span class="weapon-icon">ðŸ”«</span>
                        <div class="weapon-info">
                            <span class="weapon-name">CHRONO PISTOL</span>
                            <span class="weapon-key">2 / SCROLL</span>
                        </div>
                        <span class="weapon-ammo" id="pistol-ammo">30/30</span>
                    </div>
                    <div class="weapon-slot" id="weapon-scythe" data-weapon="scythe">
                        <span class="weapon-icon">âš°</span>
                        <div class="weapon-info">
                            <span class="weapon-name">VOID SCYTHE</span>
                            <span class="weapon-key">3 / SCROLL</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Crosshair -->
            <div id="crosshair"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CHRONOPHAGE â€” The Time Devourer
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ CONFIGURATION V2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CONFIG = {
    // Arena
    arenaRadius: 40,
    pillarCount: 12,
    fogNear: 20,
    fogFar: 80,
    fogColor: 0x0a0a1a,

    // Camera V2 - Proper third-person follow
    cameraDistance: 12,
    cameraHeight: 5,
    cameraMinDistance: 5,
    cameraMaxDistance: 20,
    cameraSmoothness: 0.08,
    cameraPitchMin: 0.15,      // ~10 degrees
    cameraPitchMax: 1.4,       // ~80 degrees
    cameraDefaultPitch: 0.4,   // ~23 degrees
    cameraCombatPullback: 1.3, // Multiplier when enemies nearby
    cameraShakeRecovery: 8,    // How fast shake recovers

    // Player Movement
    playerSpeed: 12,
    sprintMultiplier: 1.67,
    dashDistance: 6,
    dashDuration: 0.2,
    dashCooldown: 1.5,
    dashStaminaCost: 25,

    // Player Health by Difficulty
    playerHealth: {
        easy: 150,
        normal: 100,
        hard: 75,
        nightmare: 50
    },

    // Health Regeneration
    healthRegen: {
        easy: 3,
        normal: 1,
        hard: 0,
        nightmare: 0
    },
    regenDelay: 4, // seconds out of combat before regen starts

    // Stamina
    maxStamina: 100,
    staminaRegen: 35,
    staminaRegenDelay: 0.6,
    staminaRegenMultiplier: {
        easy: 1.5,
        normal: 1.0,
        hard: 0.75,
        nightmare: 0.75
    },

    // Temporal Charge
    maxCharge: 100,
    chargePerHit: 5,
    chargePerKill: 15,
    chargeDecay: 3,
    chargeGainMultiplier: {
        easy: 1.5,
        normal: 1.0,
        hard: 1.0,
        nightmare: 0.8
    },

    // Weapons V2
    weapons: {
        blade: {
            name: 'Temporal Blade',
            lightDamage: 25,  // 2 hits to kill on Normal
            heavyDamage: 45,  // 1 hit to kill on Normal (was 60)
            range: 3,
            arc: 120,
            lightStamina: 12,
            heavyStamina: 30,
            chargeGain: 1.0 // Fastest charge builder
        },
        pistol: {
            name: 'Chrono Pistol',
            damage: 25,  // 2 hits to kill on Normal (was 15)
            fireRate: 3, // shots per second
            maxAmmo: 30,
            reloadTime: 1.5,
            range: 50,
            chargeGain: 0.5
        },
        scythe: {
            name: 'Void Scythe',
            damage: 35,  // Higher damage to compensate for slower attack
            attackSpeed: 0.5, // swings per second (slower - longer windup)
            range: 5,
            arc: 360,  // Full circle attack
            staminaCost: 50,
            slowEffect: 0.3, // 30% slow
            slowDuration: 2,
            healOnTrail: 2,
            chargeGain: 0.7
        }
    },

    // Temporal Abilities
    timeFractureCost: 25,
    timeFractureDamage: 30,
    timeFractureRadius: 5,
    timeFractureCooldown: 8,

    temporalEchoCost: 50,
    temporalEchoDuration: 2,
    temporalEchoCooldown: 15,

    chronostasisCost: 75,
    chronostasisDuration: 3,
    chronostasisPlayerSpeed: 1.0,  // Player moves at full speed while enemies frozen
    chronostasisCooldown: 25,

    // Combo
    comboDecayTime: 4,
    moteTimeExtend: 2,

    // Wave System
    wavePrepTime: 3,
    waveIntervalTime: 5,
    baseWaveEnemies: 4,
    enemiesPerWave: 2,
    maxEnemiesAlive: 6,
    waveCompletionBonus: 500,

    // Difficulty Multipliers
    // Enemy health scaled so basic enemies die in: Easy=1hit, Normal=2hits, Hard=3hits, Nightmare=4hits
    difficulty: {
        easy: {
            enemyDamage: 0.7,
            enemySpeed: 0.8,
            enemyHealth: 0.5,  // 1-hit kills with light attack
            waveCountMod: -2,
            telegraphTime: 1.2 // Longer telegraphs
        },
        normal: {
            enemyDamage: 1.0,
            enemySpeed: 1.0,
            enemyHealth: 1.0,  // 2-hit kills with light attack
            waveCountMod: 0,
            telegraphTime: 1.0
        },
        hard: {
            enemyDamage: 1.25,
            enemySpeed: 1.15,
            enemyHealth: 1.5,  // 3-hit kills with light attack
            waveCountMod: 2,
            telegraphTime: 0.8 // Shorter telegraphs
        },
        nightmare: {
            enemyDamage: 1.5,
            enemySpeed: 1.3,
            enemyHealth: 2.0,  // 4-hit kills with light attack
            waveCountMod: 4,
            telegraphTime: 0.6,
            executeThreshold: 0.2 // One-hit kill below 20% HP
        }
    },

    // Post Processing V2
    bloom: {
        enabled: true,
        threshold: 0.8,
        intensity: 1.5,
        radius: 0.5
    },
    vignette: {
        enabled: true,
        intensity: 0.3,
        lowHealthIntensity: 0.6
    },
    chromaticAberration: {
        enabled: true,
        baseIntensity: 0.002,
        damageIntensity: 0.01
    },

    // Visual V2
    trailSegments: 15,
    particlePoolSize: 800,
    motePoolSize: 100,
    ambientParticles: 500,
    combatParticlesPerHit: 50,
    deathParticles: 100,

    // V4: INSANE GRAPHICS CONFIG
    graphics: {
        // Combat particles
        hitSparkCount: 30,
        killExplosionCount: 80,
        criticalHitMultiplier: 2.5,

        // Trails
        weaponTrailLength: 25,
        dashTrailLength: 15,
        projectileTrailLength: 10,

        // Screen effects
        killStreakSlowMo: true,
        impactFrames: true,
        screenShakeIntensity: 1.2,

        // Environment
        arenaEvolution: true,
        voidCreep: true,
        temporalStorms: true,
        realityTears: true,

        // Lighting
        dynamicLighting: true,
        combatLightFlashes: true,
        bossPhaseAmbience: true,

        // Particles
        ambientMoteCount: 400,
        floatingDebrisCount: 50,
        temporalStreamDensity: 25
    },

    // Audio V2
    masterVolume: 0.8,
    sfxVolume: 0.8,
    musicVolume: 1.0, // Louder music
    spatialAudio: true,

    // V6: Graphics Quality Presets
    graphicsQuality: {
        low: {
            shadows: false,
            shadowMapSize: 512,
            particleMultiplier: 0.25,
            maxDynamicLights: 0,
            trailsEnabled: false,
            ambientParticles: 50,
            hitSparkCount: 8,
            killExplosionCount: 20,
            screenShakeIntensity: 0.5,
            healthBarUpdate: 'onchange', // only update when health changes
            postProcessing: false
        },
        medium: {
            shadows: true,
            shadowMapSize: 1024,
            particleMultiplier: 0.5,
            maxDynamicLights: 4,
            trailsEnabled: true,
            ambientParticles: 200,
            hitSparkCount: 15,
            killExplosionCount: 40,
            screenShakeIntensity: 0.8,
            healthBarUpdate: 'onchange',
            postProcessing: true
        },
        high: {
            shadows: true,
            shadowMapSize: 2048,
            particleMultiplier: 1.0,
            maxDynamicLights: 8,
            trailsEnabled: true,
            ambientParticles: 400,
            hitSparkCount: 30,
            killExplosionCount: 80,
            screenShakeIntensity: 1.2,
            healthBarUpdate: 'onchange',
            postProcessing: true
        }
    }
};

// â”€â”€â”€ GRAPHICS QUALITY STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentGraphicsQuality = 'medium'; // Default to medium for balance

function getGraphicsSetting(key) {
    return CONFIG.graphicsQuality[currentGraphicsQuality][key];
}

function setGraphicsQuality(quality) {
    if (CONFIG.graphicsQuality[quality]) {
        currentGraphicsQuality = quality;
        localStorage.setItem('chronophage_graphics', quality);
        return true;
    }
    return false;
}

// Load saved graphics setting
(function loadGraphicsSetting() {
    const saved = localStorage.getItem('chronophage_graphics');
    if (saved && CONFIG.graphicsQuality[saved]) {
        currentGraphicsQuality = saved;
    }
})();

// â”€â”€â”€ DIFFICULTY STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let currentDifficulty = 'normal';
let nightmareUnlocked = false;

// Helper to get difficulty-adjusted value
function getDifficultyValue(baseValue, multiplierKey) {
    const mult = CONFIG.difficulty[currentDifficulty][multiplierKey];
    return mult !== undefined ? baseValue * mult : baseValue;
}

function getPlayerMaxHealth() {
    return CONFIG.playerHealth[currentDifficulty];
}

function getHealthRegenRate() {
    return CONFIG.healthRegen[currentDifficulty];
}

function getStaminaRegenMultiplier() {
    return CONFIG.staminaRegenMultiplier[currentDifficulty];
}

function getChargeGainMultiplier() {
    return CONFIG.chargeGainMultiplier[currentDifficulty];
}

// â”€â”€â”€ UTILITY CLASSES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Vec3 {
    static add(a, b) {
        return new THREE.Vector3(a.x + b.x, a.y + b.y, a.z + b.z);
    }

    static sub(a, b) {
        return new THREE.Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }

    static scale(v, s) {
        return new THREE.Vector3(v.x * s, v.y * s, v.z * s);
    }

    static length(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    }

    static normalize(v) {
        const len = Vec3.length(v);
        if (len === 0) return new THREE.Vector3(0, 0, 0);
        return Vec3.scale(v, 1 / len);
    }

    static distance(a, b) {
        return Vec3.length(Vec3.sub(a, b));
    }

    static lerp(a, b, t) {
        return new THREE.Vector3(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t,
            a.z + (b.z - a.z) * t
        );
    }
}

// â”€â”€â”€ GAME STATE â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const GameState = {
    MENU: 'menu',
    PLAYING: 'playing',
    PAUSED: 'paused',
    GAMEOVER: 'gameover',
    INVENTORY: 'inventory',
    SHOP: 'shop'
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// V4: CHRONOPHAGE INFINITE - LOOT SYSTEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€â”€ V4: SHIELD CONFIGURATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const SHIELD_CONFIG = {
    // Base stats (modified by equipped shield)
    baseShieldHealth: 100,      // Base shield HP
    baseDamageReduction: 0.7,   // 70% damage blocked

    // Regeneration
    regenRate: 15,              // HP per second when not blocking
    regenDelay: 1.5,            // Seconds after releasing block

    // Blocking behavior
    blockArc: 120,              // Degrees in front of player
    movementPenalty: 0.5,       // 50% move speed while blocking

    // Perfect Block (timing-based)
    perfectBlockWindow: 150,    // Milliseconds to hit perfect block
    perfectBlockMultiplier: 1.0,// Perfect blocks fully negate damage
    counterWindow: 500,         // Milliseconds to counter after perfect block

    // Shield Break
    breakRecoveryTime: 3.0      // Seconds to recover from shield break
};

// â”€â”€â”€ V4: ITEM RARITY SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const RARITY = {
    COMMON: {
        name: 'Common',
        color: '#ffffff',
        dropWeight: 60,
        statBonus: { min: 0, max: 0.10 },
        abilitySlots: 0,
        glowIntensity: 0,
        sellValue: 10,
        sellPercent: 0.50  // Common items sell for 50% of shop price
    },
    UNCOMMON: {
        name: 'Uncommon',
        color: '#00ff00',
        dropWeight: 25,
        statBonus: { min: 0.10, max: 0.25 },
        abilitySlots: 1,
        glowIntensity: 0.3,
        sellValue: 25,
        sellPercent: 0.55  // Uncommon: 55%
    },
    RARE: {
        name: 'Rare',
        color: '#0088ff',
        dropWeight: 10,
        statBonus: { min: 0.25, max: 0.50 },
        abilitySlots: 1,
        glowIntensity: 0.5,
        sellValue: 75,
        sellPercent: 0.60  // Rare: 60%
    },
    EPIC: {
        name: 'Epic',
        color: '#aa00ff',
        dropWeight: 4,
        statBonus: { min: 0.50, max: 1.00 },
        abilitySlots: 2,
        glowIntensity: 0.7,
        sellValue: 200,
        sellPercent: 0.65  // Epic: 65%
    },
    LEGENDARY: {
        name: 'Legendary',
        color: '#ffaa00',
        dropWeight: 0.9,
        statBonus: { min: 1.00, max: 2.00 },
        abilitySlots: 2,
        glowIntensity: 1.0,
        beamOfLight: true,
        sellValue: 500,
        sellPercent: 0.70  // Legendary: 70%
    },
    TEMPORAL: {
        name: 'Temporal',
        color: '#00ffff',
        dropWeight: 0.1,
        statBonus: { min: 2.00, max: 5.00 },
        abilitySlots: 3,
        glowIntensity: 1.5,
        beamOfLight: true,
        realityDistortion: true,
        unique: true,
        sellValue: 1000,
        sellPercent: 0.70  // Temporal: 70%
    }
};

// â”€â”€â”€ V4: UTILITY FUNCTIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function generateUUID() {
    return 'item_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
}

function randomInRange(min, max) {
    return min + Math.random() * (max - min);
}

function formatStatName(stat) {
    const names = {
        damage: 'Damage',
        attackSpeed: 'Attack Speed',
        range: 'Range',
        staminaCost: 'Stamina Cost',
        critChance: 'Crit Chance',
        critDamage: 'Crit Damage',
        fireRate: 'Fire Rate',
        magazineSize: 'Magazine',
        reloadTime: 'Reload Time',
        maxHealth: 'Max Health',
        damageReduction: 'Damage Reduction',
        moveSpeed: 'Move Speed',
        dashCharges: 'Dash Charges',
        dashDistance: 'Dash Distance',
        dashCooldown: 'Dash Cooldown',
        temporalChargeGain: 'Charge Gain',
        lifesteal: 'Lifesteal',
        maxEnergy: 'Shield Energy',
        regenRate: 'Shield Regen',
        abilityCooldown: 'Ability Cooldown'
    };
    return names[stat] || stat.charAt(0).toUpperCase() + stat.slice(1);
}

function isPercentStat(stat) {
    return ['critChance', 'critDamage', 'damageReduction', 'moveSpeed', 'lifesteal',
            'temporalChargeGain', 'dashCooldown', 'abilityCooldown', 'attackSpeed'].includes(stat);
}

// â”€â”€â”€ V4: ITEM TEMPLATES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

// SWORD TEMPLATES
const SWORD_TEMPLATES = {
    temporal_blade: {
        id: 'temporal_blade',
        name: 'Temporal Blade',
        type: 'weapon',
        subtype: 'sword',
        icon: 'âš”ï¸',
        baseStats: {
            damage: 25,
            attackSpeed: 1.0,
            range: 3,
            staminaCost: 12
        },
        inherentAbility: {
            name: 'Time Siphon',
            description: '+20% temporal charge gain on hit'
        },
        description: 'Standard Guardian blade infused with crystallized time.',
        lore: 'Forged in the moment between seconds.'
    },

    clockwork_saber: {
        id: 'clockwork_saber',
        name: 'Clockwork Saber',
        type: 'weapon',
        subtype: 'sword',
        minRarity: 'UNCOMMON',
        icon: 'âš”ï¸',
        baseStats: {
            damage: 18,
            attackSpeed: 1.5,
            range: 2.5,
            staminaCost: 10
        },
        inherentAbility: {
            name: 'Precision Strike',
            description: 'Every 5th hit deals double damage'
        },
        description: 'A blade of interlocking gears.',
        lore: 'Tick. Tick. Tick. Tick. STRIKE.'
    },

    grandfathers_edge: {
        id: 'grandfathers_edge',
        name: "Grandfather's Edge",
        type: 'weapon',
        subtype: 'sword',
        minRarity: 'RARE',
        icon: 'âš”ï¸',
        baseStats: {
            damage: 55,
            attackSpeed: 0.6,
            range: 4,
            staminaCost: 25
        },
        inherentAbility: {
            name: 'Tolling Strike',
            description: 'Attacks stagger enemies. Kills create shockwave.'
        },
        description: 'A massive blade torn from a fallen Grandfather.',
        lore: 'It still chimes on the hour.'
    },

    hour_devourer: {
        id: 'hour_devourer',
        name: 'Hour Devourer',
        type: 'weapon',
        subtype: 'sword',
        minRarity: 'LEGENDARY',
        icon: 'âš”ï¸',
        baseStats: {
            damage: 100,
            attackSpeed: 0.4,
            range: 5,
            staminaCost: 25
        },
        inherentAbility: {
            name: 'Consume Time',
            description: 'Each kill grants +5 damage (max +50). Damage resets stacks.'
        },
        description: 'This greatsword grows hungrier with each soul.',
        lore: 'Forged from the final hour of a dying universe.'
    },

    rusty_blade: {
        id: 'rusty_blade',
        name: 'Rusty Blade',
        type: 'weapon',
        subtype: 'sword',
        icon: 'âš”ï¸',
        baseStats: {
            damage: 15,
            attackSpeed: 1.2,
            range: 2.5,
            staminaCost: 8
        },
        description: 'A worn blade, still sharp enough.',
        lore: 'Time corrodes all things.'
    },

    minute_cutter: {
        id: 'minute_cutter',
        name: 'Minute Cutter',
        type: 'weapon',
        subtype: 'sword',
        minRarity: 'UNCOMMON',
        icon: 'âš”ï¸',
        baseStats: {
            damage: 22,
            attackSpeed: 1.3,
            range: 2.8,
            staminaCost: 10
        },
        inherentAbility: {
            name: 'Quick Slash',
            description: '+15% attack speed after dodge'
        },
        description: 'A swift blade for precise cuts.',
        lore: 'Sixty cuts per minute, if you can keep up.'
    },

    epoch_breaker: {
        id: 'epoch_breaker',
        name: 'Epoch Breaker',
        type: 'weapon',
        subtype: 'sword',
        minRarity: 'EPIC',
        icon: 'âš”ï¸',
        baseStats: {
            damage: 65,
            attackSpeed: 0.7,
            range: 4.5,
            staminaCost: 22
        },
        inherentAbility: {
            name: 'Era Shatter',
            description: 'Critical hits create time rifts dealing 30 AOE damage'
        },
        description: 'Heavy blade that fractures timelines.',
        lore: 'Every swing ends an era.'
    },

    infinity_edge: {
        id: 'infinity_edge',
        name: 'Infinity Edge',
        type: 'weapon',
        subtype: 'sword',
        minRarity: 'TEMPORAL',
        icon: 'âš”ï¸',
        baseStats: {
            damage: 150,
            attackSpeed: 0.5,
            range: 6,
            staminaCost: 30,
            critChance: 25
        },
        inherentAbility: {
            name: 'Endless Loop',
            description: 'Kills reset attack cooldown. Every 10 kills = full heal.'
        },
        description: 'A blade that exists in all moments simultaneously.',
        lore: 'The end is just another beginning.'
    }
};

// GUN TEMPLATES
const GUN_TEMPLATES = {
    chrono_pistol: {
        id: 'chrono_pistol',
        name: 'Chrono Pistol',
        type: 'weapon',
        subtype: 'gun',
        icon: 'ðŸ”«',
        baseStats: {
            damage: 15,
            fireRate: 3.0,
            magazineSize: 12,
            reloadTime: 1.5,
            range: 50
        },
        inherentAbility: null,
        description: 'Standard-issue sidearm for Temporal Guardians.',
        lore: 'Point. Click. Erase from timeline.'
    },

    tick_repeater: {
        id: 'tick_repeater',
        name: 'Tick Repeater',
        type: 'weapon',
        subtype: 'gun',
        minRarity: 'UNCOMMON',
        icon: 'ðŸ”«',
        baseStats: {
            damage: 10,
            fireRate: 5.0,
            magazineSize: 18,
            reloadTime: 1.8,
            range: 40
        },
        inherentAbility: {
            name: 'Focused Burst',
            description: '3 hits on same target = +15 bonus damage'
        },
        description: 'A burst-fire pistol mimicking rapid ticking.',
        lore: 'Three shots. Three moments. One death.'
    },

    midnight_striker: {
        id: 'midnight_striker',
        name: 'Midnight Striker',
        type: 'weapon',
        subtype: 'gun',
        minRarity: 'LEGENDARY',
        icon: 'ðŸ”«',
        baseStats: {
            damage: 120,
            fireRate: 0.5,
            magazineSize: 1,
            reloadTime: 0.8,
            range: 70
        },
        inherentAbility: {
            name: 'Witching Hour',
            description: 'Kills instantly reload. 3 kills in 5s = AOE shot.'
        },
        description: 'Strikes with the weight of midnight.',
        lore: 'When the clock strikes twelve, something dies.'
    },

    worn_sidearm: {
        id: 'worn_sidearm',
        name: 'Worn Sidearm',
        type: 'weapon',
        subtype: 'gun',
        icon: 'ðŸ”«',
        baseStats: {
            damage: 12,
            fireRate: 2.5,
            magazineSize: 8,
            reloadTime: 2.0,
            range: 35
        },
        description: 'An old but reliable pistol.',
        lore: 'Seen better days, still shoots straight.'
    },

    second_hand: {
        id: 'second_hand',
        name: 'Second Hand',
        type: 'weapon',
        subtype: 'gun',
        minRarity: 'RARE',
        icon: 'ðŸ”«',
        baseStats: {
            damage: 25,
            fireRate: 4.0,
            magazineSize: 15,
            reloadTime: 1.2,
            range: 45
        },
        inherentAbility: {
            name: 'Tick Tock',
            description: 'Alternating shots deal +20% damage'
        },
        description: 'Fires in perfect rhythm.',
        lore: 'One, two. One, two. Dead.'
    },

    temporal_cannon: {
        id: 'temporal_cannon',
        name: 'Temporal Cannon',
        type: 'weapon',
        subtype: 'gun',
        minRarity: 'EPIC',
        icon: 'ðŸ”«',
        baseStats: {
            damage: 80,
            fireRate: 1.0,
            magazineSize: 4,
            reloadTime: 2.5,
            range: 60
        },
        inherentAbility: {
            name: 'Time Blast',
            description: 'Shots explode on impact, slowing enemies 40%'
        },
        description: 'Heavy temporal energy projector.',
        lore: 'Makes time stand still. Permanently.'
    },

    eternity_revolver: {
        id: 'eternity_revolver',
        name: 'Eternity Revolver',
        type: 'weapon',
        subtype: 'gun',
        minRarity: 'TEMPORAL',
        icon: 'ðŸ”«',
        baseStats: {
            damage: 200,
            fireRate: 0.8,
            magazineSize: 6,
            reloadTime: 1.0,
            range: 80
        },
        inherentAbility: {
            name: 'Infinite Chamber',
            description: 'Never needs reloading. Crits pierce all enemies in line.'
        },
        description: 'Six shots that never end.',
        lore: 'Each bullet returns to the chamber before it leaves.'
    }
};

// SCYTHE TEMPLATES
const SCYTHE_TEMPLATES = {
    void_scythe: {
        id: 'void_scythe',
        name: 'Void Scythe',
        type: 'weapon',
        subtype: 'scythe',
        minRarity: 'RARE',
        icon: 'âš°ï¸',
        baseStats: {
            damage: 80,
            attackSpeed: 0.8,
            range: 5,
            staminaCost: 40
        },
        inherentAbility: {
            name: 'Void Touch',
            description: 'Hits in 180Â° arc. Slows enemies 30% for 2s.'
        },
        description: 'A scythe that cuts through reality itself.',
        lore: 'The void hungers.'
    },

    chrono_harvester: {
        id: 'chrono_harvester',
        name: 'Chrono Harvester',
        type: 'weapon',
        subtype: 'scythe',
        minRarity: 'LEGENDARY',
        icon: 'âš°ï¸',
        baseStats: {
            damage: 70,
            attackSpeed: 0.9,
            range: 5,
            staminaCost: 30,
            lifesteal: 15
        },
        inherentAbility: {
            name: 'Time Drain',
            description: 'Heal 15% of damage dealt. Elite kills heal 50 HP.'
        },
        description: 'Drinks the remaining time of its victims.',
        lore: 'Your seconds become my years.'
    },

    apprentice_scythe: {
        id: 'apprentice_scythe',
        name: 'Apprentice Scythe',
        type: 'weapon',
        subtype: 'scythe',
        icon: 'âš°ï¸',
        baseStats: {
            damage: 40,
            attackSpeed: 0.6,
            range: 4,
            staminaCost: 35
        },
        description: 'A training scythe for aspiring reapers.',
        lore: 'Everyone starts somewhere.'
    },

    clock_reaper: {
        id: 'clock_reaper',
        name: 'Clock Reaper',
        type: 'weapon',
        subtype: 'scythe',
        minRarity: 'UNCOMMON',
        icon: 'âš°ï¸',
        baseStats: {
            damage: 55,
            attackSpeed: 0.7,
            range: 4.5,
            staminaCost: 38
        },
        inherentAbility: {
            name: 'Pendulum',
            description: 'Hits swing back, dealing 50% damage again'
        },
        description: 'Swings like a pendulum of death.',
        lore: 'Back and forth, until time stops.'
    },

    deaths_second: {
        id: 'deaths_second',
        name: "Death's Second",
        type: 'weapon',
        subtype: 'scythe',
        minRarity: 'EPIC',
        icon: 'âš°ï¸',
        baseStats: {
            damage: 90,
            attackSpeed: 0.75,
            range: 5.5,
            staminaCost: 45
        },
        inherentAbility: {
            name: 'Soul Rend',
            description: 'Killed enemies explode, dealing 40% of their max HP to nearby foes'
        },
        description: 'The grim reaper lends his spare.',
        lore: 'Death always comes twice.'
    },

    eternity_scythe: {
        id: 'eternity_scythe',
        name: 'Eternity Scythe',
        type: 'weapon',
        subtype: 'scythe',
        minRarity: 'TEMPORAL',
        icon: 'âš°ï¸',
        baseStats: {
            damage: 120,
            attackSpeed: 0.8,
            range: 7,
            staminaCost: 50,
            lifesteal: 25
        },
        inherentAbility: {
            name: 'Eternal Harvest',
            description: 'Full circle attack. Kills grant temporary invulnerability (0.5s per kill).'
        },
        description: 'A weapon from the end of time itself.',
        lore: 'When everything dies, only the harvester remains.'
    }
};

// SHIELD TEMPLATES
const SHIELD_TEMPLATES = {
    guardian_aegis: {
        id: 'guardian_aegis',
        name: "Guardian's Aegis",
        type: 'shield',
        icon: 'ðŸ›¡ï¸',
        baseStats: {
            maxEnergy: 100,
            damageReduction: 70,
            regenRate: 15
        },
        inherentAbility: {
            name: 'Temporal Barrier',
            description: 'Create shield wall blocking projectiles for 5s'
        },
        description: 'Standard Guardian shield. Reliable protection.',
        lore: "A Guardian's first and last line of defense."
    },

    chrono_buckler: {
        id: 'chrono_buckler',
        name: 'Chrono Buckler',
        type: 'shield',
        minRarity: 'UNCOMMON',
        icon: 'ðŸ›¡ï¸',
        baseStats: {
            maxEnergy: 75,
            damageReduction: 60,
            regenRate: 25
        },
        inherentAbility: {
            name: 'Counter Pulse',
            description: 'Perfect blocks release damage wave (20 dmg)'
        },
        description: 'A smaller shield rewarding precise timing.',
        lore: 'Fortune favors the quick.'
    },

    void_mirror: {
        id: 'void_mirror',
        name: 'Void Mirror',
        type: 'shield',
        minRarity: 'EPIC',
        icon: 'ðŸ›¡ï¸',
        baseStats: {
            maxEnergy: 100,
            damageReduction: 75,
            regenRate: 20
        },
        inherentAbility: {
            name: 'Reflection',
            description: 'Return 50% blocked damage. Perfect = 100% homing.'
        },
        description: 'Crystallized void that reflects aggression.',
        lore: 'Gaze into the void. The void gazes back. And shoots.'
    },

    eternitys_gate: {
        id: 'eternitys_gate',
        name: "Eternity's Gate",
        type: 'shield',
        minRarity: 'LEGENDARY',
        icon: 'ðŸ›¡ï¸',
        baseStats: {
            maxEnergy: 200,
            damageReduction: 90,
            regenRate: 30
        },
        inherentAbility: {
            name: 'Dimensional Shift',
            description: 'Become intangible for 2s. Blocking heals 5 HP/s.'
        },
        description: 'A portal where damage cannot exist.',
        lore: 'Step through. Leave your wounds behind.'
    }
};

// HELMET TEMPLATES
const HELMET_TEMPLATES = {
    guardian_hood: {
        id: 'guardian_hood',
        name: 'Guardian Hood',
        type: 'helmet',
        icon: 'â›‘ï¸',
        baseStats: { maxHealth: 10 },
        description: 'Standard protective headgear.'
    },

    clockwork_crown: {
        id: 'clockwork_crown',
        name: 'Clockwork Crown',
        type: 'helmet',
        minRarity: 'RARE',
        icon: 'ðŸ‘‘',
        baseStats: { maxHealth: 25, temporalChargeGain: 10 },
        inherentAbility: {
            name: 'Mechanical Sight',
            description: 'Enemy weak points highlighted'
        }
    },

    chronophage_skull: {
        id: 'chronophage_skull',
        name: 'Chronophage Skull',
        type: 'helmet',
        minRarity: 'LEGENDARY',
        icon: 'ðŸ’€',
        baseStats: { maxHealth: 50, damage: 20 },
        inherentAbility: {
            name: 'Trophy Hunter',
            description: 'Boss kills grant +5 max HP permanently (up to +50)'
        }
    },

    tattered_cap: {
        id: 'tattered_cap',
        name: 'Tattered Cap',
        type: 'helmet',
        icon: 'ðŸ§¢',
        baseStats: { maxHealth: 5 },
        description: 'Better than nothing.',
        lore: 'Worn by countless warriors before you.'
    },

    brass_visor: {
        id: 'brass_visor',
        name: 'Brass Visor',
        type: 'helmet',
        minRarity: 'UNCOMMON',
        icon: 'ðŸ¥½',
        baseStats: { maxHealth: 15, critChance: 5 },
        inherentAbility: {
            name: 'Targeting System',
            description: '+10% ranged accuracy'
        },
        description: 'Enhanced vision goggles.',
        lore: 'See the seconds before they happen.'
    },

    time_warden_helm: {
        id: 'time_warden_helm',
        name: 'Time Warden Helm',
        type: 'helmet',
        minRarity: 'EPIC',
        icon: 'â›‘ï¸',
        baseStats: { maxHealth: 35, damageReduction: 10 },
        inherentAbility: {
            name: 'Foresight',
            description: 'Preview enemy attacks 0.5s early'
        },
        description: 'Helm of the Time Wardens.',
        lore: 'The future is always visible to those who look.'
    },

    eternity_crown: {
        id: 'eternity_crown',
        name: 'Eternity Crown',
        type: 'helmet',
        minRarity: 'TEMPORAL',
        icon: 'ðŸ‘‘',
        baseStats: { maxHealth: 75, damage: 30, temporalChargeGain: 25 },
        inherentAbility: {
            name: 'Timeless Mind',
            description: 'All abilities cost 25% less. Cooldowns reduced 20%.'
        },
        description: 'Crown of the Eternal King.',
        lore: 'He who wears this rules all of time.'
    }
};

// ARMOR TEMPLATES
const ARMOR_TEMPLATES = {
    guardian_robes: {
        id: 'guardian_robes',
        name: 'Guardian Robes',
        type: 'armor',
        icon: 'ðŸ¦º',
        baseStats: { maxHealth: 15, damageReduction: 5 },
        description: 'Standard Guardian vestments.'
    },

    brass_clockwork_plate: {
        id: 'brass_clockwork_plate',
        name: 'Brass Clockwork Plate',
        type: 'armor',
        minRarity: 'RARE',
        icon: 'ðŸ¦º',
        baseStats: { maxHealth: 40, damageReduction: 15 },
        inherentAbility: {
            name: 'Second Chance',
            description: 'Fatal damage = 1 HP instead (once per wave)'
        }
    },

    grandfathers_embrace: {
        id: 'grandfathers_embrace',
        name: "Grandfather's Embrace",
        type: 'armor',
        minRarity: 'LEGENDARY',
        icon: 'ðŸ¦º',
        baseStats: { maxHealth: 75, damageReduction: 25 },
        inherentAbility: {
            name: 'Temporal Dodge',
            description: 'Auto-block one attack every 60s. 15% miss chance.'
        }
    },

    worn_tunic: {
        id: 'worn_tunic',
        name: 'Worn Tunic',
        type: 'armor',
        icon: 'ðŸ‘•',
        baseStats: { maxHealth: 8, damageReduction: 2 },
        description: 'A simple cloth tunic.',
        lore: 'Barely protection, but it is something.'
    },

    temporal_vest: {
        id: 'temporal_vest',
        name: 'Temporal Vest',
        type: 'armor',
        minRarity: 'UNCOMMON',
        icon: 'ðŸ¦º',
        baseStats: { maxHealth: 25, damageReduction: 8 },
        inherentAbility: {
            name: 'Quick Recovery',
            description: 'Regenerate 2 HP/s when not taking damage for 3s'
        },
        description: 'Lightweight temporal-weave armor.',
        lore: 'Bends time around impacts.'
    },

    chrono_mail: {
        id: 'chrono_mail',
        name: 'Chrono Mail',
        type: 'armor',
        minRarity: 'EPIC',
        icon: 'ðŸ¦º',
        baseStats: { maxHealth: 55, damageReduction: 18 },
        inherentAbility: {
            name: 'Time Shield',
            description: 'Taking fatal damage rewinds 2s instead (60s cooldown)'
        },
        description: 'Heavy chronosteel chainmail.',
        lore: 'Forged in frozen moments.'
    },

    eternity_plate: {
        id: 'eternity_plate',
        name: 'Eternity Plate',
        type: 'armor',
        minRarity: 'TEMPORAL',
        icon: 'ðŸ¦º',
        baseStats: { maxHealth: 100, damageReduction: 35 },
        inherentAbility: {
            name: 'Immortal Frame',
            description: 'Cannot die for 3s after dropping below 20% HP. 90s cooldown.'
        },
        description: 'Armor that defies death itself.',
        lore: 'Eternity has no end, and neither will you.'
    }
};

// BOOTS TEMPLATES
const BOOTS_TEMPLATES = {
    guardian_treads: {
        id: 'guardian_treads',
        name: 'Guardian Treads',
        type: 'boots',
        icon: 'ðŸ‘¢',
        baseStats: { moveSpeed: 5 },
        description: 'Standard Guardian footwear.'
    },

    swift_seconds: {
        id: 'swift_seconds',
        name: 'Swift Seconds',
        type: 'boots',
        minRarity: 'UNCOMMON',
        icon: 'ðŸ‘¢',
        baseStats: { moveSpeed: 10, dashCharges: 1 }
    },

    temporal_striders: {
        id: 'temporal_striders',
        name: 'Temporal Striders',
        type: 'boots',
        minRarity: 'EPIC',
        icon: 'ðŸ‘¢',
        baseStats: { moveSpeed: 20, dashCharges: 2, dashCooldown: -50 },
        inherentAbility: {
            name: 'Aftershock',
            description: 'Post-dash attack = +30% damage'
        }
    },

    boots_of_clock_king: {
        id: 'boots_of_clock_king',
        name: 'Boots of the Clock King',
        type: 'boots',
        minRarity: 'LEGENDARY',
        icon: 'ðŸ‘¢',
        baseStats: { moveSpeed: 25, dashCharges: 3 },
        inherentAbility: {
            name: 'Time Anchor',
            description: 'Hold dash for super-dash. Stand 2s to set teleport point.'
        }
    }
};

// TRINKET TEMPLATES
const TRINKET_TEMPLATES = {
    cracked_pocket_watch: {
        id: 'cracked_pocket_watch',
        name: 'Cracked Pocket Watch',
        type: 'trinket',
        icon: 'âŒš',
        baseStats: { attackSpeed: 5 },
        description: 'Still keeps decent time.'
    },

    oscillating_crystal: {
        id: 'oscillating_crystal',
        name: 'Oscillating Crystal',
        type: 'trinket',
        minRarity: 'UNCOMMON',
        icon: 'ðŸ’Ž',
        baseStats: { critDamage: 15 }
    },

    tocks_heart: {
        id: 'tocks_heart',
        name: "Tock's Heart",
        type: 'trinket',
        minRarity: 'RARE',
        icon: 'â¤ï¸',
        inherentAbility: {
            name: 'Life Hunter',
            description: '+25% health drop rate. Pickups heal 50% more.'
        }
    },

    chronophage_core: {
        id: 'chronophage_core',
        name: 'Chronophage Core',
        type: 'trinket',
        minRarity: 'LEGENDARY',
        icon: 'ðŸ”®',
        baseStats: { abilityCooldown: -25 },
        inherentAbility: {
            name: 'Temporal Surge',
            description: 'Using temporal ability restores 25 HP'
        }
    },

    shard_of_first_clock: {
        id: 'shard_of_first_clock',
        name: 'Shard of the First Clock',
        type: 'trinket',
        minRarity: 'LEGENDARY',
        icon: 'â±ï¸',
        inherentAbility: {
            name: 'Time Dilation',
            description: 'Time flows 20% slower for enemies (permanent)'
        }
    }
};

// â”€â”€â”€ V4: ITEM CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Item {
    constructor(template, rarity = 'COMMON') {
        this.id = generateUUID();
        this.templateId = template.id;
        this.template = template;
        this.name = template.name;
        this.type = template.type;
        this.subtype = template.subtype || template.type;
        this.icon = template.icon;
        this.rarity = rarity;
        this.level = 1;

        // Calculate stats with rarity bonus
        const rarityData = RARITY[rarity];
        const bonus = randomInRange(rarityData.statBonus.min, rarityData.statBonus.max);
        this.stats = {};
        if (template.baseStats) {
            for (const [stat, value] of Object.entries(template.baseStats)) {
                this.stats[stat] = Math.round(value * (1 + bonus));
            }
        }

        // Abilities
        this.abilities = [];
        if (template.inherentAbility) {
            this.abilities.push(template.inherentAbility);
        }

        // Flavor
        this.description = template.description || '';
        this.lore = template.lore || '';

        // Calculate value
        this.value = this.calculateValue();
    }

    calculateValue() {
        const rarityData = RARITY[this.rarity];
        let baseValue = rarityData.sellValue;

        // Add value based on stats
        if (this.stats) {
            const statTotal = Object.values(this.stats).reduce((a, b) => a + b, 0);
            baseValue += Math.floor(statTotal * 0.5);
        }

        return baseValue;
    }

    getTooltipData() {
        return {
            name: this.name,
            rarity: RARITY[this.rarity].name,
            color: RARITY[this.rarity].color,
            type: this.subtype,
            stats: this.stats,
            abilities: this.abilities,
            description: this.description,
            lore: this.lore,
            value: this.value
        };
    }
}

// â”€â”€â”€ V4: LOOT GENERATOR â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class LootGenerator {
    constructor() {
        this.allTemplates = {
            sword: SWORD_TEMPLATES,
            gun: GUN_TEMPLATES,
            scythe: SCYTHE_TEMPLATES,
            shield: SHIELD_TEMPLATES,
            helmet: HELMET_TEMPLATES,
            armor: ARMOR_TEMPLATES,
            boots: BOOTS_TEMPLATES,
            trinket: TRINKET_TEMPLATES
        };
    }

    rollRarity(waveBonus = 0) {
        // Wave-scaled rarity: higher waves = much better loot
        // Wave 1-5: mostly common/uncommon
        // Wave 6-10: rare becomes common
        // Wave 11-15: epic becomes achievable
        // Wave 16+: legendary/temporal possible
        const roll = Math.random() * 100 + waveBonus;

        // Thresholds decrease with wave bonus, making rare items more common
        const temporalThreshold = Math.max(99.5 - waveBonus * 0.5, 95);
        const legendaryThreshold = Math.max(98 - waveBonus * 1.0, 85);
        const epicThreshold = Math.max(92 - waveBonus * 1.5, 70);
        const rareThreshold = Math.max(80 - waveBonus * 2.0, 50);
        const uncommonThreshold = Math.max(50 - waveBonus * 2.5, 20);

        if (roll > temporalThreshold) return 'TEMPORAL';
        if (roll > legendaryThreshold) return 'LEGENDARY';
        if (roll > epicThreshold) return 'EPIC';
        if (roll > rareThreshold) return 'RARE';
        if (roll > uncommonThreshold) return 'UNCOMMON';
        return 'COMMON';
    }

    getRandomTemplate(type) {
        const templates = this.allTemplates[type];
        if (!templates) return null;

        const keys = Object.keys(templates);
        const randomKey = keys[Math.floor(Math.random() * keys.length)];
        return templates[randomKey];
    }

    generateItem(type = null, forcedRarity = null, waveNumber = 1) {
        // If no type specified, pick random
        if (!type) {
            const types = Object.keys(this.allTemplates);
            type = types[Math.floor(Math.random() * types.length)];
        }

        const template = this.getRandomTemplate(type);
        if (!template) return null;

        // Roll rarity (with wave bonus) - more aggressive scaling
        // Wave 5 = +5 bonus, Wave 10 = +10, Wave 20 = +20
        const waveBonus = Math.floor(waveNumber);
        let rarity = forcedRarity || this.rollRarity(waveBonus);

        // Check minimum rarity requirement
        if (template.minRarity) {
            const rarityOrder = ['COMMON', 'UNCOMMON', 'RARE', 'EPIC', 'LEGENDARY', 'TEMPORAL'];
            const minIndex = rarityOrder.indexOf(template.minRarity);
            const rolledIndex = rarityOrder.indexOf(rarity);
            if (rolledIndex < minIndex) {
                rarity = template.minRarity;
            }
        }

        return new Item(template, rarity);
    }

    generateLootDrop(enemyType, waveNumber) {
        // Determine drop chance based on enemy type
        let dropChance = 0.15; // 15% base
        if (enemyType === 'boss') dropChance = 1.0; // Bosses always drop
        else if (enemyType === 'grandfather') dropChance = 0.5;
        else if (enemyType === 'tock') dropChance = 0.25;

        if (Math.random() > dropChance) return null;

        // Determine item type
        const roll = Math.random();
        let type;
        if (roll < 0.35) type = 'weapon';
        else if (roll < 0.50) type = 'shield';
        else if (roll < 0.70) type = 'armor';
        else type = 'trinket';

        // For weapon, pick subtype
        if (type === 'weapon') {
            const weaponRoll = Math.random();
            if (weaponRoll < 0.5) type = 'sword';
            else if (weaponRoll < 0.8) type = 'gun';
            else type = 'scythe';
        }

        // For armor, pick subtype
        if (type === 'armor') {
            const armorRoll = Math.random();
            if (armorRoll < 0.33) type = 'helmet';
            else if (armorRoll < 0.66) type = 'armor';
            else type = 'boots';
        }

        return this.generateItem(type, null, waveNumber);
    }
}

// Global loot generator instance
const lootGenerator = new LootGenerator();

// â”€â”€â”€ SHIELD SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ShieldSystem {
    constructor(player) {
        this.player = player;
        this.isBlocking = false;
        this.blockStartTime = 0;
        this.isPerfectBlockWindow = false;
        this.isCounterWindow = false;
        this.isBroken = false;
        this.breakRecoveryTimer = 0;

        // Shield stats (can be modified by equipped shield)
        this.maxShieldHealth = SHIELD_CONFIG.baseShieldHealth;
        this.shieldHealth = this.maxShieldHealth;
        this.damageReduction = SHIELD_CONFIG.baseDamageReduction;
        this.perfectBlockMultiplier = SHIELD_CONFIG.perfectBlockMultiplier;

        // Equipped shield reference
        this.equippedShield = null;

        // Visual components
        this.shieldMesh = null;
        this.shieldGlow = null;
        this.hexagons = [];
        this.shieldOpacity = 0;
        this.targetOpacity = 0;

        // Effects
        this.hitEffects = [];
        this.perfectBlockFlash = 0;

        this.createShieldMesh();
    }

    createShieldMesh() {
        // Create holographic hexagonal shield
        const shieldGroup = new THREE.Group();

        // Main shield - curved hexagonal barrier
        const shieldGeometry = new THREE.SphereGeometry(1.2, 6, 4, 0, Math.PI, 0, Math.PI * 0.6);
        const shieldMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0,
            side: THREE.DoubleSide,
            wireframe: false
        });
        this.shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
        this.shieldMesh.rotation.x = -Math.PI * 0.2;
        shieldGroup.add(this.shieldMesh);

        // Hexagonal wireframe overlay
        const wireGeometry = new THREE.SphereGeometry(1.22, 6, 4, 0, Math.PI, 0, Math.PI * 0.6);
        const wireMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0,
            wireframe: true
        });
        this.shieldWire = new THREE.Mesh(wireGeometry, wireMaterial);
        this.shieldWire.rotation.x = -Math.PI * 0.2;
        shieldGroup.add(this.shieldWire);

        // Inner glow
        const glowGeometry = new THREE.SphereGeometry(1.1, 6, 4, 0, Math.PI, 0, Math.PI * 0.6);
        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ffff,
            transparent: true,
            opacity: 0,
            side: THREE.BackSide
        });
        this.shieldGlow = new THREE.Mesh(glowGeometry, glowMaterial);
        this.shieldGlow.rotation.x = -Math.PI * 0.2;
        shieldGroup.add(this.shieldGlow);

        // Create floating hexagon particles
        for (let i = 0; i < 8; i++) {
            const hexGeom = new THREE.CircleGeometry(0.08, 6);
            const hexMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0,
                side: THREE.DoubleSide
            });
            const hex = new THREE.Mesh(hexGeom, hexMat);
            hex.userData = {
                angle: (i / 8) * Math.PI * 2,
                radius: 0.9 + Math.random() * 0.3,
                speed: 0.5 + Math.random() * 0.5,
                yOffset: -0.3 + Math.random() * 0.6
            };
            shieldGroup.add(hex);
            this.hexagons.push(hex);
        }

        this.shieldGroup = shieldGroup;
        this.shieldGroup.visible = false;
    }

    attachToPlayer(playerMesh) {
        if (playerMesh && this.shieldGroup) {
            playerMesh.add(this.shieldGroup);
            this.shieldGroup.position.set(0, 0.5, 0.8);
        }
    }

    equipShield(shieldItem) {
        this.equippedShield = shieldItem;
        if (shieldItem) {
            // Apply shield stats
            this.maxShieldHealth = SHIELD_CONFIG.baseShieldHealth + (shieldItem.stats.shieldHealth || 0);
            this.shieldHealth = this.maxShieldHealth;
            this.damageReduction = SHIELD_CONFIG.baseDamageReduction + (shieldItem.stats.damageReduction || 0);

            // Update shield color based on rarity
            const rarityColor = new THREE.Color(RARITY[shieldItem.rarity].color);
            this.shieldMesh.material.color = rarityColor;
            this.shieldWire.material.color = rarityColor;
            this.shieldGlow.material.color = rarityColor;
            this.hexagons.forEach(hex => hex.material.color = rarityColor);
        } else {
            // Default shield
            this.maxShieldHealth = SHIELD_CONFIG.baseShieldHealth;
            this.shieldHealth = this.maxShieldHealth;
            this.damageReduction = SHIELD_CONFIG.baseDamageReduction;

            const defaultColor = new THREE.Color(0x00ffff);
            this.shieldMesh.material.color = defaultColor;
            this.shieldWire.material.color = defaultColor;
            this.shieldGlow.material.color = defaultColor;
            this.hexagons.forEach(hex => hex.material.color = defaultColor);
        }
    }

    startBlocking() {
        if (this.isBroken) return false;

        this.isBlocking = true;
        this.blockStartTime = performance.now();
        this.isPerfectBlockWindow = true;
        this.targetOpacity = 0.6;
        this.shieldGroup.visible = true;

        // Perfect block window timer
        setTimeout(() => {
            this.isPerfectBlockWindow = false;
        }, SHIELD_CONFIG.perfectBlockWindow);

        return true;
    }

    stopBlocking() {
        this.isBlocking = false;
        this.isPerfectBlockWindow = false;
        this.isCounterWindow = false;
        this.targetOpacity = 0;
    }

    absorbDamage(incomingDamage, attacker = null) {
        if (!this.isBlocking || this.isBroken) {
            return { blocked: false, damage: incomingDamage, isPerfect: false };
        }

        let blocked = true;
        let isPerfect = this.isPerfectBlockWindow;
        let finalDamage = 0;
        let shieldDamage = incomingDamage;

        if (isPerfect) {
            // Perfect block - no damage, no shield damage, counter window opens
            finalDamage = 0;
            shieldDamage = 0;
            this.isCounterWindow = true;
            this.perfectBlockFlash = 1.0;

            // Counter window timer
            setTimeout(() => {
                this.isCounterWindow = false;
            }, SHIELD_CONFIG.counterWindow);

            // Perfect block visual feedback
            this.createPerfectBlockEffect();

        } else {
            // Regular block - reduced damage, shield takes damage
            const reduction = this.damageReduction * this.perfectBlockMultiplier;
            finalDamage = Math.floor(incomingDamage * (1 - reduction));
            shieldDamage = incomingDamage * 0.5;

            // Regular block effect
            this.createBlockHitEffect();
        }

        // Apply damage to shield
        this.shieldHealth -= shieldDamage;

        // Check for shield break
        if (this.shieldHealth <= 0) {
            this.breakShield();
            blocked = false;
            finalDamage = incomingDamage * 0.5; // Half damage on break
        }

        return {
            blocked,
            damage: finalDamage,
            isPerfect,
            counterReady: isPerfect && this.isCounterWindow
        };
    }

    breakShield() {
        this.isBroken = true;
        this.isBlocking = false;
        this.shieldHealth = 0;
        this.breakRecoveryTimer = SHIELD_CONFIG.breakRecoveryTime;

        // Shield break effect
        this.createShieldBreakEffect();
    }

    createPerfectBlockEffect() {
        // Bright flash and hexagon burst
        if (window.game && window.game.vfxManager) {
            const pos = this.player.mesh.position.clone();
            pos.y += 0.5;

            // Golden/white flash
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const speed = 3 + Math.random() * 2;
                window.game.vfxManager.spawnParticle(
                    pos.x, pos.y, pos.z,
                    Math.cos(angle) * speed,
                    (Math.random() - 0.3) * 2,
                    Math.sin(angle) * speed,
                    '#ffffff',
                    0.15,
                    0.5,
                    'spark'
                );
            }

            // Hexagon burst
            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                window.game.vfxManager.spawnParticle(
                    pos.x, pos.y, pos.z,
                    Math.cos(angle) * 4,
                    0.5,
                    Math.sin(angle) * 4,
                    '#00ffff',
                    0.2,
                    0.4,
                    'spark'
                );
            }
        }

        // Screen effect
        if (window.game && window.game.screenFlash) {
            window.game.screenFlash('#00ffff', 0.3);
        }
    }

    createBlockHitEffect() {
        // Ripple effect on shield
        if (window.game && window.game.vfxManager) {
            const pos = this.player.mesh.position.clone();
            pos.y += 0.5;
            pos.z += 1;

            for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                window.game.vfxManager.spawnParticle(
                    pos.x, pos.y, pos.z,
                    Math.cos(angle) * 2,
                    (Math.random() - 0.5) * 1,
                    Math.sin(angle) * 0.5,
                    '#00ffff',
                    0.1,
                    0.3,
                    'spark'
                );
            }
        }
    }

    createShieldBreakEffect() {
        // Dramatic shatter effect
        if (window.game && window.game.vfxManager) {
            const pos = this.player.mesh.position.clone();
            pos.y += 0.5;

            // Shatter particles
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 2 + Math.random() * 4;
                window.game.vfxManager.spawnParticle(
                    pos.x + (Math.random() - 0.5) * 1.5,
                    pos.y + (Math.random() - 0.5) * 1,
                    pos.z + 0.5 + Math.random() * 0.5,
                    Math.cos(angle) * speed,
                    Math.random() * 3,
                    Math.sin(angle) * speed * 0.5,
                    '#00ffff',
                    0.1 + Math.random() * 0.1,
                    0.5 + Math.random() * 0.3,
                    'spark'
                );
            }
        }

        // Screen shake
        if (window.game && window.game.screenEffects) {
            window.game.screenEffects.shake(0.3, 0.2);
        }
    }

    update(deltaTime) {
        // Recovery from break
        if (this.isBroken) {
            this.breakRecoveryTimer -= deltaTime;
            if (this.breakRecoveryTimer <= 0) {
                this.isBroken = false;
                this.shieldHealth = this.maxShieldHealth;
            }
        }

        // Regenerate shield health when not blocking
        if (!this.isBlocking && !this.isBroken && this.shieldHealth < this.maxShieldHealth) {
            this.shieldHealth += SHIELD_CONFIG.regenRate * deltaTime;
            this.shieldHealth = Math.min(this.shieldHealth, this.maxShieldHealth);
        }

        // Animate shield visuals
        this.shieldOpacity = THREE.MathUtils.lerp(this.shieldOpacity, this.targetOpacity, deltaTime * 10);

        if (this.shieldMesh) {
            // Perfect block flash
            let flashBonus = this.perfectBlockFlash * 0.4;
            this.perfectBlockFlash *= 0.9;

            // Health-based color shift (cyan to red as damaged)
            const healthPercent = this.shieldHealth / this.maxShieldHealth;
            const baseColor = this.equippedShield ?
                new THREE.Color(RARITY[this.equippedShield.rarity].color) :
                new THREE.Color(0x00ffff);
            const damageColor = new THREE.Color(0xff0000);
            const currentColor = baseColor.clone().lerp(damageColor, 1 - healthPercent);

            this.shieldMesh.material.opacity = this.shieldOpacity + flashBonus;
            this.shieldMesh.material.color = currentColor;

            this.shieldWire.material.opacity = (this.shieldOpacity * 0.8) + flashBonus;
            this.shieldWire.material.color = currentColor;

            this.shieldGlow.material.opacity = (this.shieldOpacity * 0.3) + flashBonus * 0.5;
            this.shieldGlow.material.color = currentColor;

            // Animate floating hexagons
            const time = performance.now() * 0.001;
            this.hexagons.forEach((hex, i) => {
                const data = hex.userData;
                data.angle += data.speed * deltaTime;

                hex.position.x = Math.cos(data.angle) * data.radius;
                hex.position.y = data.yOffset + Math.sin(time * 2 + i) * 0.1;
                hex.position.z = Math.sin(data.angle) * data.radius * 0.5 + 0.5;
                hex.rotation.z = time + i;

                hex.material.opacity = this.shieldOpacity * 0.7 + flashBonus;
                hex.material.color = currentColor;
            });

            // Hide when fully transparent
            this.shieldGroup.visible = this.shieldOpacity > 0.01;
        }
    }

    getShieldHealthPercent() {
        return this.shieldHealth / this.maxShieldHealth;
    }

    isInCounterWindow() {
        return this.isCounterWindow;
    }

    canBlock() {
        return !this.isBroken;
    }
}

// â”€â”€â”€ EQUIPMENT SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class EquipmentSystem {
    constructor() {
        // Equipment slots - weapons are now class-specific
        this.slots = {
            sword: null,        // Sword weapon slot
            gun: null,          // Gun weapon slot
            scythe: null,       // Scythe weapon slot
            shield: null,       // Shield
            helmet: null,       // Head armor
            armor: null,        // Body armor
            boots: null,        // Foot armor
            trinket1: null,     // Accessory 1
            trinket2: null      // Accessory 2
        };

        this.activeWeaponSlot = 'sword';

        // Calculated stats from all equipment
        this.bonusStats = {};

        // Callbacks
        this.onEquipmentChange = null;
    }

    equip(item, slot = null) {
        if (!item) return false;

        // Determine slot based on item type/subtype
        if (!slot) {
            switch (item.type) {
                case 'weapon':
                    // Weapons go to their specific class slot
                    if (item.subtype === 'sword') slot = 'sword';
                    else if (item.subtype === 'gun') slot = 'gun';
                    else if (item.subtype === 'scythe') slot = 'scythe';
                    else return false; // Unknown weapon type
                    break;
                case 'shield':
                    slot = 'shield';
                    break;
                case 'helmet':
                    slot = 'helmet';
                    break;
                case 'armor':
                    slot = 'armor';
                    break;
                case 'boots':
                    slot = 'boots';
                    break;
                case 'trinket':
                    if (!this.slots.trinket1) slot = 'trinket1';
                    else if (!this.slots.trinket2) slot = 'trinket2';
                    else slot = 'trinket1';
                    break;
                default:
                    return false;
            }
        }

        // Store previously equipped item to return to inventory
        const previousItem = this.slots[slot];

        // Equip new item
        this.slots[slot] = item;

        // Recalculate stats
        this.recalculateStats();

        // Callback
        if (this.onEquipmentChange) {
            this.onEquipmentChange(slot, item, previousItem);
        }

        return previousItem; // Return old item to add back to inventory
    }

    unequip(slot) {
        const item = this.slots[slot];
        this.slots[slot] = null;
        this.recalculateStats();

        if (this.onEquipmentChange) {
            this.onEquipmentChange(slot, null, item);
        }

        return item;
    }

    getEquipped(slot) {
        return this.slots[slot];
    }

    getActiveWeapon() {
        return this.slots[this.activeWeaponSlot];
    }

    cycleWeapon(direction = 1) {
        const weaponSlots = ['sword', 'gun', 'scythe'];
        let currentIndex = weaponSlots.indexOf(this.activeWeaponSlot);

        // Find next slot with a weapon
        for (let i = 0; i < 3; i++) {
            currentIndex = (currentIndex + direction + 3) % 3;
            if (this.slots[weaponSlots[currentIndex]]) {
                this.activeWeaponSlot = weaponSlots[currentIndex];
                return this.slots[this.activeWeaponSlot];
            }
        }

        return null;
    }

    // Get the active weapon type (sword, gun, or scythe)
    getActiveWeaponType() {
        return this.activeWeaponSlot;
    }

    recalculateStats() {
        this.bonusStats = {
            damage: 0,
            attackSpeed: 0,
            critChance: 0,
            critDamage: 0,
            range: 0,
            health: 0,
            armor: 0,
            moveSpeed: 0,
            dashCooldown: 0,
            shieldHealth: 0,
            damageReduction: 0,
            timeChargeRate: 0,
            comboWindow: 0,
            xpBonus: 0,
            goldBonus: 0
        };

        // Sum up stats from all equipped items
        for (const slot in this.slots) {
            const item = this.slots[slot];
            if (item && item.stats) {
                for (const stat in item.stats) {
                    if (this.bonusStats.hasOwnProperty(stat)) {
                        this.bonusStats[stat] += item.stats[stat];
                    } else {
                        this.bonusStats[stat] = item.stats[stat];
                    }
                }
            }
        }
    }

    getStat(statName) {
        return this.bonusStats[statName] || 0;
    }

    getAllEquipped() {
        return Object.entries(this.slots)
            .filter(([slot, item]) => item !== null)
            .map(([slot, item]) => ({ slot, item }));
    }

    hasWeapon() {
        return this.slots.weapon1 || this.slots.weapon2 || this.slots.weapon3;
    }

    hasShield() {
        return this.slots.shield !== null;
    }
}

// â”€â”€â”€ INVENTORY SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class InventorySystem {
    constructor(maxSlots = 20) {
        this.maxSlots = maxSlots;
        this.items = [];
        this.gold = 0;

        // Callbacks
        this.onInventoryChange = null;
    }

    addItem(item) {
        if (this.items.length >= this.maxSlots) {
            return false; // Inventory full
        }

        this.items.push(item);

        if (this.onInventoryChange) {
            this.onInventoryChange('add', item);
        }

        return true;
    }

    removeItem(itemOrId) {
        const id = typeof itemOrId === 'string' ? itemOrId : itemOrId.id;
        const index = this.items.findIndex(item => item.id === id);

        if (index === -1) return null;

        const item = this.items.splice(index, 1)[0];

        if (this.onInventoryChange) {
            this.onInventoryChange('remove', item);
        }

        return item;
    }

    getItem(id) {
        return this.items.find(item => item.id === id);
    }

    getItemsByType(type) {
        return this.items.filter(item => item.type === type);
    }

    getItemsByRarity(rarity) {
        return this.items.filter(item => item.rarity === rarity);
    }

    sortByRarity() {
        const rarityOrder = ['TEMPORAL', 'LEGENDARY', 'EPIC', 'RARE', 'UNCOMMON', 'COMMON'];
        this.items.sort((a, b) => rarityOrder.indexOf(a.rarity) - rarityOrder.indexOf(b.rarity));
    }

    sortByType() {
        const typeOrder = ['weapon', 'shield', 'helmet', 'armor', 'boots', 'trinket'];
        this.items.sort((a, b) => typeOrder.indexOf(a.type) - typeOrder.indexOf(b.type));
    }

    sortByValue() {
        this.items.sort((a, b) => b.value - a.value);
    }

    isFull() {
        return this.items.length >= this.maxSlots;
    }

    getSlotCount() {
        return { used: this.items.length, max: this.maxSlots };
    }

    addGold(amount) {
        this.gold += amount;
        if (this.onInventoryChange) {
            this.onInventoryChange('gold', amount);
        }
    }

    spendGold(amount) {
        if (this.gold >= amount) {
            this.gold -= amount;
            if (this.onInventoryChange) {
                this.onInventoryChange('gold', -amount);
            }
            return true;
        }
        return false;
    }

    sellItem(itemOrId) {
        const item = this.removeItem(itemOrId);
        if (item) {
            this.addGold(item.value);
            return item.value;
        }
        return 0;
    }

    clear() {
        this.items = [];
        if (this.onInventoryChange) {
            this.onInventoryChange('clear', null);
        }
    }
}

// â”€â”€â”€ SCREEN EFFECTS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ScreenEffects {
    constructor() {
        // Screen shake
        this.shakeIntensity = 0;
        this.shakeDuration = 0;
        this.shakeOffset = new THREE.Vector3();

        // Hitstop (time freeze)
        this.hitstopDuration = 0;
        this.timeScale = 1;

        // Slow motion
        this.slowmoDuration = 0;
        this.slowmoScale = 1;

        // Vignette flash
        this.vignetteIntensity = 0;
        this.vignetteColor = '#ff0000';

        // V2.6 Post-processing state
        this.chromaticActive = false;
        this.chromaticDuration = 0;
        this.lowHealthMode = false;
        this.combatActive = false;

        // Health-based damage vignette (CoD style)
        this.currentHealthPercent = 1.0;
        this.targetHealthPercent = 1.0;

        // Create vignette overlay
        this.createVignetteOverlay();

        // V2.6 Cache post-processing elements
        this.postVignette = document.getElementById('post-vignette');
        this.postChromatic = document.getElementById('post-chromatic');
        this.damageVignette = document.getElementById('damage-vignette');
        this.gameCanvas = document.getElementById('game-canvas');
    }

    createVignetteOverlay() {
        const overlay = document.createElement('div');
        overlay.id = 'screen-effects-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 60%, rgba(255,0,0,0) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        `;
        document.body.appendChild(overlay);
        this.vignetteOverlay = overlay;
    }

    // V2.6 Chromatic aberration burst (on damage/impact)
    chromaticBurst(duration = 0.15) {
        if (!CONFIG.chromaticAberration.enabled) return;
        this.chromaticActive = true;
        this.chromaticDuration = duration;
        if (this.postChromatic) {
            this.postChromatic.classList.add('active');
        }
    }

    // V2.6 Set low health visual mode
    setLowHealthMode(isLow) {
        if (this.lowHealthMode === isLow) return;
        this.lowHealthMode = isLow;
    }

    // CoD-style health-based damage vignette
    updateHealthVignette(healthPercent) {
        this.targetHealthPercent = healthPercent;
    }

    // Update damage vignette visuals (call in update loop)
    updateDamageVignette(deltaTime) {
        // Smoothly interpolate current health toward target
        const lerpSpeed = this.currentHealthPercent > this.targetHealthPercent ? 8 : 2; // Fast when damaged, slow recovery
        this.currentHealthPercent += (this.targetHealthPercent - this.currentHealthPercent) * lerpSpeed * deltaTime;

        if (!this.damageVignette) return;

        // Calculate vignette intensity based on missing health
        // Starts showing at 70% health, gets more intense as health drops
        const missingHealth = 1 - this.currentHealthPercent;
        let intensity = 0;

        if (this.currentHealthPercent < 0.7) {
            // Map 0.7->0 health to 0->1 intensity
            intensity = (0.7 - this.currentHealthPercent) / 0.7;
            intensity = Math.pow(intensity, 0.7); // Curve for more dramatic low health
        }

        // Apply vignette
        if (intensity > 0.01) {
            const redIntensity = Math.min(intensity * 0.9, 0.85);
            const spread = 30 + (1 - intensity) * 30; // Vignette spreads inward as health drops

            this.damageVignette.style.background = `radial-gradient(ellipse at center,
                transparent 0%,
                transparent ${spread}%,
                rgba(120, 0, 0, ${redIntensity * 0.4}) ${spread + 20}%,
                rgba(80, 0, 0, ${redIntensity * 0.7}) ${spread + 35}%,
                rgba(50, 0, 0, ${redIntensity * 0.9}) 100%)`;
            this.damageVignette.style.opacity = '1';
            this.damageVignette.style.setProperty('--damage-opacity', intensity.toString());

            // Add pulsing effect when critical (below 25%)
            if (this.currentHealthPercent < 0.25) {
                this.damageVignette.classList.add('critical');
            } else {
                this.damageVignette.classList.remove('critical');
            }
        } else {
            this.damageVignette.style.opacity = '0';
            this.damageVignette.classList.remove('critical');
        }
    }

    // V2.6 Set combat active mode (enhanced visuals during combat)
    setCombatMode(active) {
        if (this.combatActive === active) return;
        this.combatActive = active;
        if (this.gameCanvas) {
            if (active) {
                this.gameCanvas.classList.add('combat-active');
            } else {
                this.gameCanvas.classList.remove('combat-active');
            }
        }
    }

    // Trigger screen shake
    shake(intensity, duration) {
        this.shakeIntensity = Math.max(this.shakeIntensity, intensity);
        this.shakeDuration = Math.max(this.shakeDuration, duration);
    }

    // V3: Hitstop - subtle slowdown instead of jarring freeze
    // Uses 0.1 timeScale (10%) instead of 0, and caps duration at 50ms
    hitstop(duration) {
        // Cap duration to 50ms max for subtle effect
        this.hitstopDuration = Math.min(duration, 0.05);
        // Slow to 10% instead of complete freeze (0)
        this.timeScale = 0.1;
    }

    // Trigger slow motion
    slowmo(scale, duration) {
        this.slowmoScale = scale;
        this.slowmoDuration = duration;
    }

    // Flash vignette (damage indicator)
    flashVignette(color, intensity) {
        this.vignetteColor = color;
        this.vignetteIntensity = intensity;
        this.updateVignetteOverlay();
    }

    updateVignetteOverlay() {
        const overlay = this.vignetteOverlay;
        if (this.vignetteIntensity > 0) {
            // Use semi-transparent color at edges to avoid blocking view
            overlay.style.background = `radial-gradient(ellipse at center, transparent 0%, transparent 60%, ${this.vignetteColor}66 85%, ${this.vignetteColor}99 100%)`;
            overlay.style.opacity = this.vignetteIntensity;
        } else {
            overlay.style.opacity = 0;
        }
    }

    update(deltaTime) {
        // Update screen shake
        if (this.shakeDuration > 0) {
            this.shakeDuration -= deltaTime;
            const intensity = this.shakeIntensity * (this.shakeDuration > 0 ? 1 : 0);
            this.shakeOffset.set(
                (Math.random() - 0.5) * 2 * intensity,
                (Math.random() - 0.5) * 2 * intensity,
                (Math.random() - 0.5) * 2 * intensity
            );
            if (this.shakeDuration <= 0) {
                this.shakeIntensity = 0;
                this.shakeOffset.set(0, 0, 0);
            }
        }

        // Update hitstop
        if (this.hitstopDuration > 0) {
            this.hitstopDuration -= deltaTime;
            if (this.hitstopDuration <= 0) {
                this.timeScale = 1;
            }
        }

        // Update slow motion
        if (this.slowmoDuration > 0) {
            this.slowmoDuration -= deltaTime;
            this.timeScale = this.slowmoScale;
            if (this.slowmoDuration <= 0) {
                this.slowmoScale = 1;
                this.timeScale = 1;
            }
        }

        // Fade vignette
        if (this.vignetteIntensity > 0) {
            this.vignetteIntensity -= deltaTime * 4;
            if (this.vignetteIntensity < 0) this.vignetteIntensity = 0;
            this.updateVignetteOverlay();
        }

        // V2.6 Fade chromatic aberration
        if (this.chromaticActive && this.chromaticDuration > 0) {
            this.chromaticDuration -= deltaTime;
            if (this.chromaticDuration <= 0) {
                this.chromaticActive = false;
                if (this.postChromatic) {
                    this.postChromatic.classList.remove('active');
                }
            }
        }
    }

    getTimeScale() {
        if (this.hitstopDuration > 0) return 0;
        return this.slowmoScale;
    }

    applyToCamera(camera) {
        // Apply shake offset to camera
        camera.position.add(this.shakeOffset);
    }
}

// â”€â”€â”€ V4: VISUAL EFFECTS MANAGER (INSANE GRAPHICS) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class VFXManager {
    constructor(scene) {
        this.scene = scene;

        // Particle pools
        this.sparkPool = [];
        this.explosionParticles = [];
        this.trailParticles = [];
        this.ambientEffects = [];

        // Combat flash lights
        this.combatLights = [];
        this.maxCombatLights = 10;

        // Screen flash overlay
        this.flashOverlay = null;
        this.createFlashOverlay();

        // Kill streak tracking
        this.killStreak = 0;
        this.killStreakTimer = 0;
        this.killStreakDecay = 2.0;

        // Reality tear effects
        this.realityTears = [];

        // Arena damage tracking
        this.arenaStress = 0;
        this.cracks = [];

        // Temporal storm
        this.stormActive = false;
        this.stormIntensity = 0;
        this.stormLightning = [];

        // Initialize pools
        this.initPools();
    }

    createFlashOverlay() {
        this.flashOverlay = document.createElement('div');
        this.flashOverlay.id = 'vfx-flash';
        this.flashOverlay.style.cssText = `
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 90;
            opacity: 0;
            transition: opacity 0.05s;
            mix-blend-mode: screen;
        `;
        document.body.appendChild(this.flashOverlay);
    }

    initPools() {
        // Pre-create spark geometries
        this.sparkGeometry = new THREE.SphereGeometry(0.08, 4, 4);
        this.sparkMaterials = {
            gold: new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true }),
            cyan: new THREE.MeshBasicMaterial({ color: 0x44ffff, transparent: true }),
            red: new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true }),
            purple: new THREE.MeshBasicMaterial({ color: 0xff44ff, transparent: true }),
            white: new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true })
        };

        // Trail geometry
        this.trailGeometry = new THREE.SphereGeometry(0.05, 4, 4);
    }

    // â•â•â• COMBAT SPARK EXPLOSION â•â•â•
    spawnHitSparks(position, count = 20, color = 'gold', options = {}) {
        // V6: Scale particle count based on graphics quality
        const qualityMult = getGraphicsSetting('particleMultiplier') || 1.0;
        const maxLights = getGraphicsSetting('maxDynamicLights') || 8;
        const actualCount = Math.max(1, Math.floor(count * qualityMult));

        const {
            speed = 15,
            spread = 1.0,
            size = 1.0,
            gravity = 20,
            lifetime = 0.5,
            glow = true
        } = options;

        const material = this.sparkMaterials[color] || this.sparkMaterials.gold;

        for (let i = 0; i < actualCount; i++) {
            const spark = new THREE.Mesh(this.sparkGeometry, material.clone());
            spark.position.copy(position);
            spark.scale.setScalar(size * (0.5 + Math.random() * 0.5));

            // Random velocity
            const angle = Math.random() * Math.PI * 2;
            const upAngle = Math.random() * Math.PI * 0.5;
            const vel = speed * (0.5 + Math.random() * 0.5) * spread;

            spark.userData = {
                velocity: new THREE.Vector3(
                    Math.cos(angle) * Math.sin(upAngle) * vel,
                    Math.cos(upAngle) * vel + 5,
                    Math.sin(angle) * Math.sin(upAngle) * vel
                ),
                gravity: gravity,
                lifetime: lifetime,
                age: 0,
                startOpacity: 1.0
            };

            // V6: Add glow light only if under limit and quality allows
            if (glow && i < 3 && maxLights > 0 && this.combatLights.length < maxLights) {
                const light = new THREE.PointLight(
                    material.color.getHex(),
                    0.5,
                    3
                );
                spark.add(light);
                spark.userData.light = light;
            }

            this.scene.add(spark);
            this.explosionParticles.push(spark);
        }
    }

    // â•â•â• DEATH EXPLOSION - SPECTACULAR â•â•â•
    spawnDeathExplosion(position, enemyType = 'normal') {
        const isBoss = enemyType === 'boss';
        const count = isBoss ? 150 : 80;
        const colors = isBoss ? ['gold', 'purple', 'white'] : ['gold', 'cyan'];

        // Main spark burst
        colors.forEach((color, idx) => {
            this.spawnHitSparks(position, Math.floor(count / colors.length), color, {
                speed: isBoss ? 25 : 18,
                spread: 1.2,
                gravity: 15,
                lifetime: isBoss ? 1.0 : 0.7,
                glow: idx === 0
            });
        });

        // Shockwave ring
        this.spawnShockwave(position, isBoss ? 8 : 4, isBoss ? 0xd4af37 : 0x44ffff);

        // Screen flash
        this.screenFlash(isBoss ? '#ffdd44' : '#44ffff', isBoss ? 0.4 : 0.2);

        // Combat light flash
        this.spawnCombatLight(position, isBoss ? 0xffdd44 : 0x44ffff, isBoss ? 3 : 1.5, isBoss ? 8 : 4);

        // Add to arena stress
        this.arenaStress += isBoss ? 0.15 : 0.02;
    }

    // â•â•â• SHOCKWAVE RING EFFECT â•â•â•
    spawnShockwave(position, maxRadius = 5, color = 0x44ffff) {
        const geometry = new THREE.RingGeometry(0.5, 1.0, 32);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const ring = new THREE.Mesh(geometry, material);
        ring.position.copy(position);
        ring.position.y = 0.1;
        ring.rotation.x = -Math.PI / 2;

        ring.userData = {
            maxRadius: maxRadius,
            currentRadius: 0.5,
            speed: maxRadius * 3,
            age: 0,
            lifetime: 0.4
        };

        this.scene.add(ring);
        this.ambientEffects.push({ type: 'shockwave', mesh: ring });
    }

    // â•â•â• SCREEN FLASH â•â•â•
    screenFlash(color, intensity = 0.3) {
        this.flashOverlay.style.backgroundColor = color;
        this.flashOverlay.style.opacity = intensity;
        setTimeout(() => {
            this.flashOverlay.style.opacity = 0;
        }, 50);
    }

    // â•â•â• COMBAT LIGHT FLASH â•â•â•
    spawnCombatLight(position, color, intensity, range) {
        if (this.combatLights.length >= this.maxCombatLights) {
            const oldest = this.combatLights.shift();
            this.scene.remove(oldest);
        }

        const light = new THREE.PointLight(color, intensity, range);
        light.position.copy(position);
        light.position.y = 2;
        light.userData = { age: 0, lifetime: 0.3, startIntensity: intensity };

        this.scene.add(light);
        this.combatLights.push(light);
    }

    // â•â•â• WEAPON TRAIL â•â•â•
    spawnTrailSegment(position, color = 0x44ffff, size = 0.1) {
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.8
        });

        const segment = new THREE.Mesh(this.trailGeometry, material);
        segment.position.copy(position);
        segment.scale.setScalar(size);

        segment.userData = {
            age: 0,
            lifetime: 0.3,
            startScale: size
        };

        this.scene.add(segment);
        this.trailParticles.push(segment);
    }

    // â•â•â• DASH AFTERIMAGE â•â•â•
    spawnDashAfterimage(position, rotation, color = 0x4a90b8) {
        const geometry = new THREE.CylinderGeometry(0.3, 0.3, 1.8, 8);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.4,
            depthWrite: false
        });

        const ghost = new THREE.Mesh(geometry, material);
        ghost.position.copy(position);
        ghost.rotation.y = rotation;

        ghost.userData = {
            age: 0,
            lifetime: 0.4
        };

        this.scene.add(ghost);
        this.ambientEffects.push({ type: 'afterimage', mesh: ghost });
    }

    // â•â•â• REALITY TEAR â•â•â•
    spawnRealityTear(position) {
        const group = new THREE.Group();
        group.position.copy(position);

        // Tear geometry - jagged line
        const points = [];
        for (let i = 0; i < 10; i++) {
            points.push(new THREE.Vector3(
                (Math.random() - 0.5) * 0.5,
                i * 0.8 - 4,
                (Math.random() - 0.5) * 0.3
            ));
        }

        const tearGeo = new THREE.BufferGeometry().setFromPoints(points);
        const tearMat = new THREE.LineBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.9,
            linewidth: 3
        });
        const tear = new THREE.Line(tearGeo, tearMat);
        group.add(tear);

        // Glow around tear
        const glowGeo = new THREE.PlaneGeometry(2, 8);
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0x8800ff,
            transparent: true,
            opacity: 0.2,
            side: THREE.DoubleSide,
            depthWrite: false
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        group.add(glow);

        // Particles leaking from tear
        group.userData = {
            age: 0,
            lifetime: 5 + Math.random() * 5,
            particleTimer: 0
        };

        this.scene.add(group);
        this.realityTears.push(group);
    }

    // â•â•â• ARENA CRACK â•â•â•
    spawnArenaCrack(position, size = 1) {
        const group = new THREE.Group();
        group.position.set(position.x, 0.05, position.z);

        // Main crack line
        const crackPoints = [];
        let x = 0, z = 0;
        for (let i = 0; i < 8; i++) {
            crackPoints.push(new THREE.Vector3(x, 0, z));
            x += (Math.random() - 0.5) * size;
            z += (Math.random() * 0.5 + 0.3) * size;
        }

        const crackGeo = new THREE.BufferGeometry().setFromPoints(crackPoints);
        const crackMat = new THREE.LineBasicMaterial({
            color: 0x000000,
            linewidth: 2
        });
        const crack = new THREE.Line(crackGeo, crackMat);
        group.add(crack);

        // Glow beneath crack (void showing through)
        const glowGeo = new THREE.PlaneGeometry(size * 0.5, size * 2);
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0x4400ff,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const glow = new THREE.Mesh(glowGeo, glowMat);
        glow.rotation.x = -Math.PI / 2;
        glow.rotation.z = Math.random() * Math.PI;
        glow.position.y = -0.02;
        group.add(glow);

        this.scene.add(group);
        this.cracks.push(group);
    }

    // â•â•â• TEMPORAL STORM â•â•â•
    startTemporalStorm() {
        this.stormActive = true;
        this.stormIntensity = 0;
    }

    spawnLightningBolt(startPos, endPos) {
        const points = [startPos.clone()];
        const segments = 8;
        const direction = endPos.clone().sub(startPos);

        for (let i = 1; i < segments; i++) {
            const t = i / segments;
            const point = startPos.clone().lerp(endPos, t);
            point.x += (Math.random() - 0.5) * 3;
            point.z += (Math.random() - 0.5) * 3;
            points.push(point);
        }
        points.push(endPos.clone());

        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const material = new THREE.LineBasicMaterial({
            color: 0x88ffff,
            transparent: true,
            opacity: 1.0
        });

        const bolt = new THREE.Line(geometry, material);
        bolt.userData = { age: 0, lifetime: 0.15 };

        // Bright flash at impact
        const flash = new THREE.PointLight(0x88ffff, 5, 15);
        flash.position.copy(endPos);
        bolt.add(flash);

        this.scene.add(bolt);
        this.stormLightning.push(bolt);
    }

    // â•â•â• KILL STREAK EFFECTS â•â•â•
    recordKill() {
        this.killStreak++;
        this.killStreakTimer = this.killStreakDecay;

        // Show kill streak display
        this.showKillStreak();

        // Milestone effects with announcements
        if (this.killStreak === 5) {
            this.screenFlash('#44ff44', 0.2);
            this.showKillStreakAnnouncement('KILLING SPREE', '#44ff44');
        } else if (this.killStreak === 10) {
            this.screenFlash('#ffff44', 0.3);
            this.startMinorStorm();
            this.showKillStreakAnnouncement('RAMPAGE', '#ffff44');
        } else if (this.killStreak === 15) {
            this.screenFlash('#ff8844', 0.35);
            this.showKillStreakAnnouncement('DOMINATING', '#ff8844');
        } else if (this.killStreak === 25) {
            this.screenFlash('#ff44ff', 0.4);
            this.showKillStreakAnnouncement('UNSTOPPABLE', '#ff44ff');
            this.startMinorStorm();
        } else if (this.killStreak === 50) {
            this.screenFlash('#ffffff', 0.5);
            this.showKillStreakAnnouncement('GODLIKE', '#ffffff');
            // Epic storm for godlike
            for (let i = 0; i < 5; i++) {
                setTimeout(() => this.startMinorStorm(), i * 200);
            }
        }
    }

    showKillStreak() {
        const display = document.getElementById('kill-streak-display');
        if (!display) return;

        // Only show for streaks of 3+
        if (this.killStreak < 3) {
            display.style.opacity = '0';
            return;
        }

        display.textContent = `${this.killStreak} KILLS`;
        display.style.color = this.getStreakColor();
        display.style.opacity = '1';
        display.style.transform = 'translate(-50%, -50%) scale(1.2)';

        setTimeout(() => {
            display.style.transform = 'translate(-50%, -50%) scale(1)';
        }, 100);
    }

    showKillStreakAnnouncement(text, color) {
        const display = document.getElementById('kill-streak-display');
        if (!display) return;

        display.innerHTML = `<div style="font-size: 3em; text-shadow: 0 0 30px ${color}, 0 0 60px ${color};">${text}</div><div style="font-size: 1.5em; margin-top: 10px;">${this.killStreak} KILLS</div>`;
        display.style.color = color;
        display.style.opacity = '1';
        display.style.animation = 'killStreakPop 0.5s ease-out';

        setTimeout(() => {
            display.style.animation = '';
            this.showKillStreak();
        }, 1500);
    }

    getStreakColor() {
        if (this.killStreak >= 50) return '#ffffff';
        if (this.killStreak >= 25) return '#ff44ff';
        if (this.killStreak >= 15) return '#ff8844';
        if (this.killStreak >= 10) return '#ffff44';
        if (this.killStreak >= 5) return '#44ff44';
        return '#44ffff';
    }

    // â•â•â• ENEMY SPAWN EFFECTS â•â•â•
    spawnEnemySpawnEffect(position, enemyType = 'normal') {
        const isBoss = enemyType === 'boss';
        const color = isBoss ? 0xff4444 : 0x8844ff;
        const count = isBoss ? 60 : 30;

        // Upward spiral particles
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 4;
            const radius = 0.5 + (i / count) * 1.5;
            const height = (i / count) * 2;

            const spark = new THREE.Mesh(this.sparkGeometry, this.sparkMaterials.purple.clone());
            spark.position.set(
                position.x + Math.cos(angle) * radius,
                position.y + height,
                position.z + Math.sin(angle) * radius
            );

            spark.userData = {
                velocity: new THREE.Vector3(
                    Math.cos(angle) * 2,
                    5 + Math.random() * 3,
                    Math.sin(angle) * 2
                ),
                gravity: 8,
                lifetime: 0.8,
                age: i * 0.01, // Stagger
                startOpacity: 1.0
            };

            this.scene.add(spark);
            this.explosionParticles.push(spark);
        }

        // Ground rune circle
        this.spawnSpawnRune(position, isBoss ? 3 : 1.5, color);

        // Light flash
        this.spawnCombatLight(position, color, isBoss ? 2 : 1, isBoss ? 6 : 3);
    }

    spawnSpawnRune(position, size, color) {
        // Create glowing rune circle on ground
        const geometry = new THREE.RingGeometry(size * 0.3, size, 6);
        const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide,
            depthWrite: false
        });

        const rune = new THREE.Mesh(geometry, material);
        rune.position.set(position.x, 0.05, position.z);
        rune.rotation.x = -Math.PI / 2;

        rune.userData = {
            age: 0,
            lifetime: 1.5,
            rotationSpeed: 3
        };

        this.scene.add(rune);
        this.ambientEffects.push({ type: 'spawnRune', mesh: rune });
    }

    startMinorStorm() {
        // Brief lightning burst
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                const startPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 60,
                    30,
                    (Math.random() - 0.5) * 60
                );
                const endPos = new THREE.Vector3(
                    (Math.random() - 0.5) * 40,
                    0,
                    (Math.random() - 0.5) * 40
                );
                this.spawnLightningBolt(startPos, endPos);
            }, i * 100);
        }
    }

    // â•â•â• UPDATE ALL EFFECTS â•â•â•
    update(deltaTime, elapsedTime) {
        // Update explosion particles
        for (let i = this.explosionParticles.length - 1; i >= 0; i--) {
            const p = this.explosionParticles[i];
            p.userData.age += deltaTime;

            if (p.userData.age >= p.userData.lifetime) {
                if (p.userData.light) p.remove(p.userData.light);
                this.scene.remove(p);
                this.explosionParticles.splice(i, 1);
                continue;
            }

            // Physics
            p.userData.velocity.y -= p.userData.gravity * deltaTime;
            p.position.add(p.userData.velocity.clone().multiplyScalar(deltaTime));

            // Fade
            const life = 1 - (p.userData.age / p.userData.lifetime);
            p.material.opacity = life * p.userData.startOpacity;
            p.scale.setScalar(life * 0.5 + 0.5);

            if (p.userData.light) {
                p.userData.light.intensity = life * 0.5;
            }
        }

        // Update trail particles
        for (let i = this.trailParticles.length - 1; i >= 0; i--) {
            const t = this.trailParticles[i];
            t.userData.age += deltaTime;

            if (t.userData.age >= t.userData.lifetime) {
                this.scene.remove(t);
                this.trailParticles.splice(i, 1);
                continue;
            }

            const life = 1 - (t.userData.age / t.userData.lifetime);
            t.material.opacity = life * 0.8;
            t.scale.setScalar(t.userData.startScale * life);
        }

        // Update combat lights
        for (let i = this.combatLights.length - 1; i >= 0; i--) {
            const light = this.combatLights[i];
            light.userData.age += deltaTime;

            if (light.userData.age >= light.userData.lifetime) {
                this.scene.remove(light);
                this.combatLights.splice(i, 1);
                continue;
            }

            const life = 1 - (light.userData.age / light.userData.lifetime);
            light.intensity = light.userData.startIntensity * life;
        }

        // Update ambient effects (shockwaves, afterimages)
        for (let i = this.ambientEffects.length - 1; i >= 0; i--) {
            const effect = this.ambientEffects[i];
            effect.mesh.userData.age += deltaTime;

            if (effect.mesh.userData.age >= effect.mesh.userData.lifetime) {
                this.scene.remove(effect.mesh);
                effect.mesh.geometry.dispose();
                effect.mesh.material.dispose();
                this.ambientEffects.splice(i, 1);
                continue;
            }

            const life = 1 - (effect.mesh.userData.age / effect.mesh.userData.lifetime);

            if (effect.type === 'shockwave') {
                // Expand ring
                const ud = effect.mesh.userData;
                ud.currentRadius += ud.speed * deltaTime;
                const scale = ud.currentRadius / 0.75;
                effect.mesh.scale.setScalar(scale);
                effect.mesh.material.opacity = life * 0.8;
            } else if (effect.type === 'afterimage') {
                effect.mesh.material.opacity = life * 0.4;
            } else if (effect.type === 'spawnRune') {
                // Rotating rune circle
                effect.mesh.rotation.z += effect.mesh.userData.rotationSpeed * deltaTime;
                effect.mesh.material.opacity = life * 0.8;
                // Pulse effect
                const pulse = 1 + Math.sin(elapsedTime * 8) * 0.1;
                effect.mesh.scale.setScalar(pulse);
            }
        }

        // Update reality tears
        for (let i = this.realityTears.length - 1; i >= 0; i--) {
            const tear = this.realityTears[i];
            tear.userData.age += deltaTime;

            if (tear.userData.age >= tear.userData.lifetime) {
                this.scene.remove(tear);
                this.realityTears.splice(i, 1);
                continue;
            }

            // Flicker effect
            tear.children.forEach(child => {
                if (child.material) {
                    child.material.opacity = 0.5 + Math.sin(elapsedTime * 10) * 0.3;
                }
            });

            // Spawn leak particles occasionally
            tear.userData.particleTimer += deltaTime;
            if (tear.userData.particleTimer > 0.2) {
                tear.userData.particleTimer = 0;
                this.spawnHitSparks(tear.position, 2, 'purple', {
                    speed: 3,
                    gravity: -2,
                    lifetime: 1.0,
                    glow: false
                });
            }
        }

        // Update lightning bolts
        for (let i = this.stormLightning.length - 1; i >= 0; i--) {
            const bolt = this.stormLightning[i];
            bolt.userData.age += deltaTime;

            if (bolt.userData.age >= bolt.userData.lifetime) {
                this.scene.remove(bolt);
                this.stormLightning.splice(i, 1);
            }
        }

        // Update kill streak timer
        if (this.killStreakTimer > 0) {
            this.killStreakTimer -= deltaTime;
            if (this.killStreakTimer <= 0) {
                this.killStreak = 0;
            }
        }

        // Arena stress now just decays (removed crack spawning)
        if (this.arenaStress > 0) {
            this.arenaStress *= 0.99;
        }
    }

    // Cleanup
    dispose() {
        this.explosionParticles.forEach(p => this.scene.remove(p));
        this.trailParticles.forEach(t => this.scene.remove(t));
        this.combatLights.forEach(l => this.scene.remove(l));
        this.ambientEffects.forEach(e => this.scene.remove(e.mesh));
        this.realityTears.forEach(t => this.scene.remove(t));
        this.cracks.forEach(c => this.scene.remove(c));
        this.stormLightning.forEach(b => this.scene.remove(b));

        if (this.flashOverlay) {
            this.flashOverlay.remove();
        }
    }
}

// â”€â”€â”€ INPUT MANAGER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class InputManager {
    constructor() {
        this.keys = {};
        this.mouseMovement = { x: 0, y: 0 };
        this.mouseButtons = { left: false, right: false };
        this.isPointerLocked = false;

        this.setupListeners();
    }

    setupListeners() {
        // Keyboard
        window.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });

        // Mouse movement
        window.addEventListener('mousemove', (e) => {
            if (this.isPointerLocked) {
                this.mouseMovement.x += e.movementX;
                this.mouseMovement.y += e.movementY;
            }
        });

        // Mouse buttons
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) this.mouseButtons.left = true;
            if (e.button === 2) this.mouseButtons.right = true;
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) this.mouseButtons.left = false;
            if (e.button === 2) this.mouseButtons.right = false;
        });

        // Pointer lock change
        document.addEventListener('pointerlockchange', () => {
            this.isPointerLocked = document.pointerLockElement !== null;
        });

        // Prevent context menu
        window.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    isKeyDown(code) {
        return this.keys[code] === true;
    }

    consumeMouseMovement() {
        const movement = { x: this.mouseMovement.x, y: this.mouseMovement.y };
        this.mouseMovement.x = 0;
        this.mouseMovement.y = 0;
        return movement;
    }

    reset() {
        this.keys = {};
        this.mouseButtons = { left: false, right: false };
    }
}

// â”€â”€â”€ AUDIO MANAGER â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class AudioManager {
    constructor() {
        this.initialized = false;
        this.musicVolume = CONFIG.musicVolume;
        this.sfxVolume = CONFIG.sfxVolume;

        // Tone.js components
        this.musicGain = null;
        this.sfxGain = null;

        // Music system
        this.bassSynth = null;
        this.padSynth = null;
        this.leadSynth = null;
        this.arpSynth = null;
        this.drums = null;

        // Effects
        this.reverb = null;
        this.delay = null;
        this.distortion = null;
        this.filter = null;

        // Music state
        this.combatIntensity = 0;
        this.currentWave = 1;
        this.isPlaying = false;
        this.isMenuPlaying = false;
        this.menuInitialized = false;
        this.bassPattern = null;
        this.drumPattern = null;
        this.arpPattern = null;
        this.menuPatterns = [];

        // Musical scales (A minor / dark synthwave)
        this.scale = ['A2', 'C3', 'D3', 'E3', 'G3', 'A3', 'C4', 'D4', 'E4', 'G4', 'A4'];
        this.bassNotes = ['A1', 'E1', 'G1', 'D1', 'A1', 'C2', 'E1', 'G1'];
        this.chordProgressions = [
            ['A2', 'C3', 'E3'],  // Am
            ['G2', 'B2', 'D3'],  // G
            ['F2', 'A2', 'C3'],  // F
            ['E2', 'G#2', 'B2'], // E
        ];
        this.currentChord = 0;
    }

    async init() {
        // Allow re-init for music synths, but not sfxGain
        const needsMusicInit = !this.musicGain;

        if (this.initialized && !needsMusicInit) {
            return;
        }

        try {
            // Only start Tone after user interaction (browser policy)
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }

            // === EFFECTS CHAIN ===
            this.reverb = new Tone.Reverb({
                decay: 3,
                wet: 0.3
            }).toDestination();

            this.delay = new Tone.FeedbackDelay({
                delayTime: '8n',
                feedback: 0.3,
                wet: 0.2
            }).connect(this.reverb);

            this.filter = new Tone.Filter({
                frequency: 2000,
                type: 'lowpass',
                rolloff: -24
            }).connect(this.delay);

            // === GAIN NODES ===
            this.musicGain = new Tone.Gain(0.5 * this.musicVolume).connect(this.filter);
            // Only create sfxGain if not already created by menu music
            if (!this.sfxGain) {
                this.sfxGain = new Tone.Gain(this.sfxVolume).toDestination();
            }

            // === BASS SYNTH (Thick, dark bass) ===
            this.bassSynth = new Tone.MonoSynth({
                oscillator: { type: 'sawtooth' },
                envelope: {
                    attack: 0.01,
                    decay: 0.3,
                    sustain: 0.4,
                    release: 0.8
                },
                filterEnvelope: {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.3,
                    release: 0.5,
                    baseFrequency: 100,
                    octaves: 2.5
                }
            }).connect(this.musicGain);

            // === PAD SYNTH (Atmospheric chords) ===
            this.padSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'triangle' },
                envelope: {
                    attack: 0.5,
                    decay: 0.5,
                    sustain: 0.8,
                    release: 2
                }
            }).connect(this.musicGain);
            this.padSynth.volume.value = -12;

            // === LEAD SYNTH (Melodies and stabs) ===
            this.leadSynth = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: {
                    attack: 0.01,
                    decay: 0.2,
                    sustain: 0.3,
                    release: 0.5
                }
            }).connect(this.musicGain);
            this.leadSynth.volume.value = -8;

            // === ARP SYNTH (Fast arpeggios) ===
            this.arpSynth = new Tone.Synth({
                oscillator: { type: 'sawtooth' },
                envelope: {
                    attack: 0.005,
                    decay: 0.1,
                    sustain: 0.1,
                    release: 0.1
                }
            }).connect(this.musicGain);
            this.arpSynth.volume.value = -15;

            // === DRUMS ===
            this.kick = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 6,
                oscillator: { type: 'sine' },
                envelope: {
                    attack: 0.001,
                    decay: 0.4,
                    sustain: 0,
                    release: 0.4
                }
            }).connect(this.musicGain);
            this.kick.volume.value = -6;

            this.snare = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: {
                    attack: 0.001,
                    decay: 0.2,
                    sustain: 0,
                    release: 0.2
                }
            }).connect(this.musicGain);
            this.snare.volume.value = -10;

            this.hihat = new Tone.MetalSynth({
                frequency: 200,
                envelope: {
                    attack: 0.001,
                    decay: 0.05,
                    release: 0.01
                },
                harmonicity: 5.1,
                modulationIndex: 32,
                resonance: 4000,
                octaves: 1.5
            }).connect(this.musicGain);
            this.hihat.volume.value = -20;

            // === SFX SYNTHS ===
            this.hitSynth = new Tone.Synth({
                oscillator: { type: 'square' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.1 }
            }).connect(this.sfxGain);

            this.deathSynth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sawtooth' },
                envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.5 }
            }).connect(this.sfxGain);

            this.swooshNoise = new Tone.Noise('pink').connect(
                new Tone.Filter({ frequency: 1000, type: 'bandpass' }).connect(this.sfxGain)
            );

            this.initialized = true;
            console.log('Full audio init complete, sfxGain:', !!this.sfxGain);
            this.startMusic();

        } catch (e) {
            console.error('Tone.js initialization failed:', e);
        }
    }

    startMusic() {
        if (!this.initialized || this.isPlaying) return;

        Tone.Transport.bpm.value = 128;
        this.isPlaying = true;

        // === BASS PATTERN ===
        let bassIndex = 0;
        this.bassPattern = new Tone.Loop((time) => {
            const note = this.bassNotes[bassIndex % this.bassNotes.length];
            this.bassSynth.triggerAttackRelease(note, '8n', time);
            bassIndex++;
        }, '4n').start(0);

        // === DRUM PATTERN ===
        this.drumPattern = new Tone.Loop((time) => {
            // Kick on 1 and 3
            this.kick.triggerAttackRelease('C1', '8n', time);
            this.kick.triggerAttackRelease('C1', '8n', time + Tone.Time('2n').toSeconds());

            // Snare on 2 and 4
            if (this.combatIntensity > 0.3) {
                this.snare.triggerAttackRelease('8n', time + Tone.Time('4n').toSeconds());
                this.snare.triggerAttackRelease('8n', time + Tone.Time('4n').toSeconds() * 3);
            }

            // Hihats - faster when more intense
            const hihatInterval = this.combatIntensity > 0.6 ? '16n' : '8n';
            for (let i = 0; i < (this.combatIntensity > 0.6 ? 8 : 4); i++) {
                this.hihat.triggerAttackRelease('32n', time + Tone.Time(hihatInterval).toSeconds() * i, 0.3);
            }
        }, '1m').start(0);

        // === CHORD CHANGES ===
        this.chordPattern = new Tone.Loop((time) => {
            const chord = this.chordProgressions[this.currentChord % this.chordProgressions.length];
            this.padSynth.triggerAttackRelease(chord, '2n', time, 0.3);
            this.currentChord++;
        }, '2m').start(0);

        // === ARPEGGIO PATTERN (intensity-based) ===
        let arpIndex = 0;
        this.arpPattern = new Tone.Loop((time) => {
            if (this.combatIntensity > 0.5) {
                const note = this.scale[arpIndex % this.scale.length];
                this.arpSynth.triggerAttackRelease(note, '16n', time);
                arpIndex++;
            }
        }, '16n').start(0);

        Tone.Transport.start();
    }

    stopMusic() {
        if (!this.isPlaying) return;
        this.isPlaying = false;
        Tone.Transport.stop();
        if (this.bassPattern) this.bassPattern.stop();
        if (this.drumPattern) this.drumPattern.stop();
        if (this.arpPattern) this.arpPattern.stop();
        if (this.chordPattern) this.chordPattern.stop();
    }

    // === MENU/HOMEPAGE MUSIC - Epic Cinematic Dark Ambient ===
    async initMenuMusic() {
        if (this.menuInitialized) return;

        try {
            if (Tone.context.state !== 'running') {
                await Tone.start();
            }

            // === EFFECTS CHAIN - Lush and spacious ===
            this.menuReverb = new Tone.Reverb({
                decay: 8,
                wet: 0.4
            }).toDestination();

            this.menuDelay = new Tone.PingPongDelay({
                delayTime: '8n.',
                feedback: 0.35,
                wet: 0.25
            }).connect(this.menuReverb);

            this.menuChorus = new Tone.Chorus({
                frequency: 0.5,
                delayTime: 3.5,
                depth: 0.7,
                wet: 0.3
            }).connect(this.menuDelay);

            this.menuFilter = new Tone.Filter({
                frequency: 2500,
                type: 'lowpass',
                rolloff: -12
            }).connect(this.menuChorus);

            this.menuGain = new Tone.Gain(0.5).connect(this.menuFilter);

            // Separate delay for sparkles/bells
            this.menuSparkleDelay = new Tone.PingPongDelay({
                delayTime: '4n',
                feedback: 0.5,
                wet: 0.4
            }).connect(this.menuReverb);

            // SFX gain
            if (!this.sfxGain) {
                this.sfxGain = new Tone.Gain(this.sfxVolume).toDestination();
            }

            // === SYNTH 1: Deep Sub Drone (Foundation) ===
            this.menuDrone = new Tone.FMSynth({
                harmonicity: 0.5,
                modulationIndex: 1.5,
                oscillator: { type: 'sine' },
                envelope: { attack: 4, decay: 2, sustain: 1, release: 6 },
                modulation: { type: 'sine' },
                modulationEnvelope: { attack: 2, decay: 1, sustain: 0.8, release: 4 }
            }).connect(this.menuGain);
            this.menuDrone.volume.value = -10;

            // === SYNTH 2: Evolving Pad (Atmosphere) ===
            this.menuPad = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sine4' },
                envelope: { attack: 3, decay: 2, sustain: 0.7, release: 5 }
            }).connect(this.menuGain);
            this.menuPad.volume.value = -14;

            // === SYNTH 3: Secondary Pad with movement ===
            this.menuPad2 = new Tone.PolySynth(Tone.FMSynth, {
                harmonicity: 2,
                modulationIndex: 1,
                envelope: { attack: 2, decay: 1.5, sustain: 0.6, release: 4 }
            }).connect(this.menuGain);
            this.menuPad2.volume.value = -18;

            // === SYNTH 4: Pulsing Bass ===
            this.menuBass = new Tone.MonoSynth({
                oscillator: { type: 'sawtooth8' },
                envelope: { attack: 0.02, decay: 0.4, sustain: 0.3, release: 0.8 },
                filterEnvelope: { attack: 0.01, decay: 0.3, sustain: 0.2, release: 0.5, baseFrequency: 80, octaves: 2.5 }
            }).connect(this.menuGain);
            this.menuBass.volume.value = -8;

            // === SYNTH 5: Plucky Arpeggiator ===
            this.menuArp = new Tone.Synth({
                oscillator: { type: 'triangle8' },
                envelope: { attack: 0.005, decay: 0.3, sustain: 0.1, release: 0.6 }
            }).connect(this.menuDelay);
            this.menuArp.volume.value = -16;

            // === SYNTH 6: Bell/Chime for sparkles ===
            this.menuBell = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sine' },
                envelope: { attack: 0.001, decay: 1.5, sustain: 0, release: 2 }
            }).connect(this.menuSparkleDelay);
            this.menuBell.volume.value = -20;

            // === SYNTH 7: Ethereal Voice/Choir ===
            this.menuChoir = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sine2' },
                envelope: { attack: 1.5, decay: 1, sustain: 0.8, release: 3 }
            }).connect(this.menuGain);
            this.menuChoir.volume.value = -22;

            // === SYNTH 8: Tension Strings ===
            this.menuStrings = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'sawtooth4' },
                envelope: { attack: 1, decay: 0.5, sustain: 0.9, release: 2 }
            }).connect(this.menuGain);
            this.menuStrings.volume.value = -20;

            // === SYNTH 9: Soft Kick for pulse ===
            this.menuKick = new Tone.MembraneSynth({
                pitchDecay: 0.08,
                octaves: 4,
                envelope: { attack: 0.001, decay: 0.5, sustain: 0, release: 0.5 }
            }).connect(this.menuGain);
            this.menuKick.volume.value = -18;

            // === SYNTH 10: Rising Sweep FX ===
            this.menuSweep = new Tone.Noise('pink').connect(
                new Tone.Filter({ frequency: 500, type: 'bandpass', Q: 2 }).connect(this.menuGain)
            );
            this.menuSweep.volume.value = -25;

            this.menuInitialized = true;
            this.initialized = true;

            this.startMenuMusic();

        } catch (e) {
            console.error('Menu music init failed:', e);
        }
    }

    startMenuMusic() {
        if (!this.menuInitialized || this.isMenuPlaying) return;

        Tone.Transport.bpm.value = 72;
        this.isMenuPlaying = true;

        // === MUSICAL DATA ===
        // 16-bar progression in A minor (cinematic, never repeats exactly the same)
        const chordProgressions = {
            section1: [ // Bars 1-4: Establishing
                { chord: ['A2', 'C3', 'E3'], bass: 'A1' },           // Am
                { chord: ['F2', 'A2', 'C3', 'E3'], bass: 'F1' },     // Fmaj7
                { chord: ['D2', 'F2', 'A2'], bass: 'D1' },           // Dm
                { chord: ['E2', 'G#2', 'B2'], bass: 'E1' },          // E
            ],
            section2: [ // Bars 5-8: Building
                { chord: ['A2', 'C3', 'E3', 'G3'], bass: 'A1' },     // Am7
                { chord: ['G2', 'B2', 'D3', 'F3'], bass: 'G1' },     // G7
                { chord: ['F2', 'A2', 'C3'], bass: 'F1' },           // F
                { chord: ['E2', 'G#2', 'B2', 'D3'], bass: 'E1' },    // E7
            ],
            section3: [ // Bars 9-12: Climax
                { chord: ['A2', 'E3', 'A3'], bass: 'A1' },           // Am (power)
                { chord: ['D2', 'A2', 'D3', 'F3'], bass: 'D1' },     // Dm add9
                { chord: ['G2', 'D3', 'G3'], bass: 'G1' },           // G (power)
                { chord: ['C2', 'E2', 'G2', 'B2'], bass: 'C1' },     // Cmaj7
            ],
            section4: [ // Bars 13-16: Resolution
                { chord: ['F2', 'C3', 'F3'], bass: 'F1' },           // F
                { chord: ['D2', 'F2', 'A2', 'C3'], bass: 'D1' },     // Dm7
                { chord: ['E2', 'B2', 'E3'], bass: 'E1' },           // Em
                { chord: ['A1', 'E2', 'A2'], bass: 'A0' },           // Am (low, resolving)
            ]
        };

        // Melodic themes (different for each section)
        const melodies = {
            theme1: ['E4', null, 'D4', 'C4', 'B3', null, 'A3', null],
            theme2: ['A4', 'G4', null, 'E4', 'D4', 'C4', null, 'A3'],
            theme3: ['E5', null, 'D5', 'C5', null, 'A4', 'G4', 'E4'],
            theme4: ['C4', 'D4', 'E4', null, 'G4', 'E4', 'D4', null],
        };

        // Arpeggios for each chord quality
        const arpPatterns = {
            minor: [0, 3, 7, 12, 7, 3],
            major: [0, 4, 7, 12, 7, 4],
            dom7: [0, 4, 7, 10, 7, 4],
            min7: [0, 3, 7, 10, 7, 3],
        };

        // Bell/chime notes (pentatonic for safety)
        const bellNotes = ['A4', 'C5', 'D5', 'E5', 'G5', 'A5', 'C6', 'E6'];

        // State tracking
        let sectionIndex = 0;
        let chordIndex = 0;
        let melodyIndex = 0;
        let measureCount = 0;
        let arpIndex = 0;
        let bellIndex = 0;

        const sections = ['section1', 'section2', 'section3', 'section4'];
        const melodyThemes = ['theme1', 'theme2', 'theme3', 'theme4'];

        // === PATTERN 1: Main Chord Pad (every 2 bars) ===
        const chordPattern = new Tone.Loop((time) => {
            const section = chordProgressions[sections[sectionIndex % 4]];
            const data = section[chordIndex % 4];

            this.menuPad.triggerAttackRelease(data.chord, '2m', time, 0.3);

            // Every other chord, add secondary pad with slight variation
            if (chordIndex % 2 === 0) {
                const upperChord = data.chord.map(n => {
                    const note = n.slice(0, -1);
                    const octave = parseInt(n.slice(-1)) + 1;
                    return note + octave;
                });
                this.menuPad2.triggerAttackRelease(upperChord, '2m', time + 0.1, 0.15);
            }

            chordIndex++;
            if (chordIndex % 4 === 0) {
                sectionIndex++;
            }
        }, '2m').start(0);
        this.menuPatterns.push(chordPattern);

        // === PATTERN 2: Deep Drone (every 4 bars, follows root) ===
        const dronePattern = new Tone.Loop((time) => {
            const section = chordProgressions[sections[sectionIndex % 4]];
            const bass = section[0].bass;
            this.menuDrone.triggerAttackRelease(bass, '4m', time, 0.4);
        }, '4m').start(0);
        this.menuPatterns.push(dronePattern);

        // === PATTERN 3: Bass Line (quarter notes with syncopation) ===
        let bassNoteIndex = 0;
        const bassPattern = new Tone.Loop((time) => {
            const section = chordProgressions[sections[sectionIndex % 4]];
            const chordData = section[Math.floor(bassNoteIndex / 2) % 4];

            // Syncopated rhythm: play on 1, skip 2, play on 3, &4
            const beatInMeasure = bassNoteIndex % 8;
            if (beatInMeasure === 0 || beatInMeasure === 4 || beatInMeasure === 6 || beatInMeasure === 7) {
                const velocity = beatInMeasure === 0 ? 0.5 : 0.35;
                this.menuBass.triggerAttackRelease(chordData.bass, '8n', time, velocity);
            }
            bassNoteIndex++;
        }, '4n').start('8m'); // Enter after 8 bars
        this.menuPatterns.push(bassPattern);

        // === PATTERN 4: Melodic Arpeggiator (16th notes, builds over time) ===
        const arpPattern = new Tone.Loop((time) => {
            const section = chordProgressions[sections[sectionIndex % 4]];
            const chordData = section[Math.floor(arpIndex / 6) % 4];
            const baseNote = chordData.chord[0];

            // Parse note and create arpeggio
            const noteName = baseNote.slice(0, -1);
            const octave = parseInt(baseNote.slice(-1)) + 1;
            const pattern = arpPatterns.minor;
            const semitone = pattern[arpIndex % pattern.length];

            // Convert to frequency and back for proper transposition
            const noteMap = { 'A': 0, 'A#': 1, 'Bb': 1, 'B': 2, 'C': 3, 'C#': 4, 'Db': 4,
                           'D': 5, 'D#': 6, 'Eb': 6, 'E': 7, 'F': 8, 'F#': 9, 'Gb': 9, 'G': 10, 'G#': 11 };
            const noteNames = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];

            const baseIndex = noteMap[noteName] || 0;
            const newIndex = (baseIndex + semitone) % 12;
            const octaveAdjust = Math.floor((baseIndex + semitone) / 12);
            const arpNote = noteNames[newIndex] + (octave + octaveAdjust);

            const velocity = 0.2 + Math.sin(arpIndex * 0.3) * 0.1;
            this.menuArp.triggerAttackRelease(arpNote, '16n', time, velocity);
            arpIndex++;
        }, '16n').start('16m'); // Enter after 16 bars for buildup
        this.menuPatterns.push(arpPattern);

        // === PATTERN 5: Melody Line (expressive, with rests) ===
        const melodyPattern = new Tone.Loop((time) => {
            const theme = melodies[melodyThemes[sectionIndex % 4]];
            const note = theme[melodyIndex % theme.length];

            if (note) {
                const velocity = 0.25 + Math.random() * 0.1;
                this.menuArp.triggerAttackRelease(note, '4n', time, velocity);
            }
            melodyIndex++;
        }, '4n').start('12m'); // Enter after 12 bars
        this.menuPatterns.push(melodyPattern);

        // === PATTERN 6: Bell/Chimes (sparse, random, beautiful) ===
        const bellPattern = new Tone.Loop((time) => {
            if (Math.random() > 0.7) {
                const note1 = bellNotes[Math.floor(Math.random() * bellNotes.length)];
                this.menuBell.triggerAttackRelease(note1, '8n', time, 0.15 + Math.random() * 0.1);

                // Occasionally play a second bell for shimmer
                if (Math.random() > 0.6) {
                    const note2 = bellNotes[Math.floor(Math.random() * bellNotes.length)];
                    this.menuBell.triggerAttackRelease(note2, '8n', time + 0.15, 0.1);
                }
            }
        }, '2n').start('4m');
        this.menuPatterns.push(bellPattern);

        // === PATTERN 7: Choir Swells (rare, emotional) ===
        const choirPattern = new Tone.Loop((time) => {
            if (sectionIndex % 4 === 2 || sectionIndex % 4 === 3) { // Only in climax/resolution
                const section = chordProgressions[sections[sectionIndex % 4]];
                const data = section[0];
                // Sing the fifth and octave
                const choirNotes = [data.chord[0], data.chord[2] || data.chord[1]].map(n => {
                    const note = n.slice(0, -1);
                    const octave = parseInt(n.slice(-1)) + 2;
                    return note + octave;
                });
                this.menuChoir.triggerAttackRelease(choirNotes, '4m', time, 0.2);
            }
        }, '4m').start('8m');
        this.menuPatterns.push(choirPattern);

        // === PATTERN 8: Tension Strings (in climax sections) ===
        const stringsPattern = new Tone.Loop((time) => {
            if (sectionIndex % 4 === 2) { // Climax section
                const section = chordProgressions.section3;
                const data = section[Math.floor((measureCount / 2) % 4)];
                this.menuStrings.triggerAttackRelease(data.chord, '2m', time, 0.15);
            }
            measureCount++;
        }, '2m').start('8m');
        this.menuPatterns.push(stringsPattern);

        // === PATTERN 9: Soft Heartbeat Kick ===
        const kickPattern = new Tone.Loop((time) => {
            if (sectionIndex >= 2) { // Only after buildup
                this.menuKick.triggerAttackRelease('A0', '8n', time, 0.25);
            }
        }, '1m').start('16m');
        this.menuPatterns.push(kickPattern);

        // === PATTERN 10: Occasional Sweep FX (transitions) ===
        const sweepPattern = new Tone.Loop((time) => {
            if (sectionIndex % 4 === 0 && sectionIndex > 0) { // At section transitions
                this.menuSweep.start(time);
                this.menuSweep.stop(time + 2);
            }
        }, '16m').start('16m');
        this.menuPatterns.push(sweepPattern);

        // === PATTERN 11: Filter Automation (evolving texture) ===
        const filterPattern = new Tone.Loop((time) => {
            // Slowly open filter as intensity builds
            const intensity = (sectionIndex % 4) / 4;
            const targetFreq = 1500 + intensity * 2000;
            this.menuFilter.frequency.rampTo(targetFreq, 4);
        }, '4m').start(0);
        this.menuPatterns.push(filterPattern);

        Tone.Transport.start();
    }

    stopMenuMusic() {
        if (!this.isMenuPlaying) return;
        this.isMenuPlaying = false;

        // Stop all menu patterns
        this.menuPatterns.forEach(p => {
            try { p.stop(); } catch (e) {}
        });
        this.menuPatterns = [];

        // Stop any running noise
        if (this.menuSweep) {
            try { this.menuSweep.stop(); } catch (e) {}
        }

        // Fade out synths
        if (this.menuGain) {
            this.menuGain.gain.rampTo(0, 1);
        }
    }

    // Transition from menu to game music
    transitionToGameMusic() {
        this.stopMenuMusic();

        // Brief pause then start combat music
        setTimeout(async () => {
            if (this.menuGain) this.menuGain.gain.value = 0.5; // Reset for next time

            // Fully stop and clear Transport before reinitializing
            Tone.Transport.stop();
            Tone.Transport.cancel(); // Cancel all scheduled events
            Tone.Transport.position = 0;

            // Reset playing state
            this.isPlaying = false;

            // Must call init() to set up sfxGain and all synths
            await this.init();
        }, 800);
    }

    // === VOLUME CONTROLS ===
    setMusicVolume(volume) {
        this.musicVolume = Math.max(0, Math.min(1, volume));
        if (this.musicGain) {
            this.musicGain.gain.value = 0.5 * this.musicVolume;
        }
    }

    setSfxVolume(volume) {
        this.sfxVolume = Math.max(0, Math.min(1, volume));
        if (this.sfxGain) {
            this.sfxGain.gain.value = this.sfxVolume;
        }
    }

    getMusicVolume() { return this.musicVolume; }
    getSfxVolume() { return this.sfxVolume; }

    // === INTENSITY CONTROL ===
    setCombatIntensity(intensity) {
        this.combatIntensity = Math.max(0, Math.min(1, intensity));

        // Adjust filter for more intensity
        if (this.filter) {
            const freq = 1000 + this.combatIntensity * 3000;
            this.filter.frequency.rampTo(freq, 0.5);
        }

        // Speed up BPM slightly with intensity
        if (this.initialized) {
            const targetBPM = 128 + Math.floor(this.combatIntensity * 20);
            Tone.Transport.bpm.rampTo(targetBPM, 2);
        }
    }

    setWaveNumber(wave) {
        this.currentWave = wave;
        // More intense as waves progress
        const baseIntensity = Math.min(0.3 + wave * 0.05, 0.8);
        this.setCombatIntensity(baseIntensity);
    }

    // Helper to ensure Tone.js is ready for sounds
    ensureToneReady() {
        // Start Tone if not running (fire and forget - browser requires user gesture anyway)
        if (Tone.context.state !== 'running') {
            Tone.start();
        }
        if (!this.sfxGain) {
            this.sfxGain = new Tone.Gain(this.sfxVolume || 0.8).toDestination();
        }
    }

    // === SWORD SWINGS - Realistic metal whoosh ===
    playSwing(isHeavy = false) {
        this.ensureToneReady();

        try {
            // Layer 1: Air whoosh (filtered noise with pitch envelope)
            const whooshFilter = new Tone.Filter({
                frequency: isHeavy ? 300 : 500,
                type: 'bandpass',
                Q: 1.5
            }).connect(this.sfxGain);

            const whoosh = new Tone.Noise('white').connect(whooshFilter);
            whoosh.volume.value = isHeavy ? 0 : -4;

            // Sweep the filter for motion feel
            whooshFilter.frequency.rampTo(isHeavy ? 800 : 1200, 0.08);
            whooshFilter.frequency.rampTo(isHeavy ? 200 : 300, 0.12);

            whoosh.start();
            whoosh.stop(isHeavy ? '+0.25' : '+0.15');

            // Layer 2: Metallic ring (blade cutting air)
            const blade = new Tone.Synth({
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 }
            }).connect(this.sfxGain);
            blade.volume.value = isHeavy ? -8 : -12;
            blade.triggerAttackRelease(isHeavy ? 180 : 280, 0.08);
            blade.frequency.rampTo(isHeavy ? 100 : 150, 0.1);

            setTimeout(() => {
                whoosh.dispose();
                whooshFilter.dispose();
                blade.dispose();
            }, 400);
        } catch (e) {
            // Silently fail
        }
    }

    // === ENEMY HIT - Satisfying impact when hitting enemies ===
    playEnemyHit(damage = 25) {
        this.ensureToneReady();
        try {
            const intensity = Math.min(damage / 50, 1);

            // Layer 1: Meaty thwack
            const thwack = new Tone.MembraneSynth({
                pitchDecay: 0.015,
                octaves: 3,
                envelope: { attack: 0.001, decay: 0.12, sustain: 0, release: 0.08 }
            }).connect(this.sfxGain);
            thwack.volume.value = -6 + intensity * 3;
            thwack.triggerAttackRelease(80 + intensity * 30, 0.1);

            // Layer 2: Sharp crack/slice
            const crack = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.001, decay: 0.04 + intensity * 0.02, sustain: 0, release: 0.02 }
            }).connect(this.sfxGain);
            crack.volume.value = -12 + intensity * 4;
            crack.triggerAttackRelease(0.05);

            // Layer 3: Subtle metal ring for blade
            const ring = new Tone.MetalSynth({
                frequency: 300 + intensity * 200,
                envelope: { attack: 0.001, decay: 0.06, release: 0.03 },
                harmonicity: 4,
                modulationIndex: 10,
                resonance: 3000,
                octaves: 0.5
            }).connect(this.sfxGain);
            ring.volume.value = -22 + intensity * 3;
            ring.triggerAttackRelease('32n');

            setTimeout(() => {
                thwack.dispose();
                crack.dispose();
                ring.dispose();
            }, 300);
        } catch (e) {
            // Silently fail
        }
    }

    // === PLAYER WEAPON HIT (for combo feedback) ===
    playHit(damage = 25) {
        this.playEnemyHit(damage);
    }

    // Enemy death - temporal dissolution
    playEnemyDeath(isBoss = false) {
        this.ensureToneReady();
        try {
        const duration = isBoss ? 1.2 : 0.5;

        // Descending synth - time unraveling
        const death = new Tone.Synth({
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.01, decay: duration, sustain: 0, release: 0.1 }
        }).connect(this.sfxGain);
        death.volume.value = isBoss ? -6 : -10;

        const startNote = isBoss ? 'C4' : 'A3';
        death.triggerAttackRelease(startNote, duration);

        // Pitch bend down
        death.frequency.rampTo(50, duration);

        // Crystalline shatter for boss
        if (isBoss) {
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const sparkle = new Tone.Synth({
                        oscillator: { type: 'sine' },
                        envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }
                    }).connect(this.sfxGain);
                    sparkle.volume.value = -15;
                    sparkle.triggerAttackRelease(1200 + i * 200, 0.2);
                    setTimeout(() => sparkle.dispose(), 400);
                }, i * 100);
            }
        }

        setTimeout(() => death.dispose(), duration * 1000 + 200);
        } catch (e) {
            console.error('playEnemyDeath error:', e);
        }
    }

    // Player damage - painful impact
    playPlayerHit() {
        this.ensureToneReady();
        try {

        // Low impact thud
        const impact = new Tone.MembraneSynth({
            pitchDecay: 0.08,
            octaves: 6,
            envelope: { attack: 0.001, decay: 0.25, sustain: 0, release: 0.1 }
        }).connect(this.sfxGain);
        impact.volume.value = -4;
        impact.triggerAttackRelease(40, 0.2);

        // Distorted crunch
        const distort = new Tone.Distortion(0.8).connect(this.sfxGain);
        const crunch = new Tone.Synth({
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.05 }
        }).connect(distort);
        crunch.volume.value = -12;
        crunch.triggerAttackRelease(150, 0.1);
        crunch.frequency.rampTo(40, 0.15);

        setTimeout(() => {
            impact.dispose();
            crunch.dispose();
            distort.dispose();
        }, 400);
        } catch (e) {
            console.error('playPlayerHit error:', e);
        }
    }

    // Dash - whoosh with pitch shift
    playDash() {
        this.ensureToneReady();
        try {

        // Filtered noise whoosh
        const filter = new Tone.Filter({
            frequency: 800,
            type: 'bandpass',
            Q: 2
        }).connect(this.sfxGain);

        const noise = new Tone.Noise('white').connect(filter);
        noise.volume.value = -10;

        // Pitch sweep
        filter.frequency.rampTo(2000, 0.1);
        filter.frequency.rampTo(400, 0.15);

        noise.start();
        noise.stop('+0.2');

        setTimeout(() => {
            noise.dispose();
            filter.dispose();
        }, 400);
        } catch (e) {
            console.error('playDash error:', e);
        }
    }

    // === TIME FRACTURE (Q) - Epic temporal explosion ===
    playTimeFracture() {
        this.ensureToneReady();
        try {

        // Layer 1: Intense charging buildup
        const charge = new Tone.FMSynth({
            harmonicity: 2,
            modulationIndex: 15,
            envelope: { attack: 0.01, decay: 0.2, sustain: 0.5, release: 0.1 },
            modulation: { type: 'sine' },
            modulationEnvelope: { attack: 0.01, decay: 0.15, sustain: 0.3, release: 0.05 }
        }).connect(this.sfxGain);
        charge.volume.value = -6;
        charge.triggerAttackRelease('A2', 0.2);
        charge.frequency.rampTo(1200, 0.18);

        // Layer 2: Sub bass rumble during charge
        const rumble = new Tone.Noise('brown').connect(this.sfxGain);
        rumble.volume.value = -8;
        rumble.start();
        rumble.stop('+0.2');

        // EXPLOSION after buildup
        setTimeout(() => {
            // Massive boom
            const boom = new Tone.MembraneSynth({
                pitchDecay: 0.15,
                octaves: 10,
                envelope: { attack: 0.001, decay: 0.5, sustain: 0, release: 0.3 }
            }).connect(this.sfxGain);
            boom.volume.value = 2;
            boom.triggerAttackRelease(35, 0.5);

            // White noise explosion
            const explodeFilter = new Tone.Filter({
                frequency: 5000,
                type: 'lowpass'
            }).connect(this.sfxGain);
            const explode = new Tone.Noise('white').connect(explodeFilter);
            explode.volume.value = -2;
            explodeFilter.frequency.rampTo(100, 0.5);
            explode.start();
            explode.stop('+0.5');

            // Temporal shatter - high crystalline sounds
            for (let i = 0; i < 4; i++) {
                setTimeout(() => {
                    const shard = new Tone.MetalSynth({
                        frequency: 800 + i * 300,
                        envelope: { attack: 0.001, decay: 0.15, release: 0.1 },
                        harmonicity: 5,
                        modulationIndex: 20,
                        resonance: 4000,
                        octaves: 1.5
                    }).connect(this.sfxGain);
                    shard.volume.value = -12;
                    shard.triggerAttackRelease('16n');
                    setTimeout(() => shard.dispose(), 300);
                }, i * 40);
            }

            // Reverberating sub tail
            const tail = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.1, decay: 0.6, sustain: 0, release: 0.3 }
            }).connect(this.sfxGain);
            tail.volume.value = -10;
            tail.triggerAttackRelease(40, 0.6);

            setTimeout(() => {
                boom.dispose();
                explode.dispose();
                explodeFilter.dispose();
                tail.dispose();
            }, 800);
        }, 180);

        setTimeout(() => {
            charge.dispose();
            rumble.dispose();
        }, 400);
        } catch (e) {
            console.error('playTimeFracture error:', e);
        }
    }

    // === TEMPORAL ECHO (E) - Ghostly phase shift ===
    playTemporalEcho() {
        this.ensureToneReady();
        try {

        // Layer 1: Ethereal ascending arpeggio
        const notes = ['E4', 'A4', 'C5', 'E5'];
        notes.forEach((note, i) => {
            setTimeout(() => {
                const shimmer = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.02, decay: 0.3, sustain: 0, release: 0.2 }
                }).connect(this.sfxGain);
                shimmer.volume.value = -10;
                shimmer.triggerAttackRelease(note, 0.25);
                setTimeout(() => shimmer.dispose(), 400);
            }, i * 50);
        });

        // Layer 2: Ghostly whoosh
        const whooshFilter = new Tone.Filter({
            frequency: 500,
            type: 'bandpass',
            Q: 3
        }).connect(this.sfxGain);
        const whoosh = new Tone.Noise('pink').connect(whooshFilter);
        whoosh.volume.value = -10;
        whooshFilter.frequency.rampTo(2000, 0.15);
        whooshFilter.frequency.rampTo(300, 0.25);
        whoosh.start();
        whoosh.stop('+0.4');

        // Layer 3: Phaser-like sweep
        const phase = new Tone.FMSynth({
            harmonicity: 1.5,
            modulationIndex: 8,
            envelope: { attack: 0.05, decay: 0.35, sustain: 0, release: 0.1 },
            modulation: { type: 'sine' }
        }).connect(this.sfxGain);
        phase.volume.value = -15;
        phase.triggerAttackRelease('A3', 0.35);
        phase.frequency.rampTo(200, 0.35);

        setTimeout(() => {
            whoosh.dispose();
            whooshFilter.dispose();
            phase.dispose();
        }, 600);
        } catch (e) {
            console.error('playTemporalEcho error:', e);
        }
    }

    // === TEMPORAL ECHO RETURN - Snap back to reality ===
    playEchoReturn() {
        this.ensureToneReady();
        try {

        // Reverse arpeggio (descending)
        const notes = ['E5', 'C5', 'A4', 'E4'];
        notes.forEach((note, i) => {
            setTimeout(() => {
                const shimmer = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.15, sustain: 0, release: 0.1 }
                }).connect(this.sfxGain);
                shimmer.volume.value = -8;
                shimmer.triggerAttackRelease(note, 0.12);
                setTimeout(() => shimmer.dispose(), 250);
            }, i * 35);
        });

        // Snap/pop effect
        setTimeout(() => {
            const snap = new Tone.NoiseSynth({
                noise: { type: 'white' },
                envelope: { attack: 0.001, decay: 0.03, sustain: 0, release: 0.01 }
            }).connect(this.sfxGain);
            snap.volume.value = -6;
            snap.triggerAttackRelease(0.03);

            const pop = new Tone.MembraneSynth({
                pitchDecay: 0.01,
                octaves: 4,
                envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.05 }
            }).connect(this.sfxGain);
            pop.volume.value = -8;
            pop.triggerAttackRelease(200, 0.06);

            setTimeout(() => {
                snap.dispose();
                pop.dispose();
            }, 150);
        }, 120);
        } catch (e) {
            console.error('playEchoReturn error:', e);
        }
    }

    // === CHRONOSTASIS (R) - Epic time freeze ===
    playChronostasis() {
        this.ensureToneReady();
        try {

        // Layer 1: Deep resonant gong/bell
        const gong = new Tone.MembraneSynth({
            pitchDecay: 0.3,
            octaves: 6,
            envelope: { attack: 0.01, decay: 2.5, sustain: 0, release: 0.8 }
        }).connect(this.sfxGain);
        gong.volume.value = -2;
        gong.triggerAttackRelease(40, 2);

        // Layer 2: High crystalline freeze shimmer
        const freezeChord = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: 'sine' },
            envelope: { attack: 0.2, decay: 1.5, sustain: 0, release: 0.5 }
        }).connect(this.sfxGain);
        freezeChord.volume.value = -10;
        freezeChord.triggerAttackRelease(['C6', 'E6', 'G6', 'B6'], 1.5);

        // Layer 3: Time slowing down - descending sweep
        const slowDown = new Tone.Synth({
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.05, decay: 1, sustain: 0, release: 0.3 }
        }).connect(this.sfxGain);
        slowDown.volume.value = -8;
        slowDown.triggerAttackRelease(600, 1);
        slowDown.frequency.rampTo(30, 1);

        // Layer 4: Ice crackling
        for (let i = 0; i < 6; i++) {
            setTimeout(() => {
                const crackle = new Tone.MetalSynth({
                    frequency: 1000 + Math.random() * 1000,
                    envelope: { attack: 0.001, decay: 0.05 + Math.random() * 0.05, release: 0.02 },
                    harmonicity: 4 + Math.random() * 2,
                    modulationIndex: 15,
                    resonance: 3000,
                    octaves: 1
                }).connect(this.sfxGain);
                crackle.volume.value = -18;
                crackle.triggerAttackRelease('64n');
                setTimeout(() => crackle.dispose(), 150);
            }, 200 + i * 150);
        }

        // Layer 5: Sustained frozen drone
        const drone = new Tone.FMSynth({
            harmonicity: 0.5,
            modulationIndex: 3,
            envelope: { attack: 0.5, decay: 1.5, sustain: 0, release: 0.5 },
            modulation: { type: 'sine' }
        }).connect(this.sfxGain);
        drone.volume.value = -12;
        drone.triggerAttackRelease('A1', 2);

        setTimeout(() => {
            gong.dispose();
            freezeChord.dispose();
            slowDown.dispose();
            drone.dispose();
        }, 3000);
        } catch (e) {
            console.error('playChronostasis error:', e);
        }
    }

    // Chronostasis end
    playChronostasisEnd() {
        this.ensureToneReady();
        try {

        // Time resuming - ascending sweep
        const filter = new Tone.Filter({
            frequency: 200,
            type: 'lowpass'
        }).connect(this.sfxGain);
        const sweep = new Tone.Synth({
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.1 }
        }).connect(filter);
        sweep.volume.value = -10;
        sweep.triggerAttackRelease(50, 0.4);
        sweep.frequency.rampTo(400, 0.3);
        filter.frequency.rampTo(2000, 0.3);

        setTimeout(() => {
            sweep.dispose();
            filter.dispose();
        }, 500);
        } catch (e) {
            console.error('playChronostasisEnd error:', e);
        }
    }

    // Wave announcement
    playWaveStart(waveNumber) {
        this.ensureToneReady();
        try {

        const isBossWave = waveNumber % 10 === 0 && waveNumber > 0;

        // Warning horn
        const filter = new Tone.Filter({
            frequency: 600,
            type: 'lowpass'
        }).connect(this.sfxGain);

        const horn = new Tone.Synth({
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.01, decay: 0.4, sustain: 0, release: 0.1 }
        }).connect(filter);
        horn.volume.value = -8;
        horn.triggerAttackRelease(isBossWave ? 150 : 200, 0.4);

        // Second horn blast
        setTimeout(() => {
            const horn2 = new Tone.Synth({
                oscillator: { type: 'sawtooth' },
                envelope: { attack: 0.01, decay: 0.7, sustain: 0, release: 0.2 }
            }).connect(filter);
            horn2.volume.value = -6;
            horn2.triggerAttackRelease(isBossWave ? 120 : 250, 0.7);
            setTimeout(() => horn2.dispose(), 1000);
        }, 500);

        // Boss wave gets extra ominous drone
        if (isBossWave) {
            const doom = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.1, decay: 2, sustain: 0, release: 0.5 }
            }).connect(this.sfxGain);
            doom.volume.value = -6;
            doom.triggerAttackRelease(40, 2);
            setTimeout(() => doom.dispose(), 2500);
        }

        setTimeout(() => {
            horn.dispose();
            filter.dispose();
        }, 1500);
        } catch (e) {
            console.error('playWaveStart error:', e);
        }
    }

    // Boss entrance
    playBossEntrance() {
        this.ensureToneReady();
        try {

        // Dramatic Am chord
        const chord = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.5, decay: 1, sustain: 0.3, release: 1 }
        }).connect(this.sfxGain);
        chord.volume.value = -8;
        chord.triggerAttackRelease(['A1', 'E2', 'A2', 'C3'], 2.5);

        // Thunderous impact
        setTimeout(() => {
            const impact = new Tone.MembraneSynth({
                pitchDecay: 0.3,
                octaves: 8,
                envelope: { attack: 0.001, decay: 0.7, sustain: 0, release: 0.3 }
            }).connect(this.sfxGain);
            impact.volume.value = 0;
            impact.triggerAttackRelease(30, 0.7);
            setTimeout(() => impact.dispose(), 1000);
        }, 300);

        setTimeout(() => chord.dispose(), 3500);
        } catch (e) {
            console.error('playBossEntrance error:', e);
        }
    }

    // Game over
    playGameOver() {
        this.ensureToneReady();
        try {

        // Descending death knell
        const knell = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.01, decay: 2, sustain: 0, release: 0.5 }
        }).connect(this.sfxGain);
        knell.volume.value = -6;
        knell.triggerAttackRelease(200, 2);
        knell.frequency.rampTo(50, 1.5);

        // Heartbeat fading
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                const beat = new Tone.MembraneSynth({
                    pitchDecay: 0.02,
                    octaves: 2,
                    envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }
                }).connect(this.sfxGain);
                beat.volume.value = -8 - i * 3;
                beat.triggerAttackRelease(60, 0.25);
                setTimeout(() => beat.dispose(), 400);
            }, i * 800);
        }

        setTimeout(() => knell.dispose(), 2500);
        } catch (e) {
            console.error('playGameOver error:', e);
        }
    }

    // Gold/coin pickup sound
    playGoldPickup() {
        this.ensureToneReady();
        try {
            const coin = new Tone.MetalSynth({
                frequency: 400,
                envelope: { attack: 0.001, decay: 0.1, release: 0.05 },
                harmonicity: 5,
                modulationIndex: 20,
                resonance: 3000,
                octaves: 1
            }).connect(this.sfxGain);
            coin.volume.value = -10;
            coin.triggerAttackRelease('16n');
            setTimeout(() => coin.dispose(), 200);
        } catch (e) {
            // Silently fail
        }
    }

    // Mote collection
    playMoteCollect() {
        this.ensureToneReady();
        try {

        const chime = new Tone.Synth({
            oscillator: { type: 'sine' },
            envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.05 }
        }).connect(this.sfxGain);
        chime.volume.value = -15;
        const freq = 800 + Math.random() * 400;
        chime.triggerAttackRelease(freq, 0.15);
        chime.frequency.rampTo(freq + 400, 0.1);

        setTimeout(() => chime.dispose(), 300);
        } catch (e) {
            // Silently fail
        }
    }

    // Wave complete
    playWaveComplete() {
        this.ensureToneReady();
        try {

        // Victory fanfare - ascending arpeggio
        const notes = ['C4', 'E4', 'G4', 'C5'];
        notes.forEach((note, i) => {
            setTimeout(() => {
                const osc = new Tone.Synth({
                    oscillator: { type: 'triangle' },
                    envelope: { attack: 0.01, decay: 0.35, sustain: 0, release: 0.1 }
                }).connect(this.sfxGain);
                osc.volume.value = -10;
                osc.triggerAttackRelease(note, 0.35);
                setTimeout(() => osc.dispose(), 500);
            }, i * 100);
        });
        } catch (e) {
            console.error('playWaveComplete error:', e);
        }
    }

    // Enemy spawn sound
    playEnemySpawn() {
        this.ensureToneReady();
        try {

        const filter = new Tone.Filter({
            frequency: 100,
            type: 'bandpass',
            Q: 2
        }).connect(this.sfxGain);

        const spawn = new Tone.Synth({
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.01, decay: 0.3, sustain: 0, release: 0.1 }
        }).connect(filter);
        spawn.volume.value = -12;
        spawn.triggerAttackRelease(50, 0.25);
        spawn.frequency.rampTo(200, 0.2);
        filter.frequency.rampTo(800, 0.2);

        setTimeout(() => {
            spawn.dispose();
            filter.dispose();
        }, 400);
        } catch (e) {
            console.error('playEnemySpawn error:', e);
        }
    }

    // Footstep
    playFootstep() {
        this.ensureToneReady();
        try {

        const step = new Tone.MembraneSynth({
            pitchDecay: 0.01,
            octaves: 2,
            envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.01 }
        }).connect(this.sfxGain);
        step.volume.value = -25;
        step.triggerAttackRelease(60 + Math.random() * 20, 0.04);

        setTimeout(() => step.dispose(), 100);
        } catch (e) {
            console.error('playFootstep error:', e);
        }
    }

    setVolume(value) {
        this.sfxVolume = Math.max(0, Math.min(1, value));
        if (this.sfxGain) {
            this.sfxGain.gain.value = this.sfxVolume;
        }
    }

    stopAmbience() {
        // No longer using ambient oscillators array
    }

    // === PISTOL SHOT - Punchy sci-fi energy weapon ===
    playPistolShot() {
        this.ensureToneReady();
        try {
            // Layer 1: Initial transient pop/crack
        const pop = new Tone.NoiseSynth({
            noise: { type: 'white' },
            envelope: { attack: 0.001, decay: 0.02, sustain: 0, release: 0.01 }
        }).connect(this.sfxGain);
        pop.volume.value = 2; // Boosted
        pop.triggerAttackRelease(0.02);

        // Layer 2: Body of the shot - punchy low thump
        const body = new Tone.MembraneSynth({
            pitchDecay: 0.01,
            octaves: 3,
            envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.05 }
        }).connect(this.sfxGain);
        body.volume.value = -6;
        body.triggerAttackRelease(100, 0.06);

        // Layer 3: High-end sizzle/zap for sci-fi feel
        const zap = new Tone.Synth({
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.001, decay: 0.06, sustain: 0, release: 0.02 }
        }).connect(this.sfxGain);
        zap.volume.value = -12;
        zap.triggerAttackRelease(2000, 0.04);
        zap.frequency.rampTo(600, 0.05);

        // Layer 4: Temporal energy tail
        const tail = new Tone.FMSynth({
            harmonicity: 3,
            modulationIndex: 10,
            envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 },
            modulation: { type: 'sine' },
            modulationEnvelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.05 }
        }).connect(this.sfxGain);
        tail.volume.value = -15;
        tail.triggerAttackRelease('C5', 0.12);

        setTimeout(() => {
            pop.dispose();
            body.dispose();
            zap.dispose();
            tail.dispose();
        }, 300);
        } catch (e) {
            console.error('playPistolShot error:', e);
        }
    }

    // === PISTOL RELOAD - Mechanical + energy charge ===
    playPistolReload() {
        this.ensureToneReady();
        try {

        // Mechanical click sequence
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                const click = new Tone.MetalSynth({
                    frequency: 400 + i * 80,
                    envelope: { attack: 0.001, decay: 0.03, release: 0.01 },
                    harmonicity: 3,
                    modulationIndex: 12,
                    resonance: 2000,
                    octaves: 0.3
                }).connect(this.sfxGain);
                click.volume.value = -10;
                click.triggerAttackRelease('64n');
                setTimeout(() => click.dispose(), 100);
            }, i * 100);
        }

        // Energy charging whine
        setTimeout(() => {
            const charge = new Tone.Synth({
                oscillator: { type: 'sine' },
                envelope: { attack: 0.05, decay: 0.4, sustain: 0.2, release: 0.1 }
            }).connect(this.sfxGain);
            charge.volume.value = -12;
            charge.triggerAttackRelease(300, 0.5);
            charge.frequency.rampTo(1200, 0.45);

            // Add shimmer
            const shimmer = new Tone.FMSynth({
                harmonicity: 2,
                modulationIndex: 5,
                envelope: { attack: 0.1, decay: 0.3, sustain: 0, release: 0.1 }
            }).connect(this.sfxGain);
            shimmer.volume.value = -20;
            shimmer.triggerAttackRelease('E5', 0.4);

            setTimeout(() => {
                charge.dispose();
                shimmer.dispose();
            }, 600);
        }, 250);
        } catch (e) {
            console.error('playPistolReload error:', e);
        }
    }

    // === SCYTHE SWING - Heavy, menacing sweep ===
    playScytheSwing() {
        this.ensureToneReady();
        try {
            // Layer 1: Deep heavy whoosh
        const lowFilter = new Tone.Filter({
            frequency: 200,
            type: 'lowpass',
            Q: 2
        }).connect(this.sfxGain);

        const deepWhoosh = new Tone.Noise('brown').connect(lowFilter);
        deepWhoosh.volume.value = 2; // Boosted
        lowFilter.frequency.rampTo(400, 0.15);
        lowFilter.frequency.rampTo(100, 0.25);

        deepWhoosh.start();
        deepWhoosh.stop('+0.45');

        // Layer 2: Mid-range air movement
        const midFilter = new Tone.Filter({
            frequency: 400,
            type: 'bandpass',
            Q: 1.5
        }).connect(this.sfxGain);

        const midWhoosh = new Tone.Noise('pink').connect(midFilter);
        midWhoosh.volume.value = -8;
        midFilter.frequency.rampTo(800, 0.1);
        midFilter.frequency.rampTo(300, 0.3);

        midWhoosh.start();
        midWhoosh.stop('+0.4');

        // Layer 3: Ominous low drone
        const drone = new Tone.Synth({
            oscillator: { type: 'sawtooth' },
            envelope: { attack: 0.02, decay: 0.4, sustain: 0, release: 0.15 }
        }).connect(this.sfxGain);
        drone.volume.value = -12;
        drone.triggerAttackRelease(60, 0.35);
        drone.frequency.rampTo(40, 0.35);

        // Layer 4: Sharp blade edge
        const edge = new Tone.Synth({
            oscillator: { type: 'triangle' },
            envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1 }
        }).connect(this.sfxGain);
        edge.volume.value = -16;
        edge.triggerAttackRelease(120, 0.12);
        edge.frequency.rampTo(60, 0.15);

        setTimeout(() => {
            deepWhoosh.dispose();
            lowFilter.dispose();
            midWhoosh.dispose();
            midFilter.dispose();
            drone.dispose();
            edge.dispose();
        }, 600);
        } catch (e) {
            console.error('playScytheSwing error:', e);
        }
    }

    // V2.8 - Combo milestone sound
    playComboMilestone(tier) {
        this.ensureToneReady();
        try {

        const baseFreq = 400 + tier * 100;
        const notes = [baseFreq, baseFreq * 1.25, baseFreq * 1.5];

        notes.forEach((freq, i) => {
            setTimeout(() => {
                const chime = new Tone.Synth({
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.25, sustain: 0, release: 0.05 }
                }).connect(this.sfxGain);
                chime.volume.value = -10;
                chime.triggerAttackRelease(freq, 0.25);
                setTimeout(() => chime.dispose(), 350);
            }, i * 80);
        });
        } catch (e) {
            console.error('playComboMilestone error:', e);
        }
    }

    // V2.8 - Low health heartbeat
    playHeartbeat(intensity = 1) {
        this.ensureToneReady();
        try {

        // Double beat
        for (let i = 0; i < 2; i++) {
            setTimeout(() => {
                const beat = new Tone.MembraneSynth({
                    pitchDecay: 0.02,
                    octaves: 3,
                    envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.05 }
                }).connect(this.sfxGain);
                beat.volume.value = -8 + intensity * 3;
                beat.triggerAttackRelease(50, 0.12);
                setTimeout(() => beat.dispose(), 200);
            }, i * 150);
        }
        } catch (e) {
            console.error('playHeartbeat error:', e);
        }
    }

    // V2.8 - Set ambient intensity based on combat
    setAmbientIntensity(intensity) {
        // Now handled by setCombatIntensity
    }
}

// Global audio manager instance
const audioManager = new AudioManager();

// â”€â”€â”€ SWORD CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Sword {
    constructor(scene, player) {
        this.scene = scene;
        this.player = player;

        // Sword properties
        this.mesh = null;
        this.bladeGlow = null;
        this.trailMesh = null;
        this.trailPositions = [];

        // Attack state
        this.isAttacking = false;
        this.attackPhase = 'none'; // 'windup', 'active', 'recovery'
        this.attackType = 'none'; // 'light', 'heavy'
        this.attackTimer = 0;
        this.comboCount = 0;
        this.comboTimer = 0;
        this.canCombo = false;
        this.hitFrameSet = false; // V2 - Track if hitFrame was set for current attack

        // Attack timings
        this.lightAttackTimings = {
            windup: 0.1,
            active: 0.15,
            recovery: 0.2
        };
        this.heavyAttackTimings = {
            windup: 0.4,
            active: 0.2,
            recovery: 0.5
        };
        // Scythe attack timings - slower 360-degree sweep
        this.scytheAttackTimings = {
            windup: 0.5,   // Longer windup for the spin
            active: 0.4,   // Longer active phase for full rotation
            recovery: 0.3
        };

        // Animation values
        this.swingAngle = 0;
        this.targetSwingAngle = 0;
        this.swingProgress = 0;

        // Charge level colors
        this.chargeColors = [
            new THREE.Color(0x4a90b8), // Level 0: Blue
            new THREE.Color(0x5aa0c8), // Level 1: Bright blue
            new THREE.Color(0xffffff), // Level 2: White
            new THREE.Color(0xd4af37), // Level 3: Gold
            new THREE.Color(0xffd700)  // Level 4: Brilliant gold
        ];

        // V4: VFX reference for trail particles
        this.vfx = null;
        this.trailParticleTimer = 0;

        this.createMesh();
        this.createTrail();
    }

    // V4: Set VFX manager reference
    setVFX(vfx) {
        this.vfx = vfx;
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Blade material - crystallized time (translucent with glow)
        const bladeMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90b8,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.85,
            metalness: 0.3,
            roughness: 0.2
        });
        this.bladeMaterial = bladeMaterial;

        // Handle material
        const handleMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a3a,
            metalness: 0.8,
            roughness: 0.3
        });

        // Gold accent material
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });

        // Blade - long, elegant shape (1.5 units)
        const bladeGeometry = new THREE.BoxGeometry(0.08, 1.2, 0.02);
        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
        blade.position.y = 0.75;
        blade.castShadow = true;
        this.mesh.add(blade);
        this.blade = blade;

        // Blade tip (pointed)
        const tipGeometry = new THREE.ConeGeometry(0.04, 0.25, 4);
        const tip = new THREE.Mesh(tipGeometry, bladeMaterial);
        tip.position.y = 1.45;
        tip.castShadow = true;
        this.mesh.add(tip);

        // Blade edge glow (inner light)
        const edgeGeometry = new THREE.BoxGeometry(0.02, 1.1, 0.005);
        const edgeMaterial = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 0.9
        });
        const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
        edge.position.y = 0.7;
        edge.position.z = 0.012;
        this.mesh.add(edge);
        this.bladeEdge = edge;

        // Crossguard
        const crossguardGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.06);
        const crossguard = new THREE.Mesh(crossguardGeometry, goldMaterial);
        crossguard.position.y = 0.1;
        crossguard.castShadow = true;
        this.mesh.add(crossguard);

        // Clock face in crossguard
        const clockFaceGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.07, 16);
        const clockFaceMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a90b8,
            transparent: true,
            opacity: 0.8
        });
        const clockFace = new THREE.Mesh(clockFaceGeometry, clockFaceMaterial);
        clockFace.position.set(0, 0.1, 0.035);
        clockFace.rotation.x = Math.PI / 2;
        this.mesh.add(clockFace);
        this.clockFace = clockFace;

        // Clock hands on crossguard
        const handGeometry = new THREE.BoxGeometry(0.01, 0.04, 0.005);
        const hourHand = new THREE.Mesh(handGeometry, new THREE.MeshBasicMaterial({ color: 0xd4af37 }));
        hourHand.position.set(0, 0.1, 0.075);
        this.mesh.add(hourHand);
        this.clockHourHand = hourHand;

        const minuteHandGeometry = new THREE.BoxGeometry(0.008, 0.05, 0.005);
        const minuteHand = new THREE.Mesh(minuteHandGeometry, new THREE.MeshBasicMaterial({ color: 0xd4af37 }));
        minuteHand.position.set(0, 0.1, 0.075);
        this.mesh.add(minuteHand);
        this.clockMinuteHand = minuteHand;

        // Handle
        const handleGeometry = new THREE.CylinderGeometry(0.03, 0.035, 0.25, 8);
        const handle = new THREE.Mesh(handleGeometry, handleMaterial);
        handle.position.y = -0.05;
        handle.castShadow = true;
        this.mesh.add(handle);

        // Pommel
        const pommelGeometry = new THREE.SphereGeometry(0.045, 8, 8);
        const pommel = new THREE.Mesh(pommelGeometry, goldMaterial);
        pommel.position.y = -0.2;
        this.mesh.add(pommel);

        // Blade glow light
        this.bladeGlow = new THREE.PointLight(0x4a90b8, 0.6, 3);
        this.bladeGlow.position.y = 0.8;
        this.mesh.add(this.bladeGlow);

        // Initial position (held at side)
        this.mesh.position.set(0.5, 0.3, 0.5);
        this.mesh.rotation.x = -0.8;
        this.mesh.rotation.z = -0.2;
    }

    createTrail() {
        // Create trail geometry
        const trailLength = CONFIG.trailSegments;
        const trailGeometry = new THREE.BufferGeometry();

        // Each segment is a quad (2 triangles, 6 vertices)
        const positions = new Float32Array(trailLength * 6 * 3);
        const colors = new Float32Array(trailLength * 6 * 4);

        trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 4));

        const trailMaterial = new THREE.MeshBasicMaterial({
            vertexColors: true,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        this.trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
        this.trailMesh.frustumCulled = false;
        this.scene.add(this.trailMesh);

        // Initialize trail positions
        for (let i = 0; i < trailLength; i++) {
            this.trailPositions.push({
                base: new THREE.Vector3(),
                tip: new THREE.Vector3(),
                alpha: 0
            });
        }
    }

    update(deltaTime, elapsedTime) {
        // Update charge-based color
        this.updateBladeColor();

        // Animate clock hands on crossguard
        this.clockHourHand.rotation.z = elapsedTime * 0.5;
        this.clockMinuteHand.rotation.z = elapsedTime * 2;

        // Update attack animation
        if (this.isAttacking) {
            this.updateAttack(deltaTime);
        } else {
            // Idle sword sway
            this.mesh.rotation.x = -0.8 + Math.sin(elapsedTime * 2) * 0.02;
        }

        // Update combo timer
        if (this.comboTimer > 0) {
            this.comboTimer -= deltaTime;
            if (this.comboTimer <= 0) {
                this.comboCount = 0;
            }
        }

        // Update trail
        this.updateTrail(deltaTime);
    }

    updateBladeColor() {
        const chargeRatio = this.player.temporalCharge / CONFIG.maxCharge;
        let colorIndex = 0;

        if (chargeRatio >= 1.0) colorIndex = 4;
        else if (chargeRatio >= 0.75) colorIndex = 3;
        else if (chargeRatio >= 0.5) colorIndex = 2;
        else if (chargeRatio >= 0.25) colorIndex = 1;

        const targetColor = this.chargeColors[colorIndex];

        // Lerp to target color
        this.bladeMaterial.color.lerp(targetColor, 0.1);
        this.bladeMaterial.emissive.lerp(targetColor, 0.1);
        this.bladeGlow.color.lerp(targetColor, 0.1);

        // Increase intensity with charge
        this.bladeMaterial.emissiveIntensity = 0.5 + chargeRatio * 0.5;
        this.bladeGlow.intensity = 0.6 + chargeRatio * 0.8;
    }

    startLightAttack() {
        if (this.isAttacking && !this.canCombo) return false;
        if (this.player.stamina < CONFIG.lightAttackStamina) return false;
        if (this.player.isSprinting) return false;

        // Use stamina
        this.player.stamina -= CONFIG.lightAttackStamina;
        this.player.staminaRegenTimer = CONFIG.staminaRegenDelay;

        // Track combo
        if (this.canCombo && this.comboCount < 3) {
            this.comboCount++;
        } else {
            this.comboCount = 1;
        }

        this.isAttacking = true;
        this.attackType = 'light';
        this.attackPhase = 'windup';
        this.attackTimer = 0;
        this.canCombo = false;
        this.swingProgress = 0;
        this.hitFrameSet = false; // V2 - Reset hit tracking for new attack

        // Determine swing direction based on combo
        if (this.comboCount === 1) {
            this.targetSwingAngle = Math.PI * 0.6; // Right to left
        } else if (this.comboCount === 2) {
            this.targetSwingAngle = -Math.PI * 0.6; // Left to right
        } else {
            this.targetSwingAngle = Math.PI * 0.8; // Overhead slam
        }

        // Play swing sound - V2.8: weapon-specific
        if (this.player.currentWeapon === 'scythe') {
            audioManager.playScytheSwing();
        } else {
            audioManager.playSwing(false);
        }

        return true;
    }

    startHeavyAttack() {
        if (this.isAttacking) return false;
        if (this.player.stamina < CONFIG.heavyAttackStamina) return false;
        if (this.player.isSprinting) return false;

        // Use stamina
        this.player.stamina -= CONFIG.heavyAttackStamina;
        this.player.staminaRegenTimer = CONFIG.staminaRegenDelay;

        this.isAttacking = true;
        this.attackType = 'heavy';
        this.attackPhase = 'windup';
        this.attackTimer = 0;
        this.comboCount = 0;
        this.canCombo = false;
        this.swingProgress = 0;
        this.hitFrameSet = false; // V2 - Reset hit tracking for new attack
        this.targetSwingAngle = Math.PI; // Full overhead

        // Play heavy swing sound - V2.8: weapon-specific
        if (this.player.currentWeapon === 'scythe') {
            audioManager.playScytheSwing();
        } else {
            audioManager.playSwing(true);
        }

        return true;
    }

    updateAttack(deltaTime) {
        // Use scythe timings if using scythe, otherwise light/heavy based on attack type
        let timings;
        if (this.player && this.player.currentWeapon === 'scythe') {
            timings = this.scytheAttackTimings;
        } else {
            timings = this.attackType === 'light' ? this.lightAttackTimings : this.heavyAttackTimings;
        }

        this.attackTimer += deltaTime;

        switch (this.attackPhase) {
            case 'windup':
                // Wind up animation
                const windupProgress = this.attackTimer / timings.windup;
                this.animateWindup(windupProgress);

                if (this.attackTimer >= timings.windup) {
                    this.attackPhase = 'active';
                    this.attackTimer = 0;
                }
                break;

            case 'active':
                // Active swing - hitbox is active
                const activeProgress = this.attackTimer / timings.active;
                this.animateSwing(activeProgress);

                if (this.attackTimer >= timings.active) {
                    this.attackPhase = 'recovery';
                    this.attackTimer = 0;
                    // Can combo during recovery for light attacks
                    if (this.attackType === 'light' && this.comboCount < 3) {
                        this.canCombo = true;
                        this.comboTimer = 0.5; // Window to input next attack
                    }
                }
                break;

            case 'recovery':
                // Recovery animation
                const recoveryProgress = this.attackTimer / timings.recovery;
                this.animateRecovery(recoveryProgress);

                if (this.attackTimer >= timings.recovery) {
                    this.endAttack();
                }
                break;
        }
    }

    animateWindup(progress) {
        const eased = this.easeOutQuad(progress);

        // Scythe spin windup - crouch down and prepare to spin
        if (this.player && this.player.currentWeapon === 'scythe') {
            this.mesh.rotation.x = -0.8 - eased * 0.5;
            this.mesh.rotation.z = -0.2;
            this.mesh.position.y = 0.3 - eased * 0.1;
            this.spinAngle = 0; // Reset spin angle
        } else if (this.comboCount === 3 || this.attackType === 'heavy') {
            // Overhead swing - raise sword high
            this.mesh.rotation.x = -0.8 - eased * 2.0;
            this.mesh.rotation.z = -0.2 + eased * 0.2;
            this.mesh.position.y = 0.3 + eased * 0.5;
        } else if (this.comboCount === 2) {
            // Left side swing
            this.mesh.rotation.x = -0.8 - eased * 0.3;
            this.mesh.rotation.z = -0.2 - eased * 1.2;
            this.mesh.position.x = 0.5 - eased * 0.8;
        } else {
            // Right side swing (default)
            this.mesh.rotation.x = -0.8 - eased * 0.3;
            this.mesh.rotation.z = -0.2 + eased * 1.2;
            this.mesh.position.x = 0.5 + eased * 0.3;
        }
    }

    animateSwing(progress) {
        const eased = this.easeInQuad(progress);

        // Scythe 360-degree spin attack
        if (this.player && this.player.currentWeapon === 'scythe') {
            // Full 360-degree rotation (2 * PI radians)
            this.spinAngle = progress * Math.PI * 2;
            this.mesh.rotation.z = -0.2 + Math.sin(this.spinAngle) * 0.5;
            this.mesh.position.x = 0.5 + Math.cos(this.spinAngle) * 0.3;
            this.mesh.position.z = 0.5 + Math.sin(this.spinAngle) * 0.3;
        } else if (this.comboCount === 3 || this.attackType === 'heavy') {
            // Overhead slam down
            this.mesh.rotation.x = -2.8 + eased * 3.5;
            this.mesh.position.y = 0.8 - eased * 0.6;
            this.mesh.position.z = 0.5 + eased * 0.5;
        } else if (this.comboCount === 2) {
            // Swing from left to right
            this.mesh.rotation.z = -1.4 + eased * 2.6;
            this.mesh.position.x = -0.3 + eased * 1.0;
        } else {
            // Swing from right to left
            this.mesh.rotation.z = 1.0 - eased * 2.4;
            this.mesh.position.x = 0.8 - eased * 0.8;
        }

        this.swingProgress = progress;
    }

    animateRecovery(progress) {
        const eased = this.easeOutQuad(progress);

        // Return to idle position
        this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, -0.8, eased);
        this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, -0.2, eased);
        this.mesh.position.x = THREE.MathUtils.lerp(this.mesh.position.x, 0.5, eased);
        this.mesh.position.y = THREE.MathUtils.lerp(this.mesh.position.y, 0.3, eased);
        this.mesh.position.z = THREE.MathUtils.lerp(this.mesh.position.z, 0.5, eased);
    }

    endAttack() {
        this.isAttacking = false;
        this.attackPhase = 'none';
        this.attackType = 'none';
        this.canCombo = false;

        // Reset combo if timer expired
        if (this.comboTimer <= 0) {
            this.comboCount = 0;
        }
    }

    updateTrail(deltaTime = 0.016) {
        // Shift trail positions
        for (let i = this.trailPositions.length - 1; i > 0; i--) {
            this.trailPositions[i].base.copy(this.trailPositions[i - 1].base);
            this.trailPositions[i].tip.copy(this.trailPositions[i - 1].tip);
            this.trailPositions[i].alpha = this.trailPositions[i - 1].alpha * 0.85;
        }

        // Get current sword world positions
        const swordWorldMatrix = new THREE.Matrix4();
        this.mesh.updateMatrixWorld();
        swordWorldMatrix.copy(this.mesh.matrixWorld);

        // Transform blade base and tip to world space
        const bladeBase = new THREE.Vector3(0, 0.15, 0);
        const bladeTip = new THREE.Vector3(0, 1.5, 0);

        bladeBase.applyMatrix4(swordWorldMatrix);
        bladeTip.applyMatrix4(swordWorldMatrix);

        this.trailPositions[0].base.copy(bladeBase);
        this.trailPositions[0].tip.copy(bladeTip);

        // Trail is visible during attacks
        if (this.isAttacking && this.attackPhase === 'active') {
            this.trailPositions[0].alpha = 1.0;

            // V4: Spawn trail particles during active swing
            if (this.vfx) {
                this.trailParticleTimer += deltaTime;
                if (this.trailParticleTimer >= 0.02) { // Spawn every 20ms
                    this.trailParticleTimer = 0;

                    // Spawn particles along the blade
                    const chargeRatio = this.player.temporalCharge / CONFIG.maxCharge;
                    const particleColor = chargeRatio > 0.75 ? 'gold' : chargeRatio > 0.5 ? 'white' : 'cyan';

                    // Random position along blade
                    const t = Math.random();
                    const particlePos = new THREE.Vector3().lerpVectors(bladeBase, bladeTip, t);

                    this.vfx.spawnHitSparks(particlePos, 2, particleColor, {
                        speed: 3 + chargeRatio * 5,
                        spread: 0.3,
                        size: 0.5 + chargeRatio * 0.5,
                        gravity: 5,
                        lifetime: 0.3,
                        glow: chargeRatio > 0.5
                    });
                }
            }
        } else {
            this.trailPositions[0].alpha = Math.max(0, this.trailPositions[0].alpha - 0.1);
            this.trailParticleTimer = 0;
        }

        // Update trail geometry
        const positions = this.trailMesh.geometry.attributes.position.array;
        const colors = this.trailMesh.geometry.attributes.color.array;

        const chargeRatio = this.player.temporalCharge / CONFIG.maxCharge;
        const trailColor = this.bladeMaterial.color;

        for (let i = 0; i < this.trailPositions.length - 1; i++) {
            const curr = this.trailPositions[i];
            const next = this.trailPositions[i + 1];
            const alpha = curr.alpha * (1 - i / this.trailPositions.length);

            const idx = i * 18; // 6 vertices * 3 components

            // First triangle
            positions[idx] = curr.base.x;
            positions[idx + 1] = curr.base.y;
            positions[idx + 2] = curr.base.z;

            positions[idx + 3] = curr.tip.x;
            positions[idx + 4] = curr.tip.y;
            positions[idx + 5] = curr.tip.z;

            positions[idx + 6] = next.tip.x;
            positions[idx + 7] = next.tip.y;
            positions[idx + 8] = next.tip.z;

            // Second triangle
            positions[idx + 9] = curr.base.x;
            positions[idx + 10] = curr.base.y;
            positions[idx + 11] = curr.base.z;

            positions[idx + 12] = next.tip.x;
            positions[idx + 13] = next.tip.y;
            positions[idx + 14] = next.tip.z;

            positions[idx + 15] = next.base.x;
            positions[idx + 16] = next.base.y;
            positions[idx + 17] = next.base.z;

            // Colors with alpha
            const cIdx = i * 24; // 6 vertices * 4 components
            for (let j = 0; j < 6; j++) {
                colors[cIdx + j * 4] = trailColor.r;
                colors[cIdx + j * 4 + 1] = trailColor.g;
                colors[cIdx + j * 4 + 2] = trailColor.b;
                colors[cIdx + j * 4 + 3] = alpha * (0.6 + chargeRatio * 0.4);
            }
        }

        this.trailMesh.geometry.attributes.position.needsUpdate = true;
        this.trailMesh.geometry.attributes.color.needsUpdate = true;
    }

    // Get attack hitbox for collision detection
    getAttackHitbox() {
        if (!this.isAttacking || this.attackPhase !== 'active') {
            return null;
        }

        // Get sword tip world position
        this.mesh.updateMatrixWorld();
        const tipLocal = new THREE.Vector3(0, 1.2, 0);
        const tipWorld = tipLocal.applyMatrix4(this.mesh.matrixWorld);

        return {
            position: tipWorld,
            radius: CONFIG.weapons.blade.range, // Use blade's configured range (3)
            arc: CONFIG.weapons.blade.arc,      // Use blade's configured arc (120)
            playerRotation: this.player.rotation,
            damage: this.getDamage()
        };
    }

    getDamage() {
        let baseDamage = this.attackType === 'heavy' ? CONFIG.weapons.blade.heavyDamage : CONFIG.weapons.blade.lightDamage;

        // Combo bonus for third light attack
        if (this.attackType === 'light' && this.comboCount === 3) {
            baseDamage = CONFIG.weapons.blade.heavyDamage; // Overhead slam does heavy damage
        }

        // Charge bonus
        const chargeRatio = this.player.temporalCharge / CONFIG.maxCharge;
        let multiplier = 1.0;

        if (chargeRatio >= 1.0) multiplier = 1.5;
        else if (chargeRatio >= 0.75) multiplier = 1.3;
        else if (chargeRatio >= 0.5) multiplier = 1.2;
        else if (chargeRatio >= 0.25) multiplier = 1.1;

        return baseDamage * multiplier;
    }

    // Easing functions
    easeOutQuad(t) {
        return t * (2 - t);
    }

    easeInQuad(t) {
        return t * t;
    }

    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
}

// â”€â”€â”€ V3: HEALTH DROP SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class HealthDrop {
    constructor(scene, position) {
        this.scene = scene;
        this.position = position.clone();
        this.position.y = 0.5; // Float above ground
        this.lifetime = 15; // Disappear after 15 seconds
        this.age = 0;
        this.healAmount = 15; // Heal 15 HP on pickup
        this.pickupRadius = 1.5;
        this.bobPhase = Math.random() * Math.PI * 2;
        this.collected = false;

        this.createMesh();
    }

    createMesh() {
        // Create a glowing health orb
        const group = new THREE.Group();

        // Inner core (bright)
        const coreGeom = new THREE.SphereGeometry(0.25, 12, 12);
        const coreMat = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.9
        });
        this.core = new THREE.Mesh(coreGeom, coreMat);
        group.add(this.core);

        // Outer glow sphere
        const glowGeom = new THREE.SphereGeometry(0.4, 12, 12);
        const glowMat = new THREE.MeshBasicMaterial({
            color: 0x00ff88,
            transparent: true,
            opacity: 0.3
        });
        this.glow = new THREE.Mesh(glowGeom, glowMat);
        group.add(this.glow);

        // Plus sign indicator
        const plusMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const hBar = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.08, 0.08), plusMat);
        const vBar = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.3, 0.08), plusMat);
        group.add(hBar);
        group.add(vBar);

        // Point light for glow effect
        this.light = new THREE.PointLight(0x00ff88, 0.5, 3);
        group.add(this.light);

        group.position.copy(this.position);
        this.mesh = group;
        this.scene.add(this.mesh);
    }

    update(deltaTime, elapsedTime) {
        this.age += deltaTime;

        // Bob up and down
        const bobHeight = Math.sin(elapsedTime * 3 + this.bobPhase) * 0.15;
        this.mesh.position.y = 0.5 + bobHeight;

        // Rotate slowly
        this.mesh.rotation.y += deltaTime * 2;

        // Pulse glow
        const pulse = 0.3 + Math.sin(elapsedTime * 5) * 0.1;
        this.glow.material.opacity = pulse;
        this.light.intensity = 0.4 + Math.sin(elapsedTime * 5) * 0.2;

        // Blink when about to expire (last 3 seconds)
        if (this.lifetime - this.age < 3) {
            const blink = Math.sin(elapsedTime * 15) > 0;
            this.mesh.visible = blink;
        }

        // Check if expired
        return this.age < this.lifetime && !this.collected;
    }

    checkPickup(playerPosition) {
        if (this.collected) return false;

        const dx = this.position.x - playerPosition.x;
        const dz = this.position.z - playerPosition.z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        if (distance < this.pickupRadius) {
            this.collected = true;
            return true;
        }
        return false;
    }

    dispose() {
        this.scene.remove(this.mesh);
        // Dispose geometries and materials
        this.mesh.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
}

// â”€â”€â”€ V4 INFINITE: GOLD COIN DROP â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class GoldCoin {
    constructor(scene, position, value = 1) {
        this.scene = scene;
        this.position = position.clone();
        // Scatter slightly from spawn point
        this.position.x += (Math.random() - 0.5) * 1.5;
        this.position.z += (Math.random() - 0.5) * 1.5;
        this.position.y = 0.3;
        this.value = value;
        this.lifetime = 20; // Disappear after 20 seconds
        this.age = 0;
        this.pickupRadius = 2.0; // Generous pickup radius
        this.collected = false;
        this.bobPhase = Math.random() * Math.PI * 2;
        this.spinSpeed = 3 + Math.random() * 2;

        // Initial velocity for scatter effect
        this.velocity = new THREE.Vector3(
            (Math.random() - 0.5) * 3,
            3 + Math.random() * 2,
            (Math.random() - 0.5) * 3
        );
        this.gravity = -15;
        this.grounded = false;

        this.createMesh();
    }

    createMesh() {
        const group = new THREE.Group();

        // Gold coin - flat cylinder
        const coinGeom = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
        const coinMat = new THREE.MeshBasicMaterial({
            color: 0xffd700,
            transparent: true,
            opacity: 0.95
        });
        this.coin = new THREE.Mesh(coinGeom, coinMat);
        this.coin.rotation.x = Math.PI / 2; // Lay flat initially
        group.add(this.coin);

        // Inner shine
        const shineGeom = new THREE.CylinderGeometry(0.12, 0.12, 0.06, 16);
        const shineMat = new THREE.MeshBasicMaterial({
            color: 0xffec80,
            transparent: true,
            opacity: 0.7
        });
        this.shine = new THREE.Mesh(shineGeom, shineMat);
        this.shine.rotation.x = Math.PI / 2;
        group.add(this.shine);

        // Small glow
        this.light = new THREE.PointLight(0xffd700, 0.3, 2);
        group.add(this.light);

        group.position.copy(this.position);
        this.mesh = group;
        this.scene.add(this.mesh);
    }

    update(deltaTime, elapsedTime) {
        this.age += deltaTime;

        // Physics for initial scatter
        if (!this.grounded) {
            this.velocity.y += this.gravity * deltaTime;
            this.position.add(this.velocity.clone().multiplyScalar(deltaTime));

            // Ground collision
            if (this.position.y <= 0.2) {
                this.position.y = 0.2;
                this.grounded = true;
                this.velocity.set(0, 0, 0);
            }
        } else {
            // Bob up and down when grounded
            const bobHeight = Math.sin(elapsedTime * 3 + this.bobPhase) * 0.1;
            this.position.y = 0.3 + bobHeight;
        }

        this.mesh.position.copy(this.position);

        // Spin the coin
        this.coin.rotation.z += deltaTime * this.spinSpeed;
        this.shine.rotation.z += deltaTime * this.spinSpeed;

        // Pulse glow
        this.light.intensity = 0.2 + Math.sin(elapsedTime * 4) * 0.1;

        // Blink when about to expire (last 4 seconds)
        if (this.lifetime - this.age < 4) {
            const blink = Math.sin(elapsedTime * 12) > 0;
            this.mesh.visible = blink;
        }

        return this.age < this.lifetime && !this.collected;
    }

    checkPickup(playerPosition) {
        if (this.collected) return false;

        const dx = this.position.x - playerPosition.x;
        const dz = this.position.z - playerPosition.z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        if (distance < this.pickupRadius) {
            this.collected = true;
            return true;
        }
        return false;
    }

    dispose() {
        this.scene.remove(this.mesh);
        this.mesh.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
}

// â”€â”€â”€ V4 INFINITE: BOSS TREASURE CHEST â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class TreasureChest {
    constructor(scene, position, waveNumber) {
        this.scene = scene;
        this.position = position.clone();
        this.position.y = 0;
        this.waveNumber = waveNumber;
        this.isOpen = false;
        this.collected = false;
        this.interactRadius = 3.0;
        this.bobPhase = 0;
        this.glowIntensity = 0;

        this.createMesh();
    }

    createMesh() {
        const group = new THREE.Group();

        // Chest base (box shape)
        const baseGeom = new THREE.BoxGeometry(1.2, 0.8, 0.8);
        const baseMat = new THREE.MeshStandardMaterial({
            color: 0x8b4513,  // Brown wood
            metalness: 0.2,
            roughness: 0.8
        });
        this.base = new THREE.Mesh(baseGeom, baseMat);
        this.base.position.y = 0.4;
        group.add(this.base);

        // Chest lid (half cylinder approximation with box)
        const lidGeom = new THREE.BoxGeometry(1.3, 0.4, 0.9);
        const lidMat = new THREE.MeshStandardMaterial({
            color: 0x654321,
            metalness: 0.3,
            roughness: 0.7
        });
        this.lid = new THREE.Mesh(lidGeom, lidMat);
        this.lid.position.set(0, 1.0, 0);
        group.add(this.lid);

        // Gold trim/lock
        const lockGeom = new THREE.BoxGeometry(0.3, 0.3, 0.1);
        const lockMat = new THREE.MeshStandardMaterial({
            color: 0xffd700,
            metalness: 0.8,
            roughness: 0.2,
            emissive: 0xffd700,
            emissiveIntensity: 0.3
        });
        this.lock = new THREE.Mesh(lockGeom, lockMat);
        this.lock.position.set(0, 0.8, 0.45);
        group.add(this.lock);

        // Corner trims
        const trimGeom = new THREE.BoxGeometry(0.15, 0.9, 0.15);
        const corners = [[-0.55, 0, -0.35], [0.55, 0, -0.35], [-0.55, 0, 0.35], [0.55, 0, 0.35]];
        corners.forEach(pos => {
            const trim = new THREE.Mesh(trimGeom, lockMat.clone());
            trim.position.set(pos[0], 0.45, pos[2]);
            group.add(trim);
        });

        // Glowing aura
        this.light = new THREE.PointLight(0xffd700, 1.5, 8);
        this.light.position.y = 1;
        group.add(this.light);

        // Particle beam upward
        const beamGeom = new THREE.CylinderGeometry(0.1, 0.3, 5, 8);
        const beamMat = new THREE.MeshBasicMaterial({
            color: 0xffd700,
            transparent: true,
            opacity: 0.3
        });
        this.beam = new THREE.Mesh(beamGeom, beamMat);
        this.beam.position.y = 3;
        group.add(this.beam);

        group.position.copy(this.position);
        this.mesh = group;
        this.scene.add(this.mesh);
    }

    update(deltaTime, elapsedTime) {
        if (this.collected) return false;

        this.bobPhase += deltaTime * 2;

        // Bob and rotate
        if (!this.isOpen) {
            this.mesh.position.y = this.position.y + Math.sin(this.bobPhase) * 0.15;
            this.mesh.rotation.y += deltaTime * 0.5;

            // Pulsing glow
            this.glowIntensity = 1.0 + Math.sin(elapsedTime * 3) * 0.5;
            this.light.intensity = this.glowIntensity;
            this.beam.material.opacity = 0.2 + Math.sin(elapsedTime * 2) * 0.1;
        }

        return true;
    }

    canInteract(playerPosition) {
        if (this.isOpen || this.collected) return false;

        const dx = this.position.x - playerPosition.x;
        const dz = this.position.z - playerPosition.z;
        const distance = Math.sqrt(dx * dx + dz * dz);

        return distance < this.interactRadius;
    }

    open() {
        if (this.isOpen) return null;
        this.isOpen = true;

        // Animate lid opening
        this.lid.rotation.x = -Math.PI * 0.6;
        this.lid.position.y = 1.3;
        this.lid.position.z = -0.3;

        // Hide beam
        this.beam.visible = false;

        // Generate loot based on wave - boss chests are guaranteed good
        const items = [];
        const numItems = 2 + Math.floor(this.waveNumber / 10); // 2-4 items

        for (let i = 0; i < numItems; i++) {
            // Force minimum rarity based on wave
            const waveBonus = this.waveNumber * 2; // Extra bonus for boss chest
            const item = lootGenerator.generateItem(null, null, this.waveNumber + 10);
            if (item) items.push(item);
        }

        // Bonus gold
        const goldAmount = 100 + this.waveNumber * 20;

        return { items, gold: goldAmount };
    }

    dispose() {
        this.collected = true;
        this.scene.remove(this.mesh);
        this.mesh.traverse((child) => {
            if (child.geometry) child.geometry.dispose();
            if (child.material) child.material.dispose();
        });
    }
}

// â”€â”€â”€ ENEMY BASE CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Enemy {
    constructor(scene, position) {
        this.scene = scene;
        this.position = position.clone();
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.rotation = 0;

        this.health = 40;
        this.maxHealth = 40;
        this.damage = 15;
        this.speed = 6;
        this.points = 100;

        this.mesh = null;
        this.isAlive = true;
        this.isDying = false;
        this.deathTimer = 0;

        // State
        this.state = 'SPAWN';
        this.stateTimer = 0;

        // Hit flash
        this.isFlashing = false;
        this.flashTimer = 0;

        // Hit tracking (prevent multiple hits from same attack)
        this.lastHitFrame = -1;

        // Track if this attack already hit the player (prevent multi-hit)
        this.hasHitPlayer = false;

        // Health bar sprite (will be created in subclass after mesh exists)
        this.healthBarSprite = null;
        this.healthBarCanvas = null;
        this.healthBarContext = null;
        this.enemyName = 'Enemy'; // Override in subclass
        this.healthBarHeight = 2.0; // Height above enemy mesh
        this.lastDrawnHealth = -1; // V6: Track last drawn health for optimization
    }

    createHealthBar() {
        // Create canvas for health bar
        this.healthBarCanvas = document.createElement('canvas');
        this.healthBarCanvas.width = 128;
        this.healthBarCanvas.height = 32;
        this.healthBarContext = this.healthBarCanvas.getContext('2d');

        // Create texture and sprite
        const texture = new THREE.CanvasTexture(this.healthBarCanvas);
        texture.minFilter = THREE.LinearFilter;
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false
        });
        this.healthBarSprite = new THREE.Sprite(spriteMaterial);
        this.healthBarSprite.scale.set(1.5, 0.4, 1);
        this.healthBarSprite.renderOrder = 999; // Render on top

        // Add to scene (not to mesh, so it billboards properly)
        this.scene.add(this.healthBarSprite);

        // Initial draw
        this.updateHealthBar();
    }

    updateHealthBar() {
        if (!this.healthBarContext || !this.healthBarSprite) return;

        // V6: Only redraw canvas if health changed (major optimization)
        const needsRedraw = this.lastDrawnHealth !== this.health;

        if (needsRedraw) {
            this.lastDrawnHealth = this.health;

            const ctx = this.healthBarContext;
            const w = this.healthBarCanvas.width;
            const h = this.healthBarCanvas.height;

            // Clear canvas
            ctx.clearRect(0, 0, w, h);

            // Draw enemy name (semi-transparent, bigger)
            ctx.font = 'bold 14px Arial';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.textAlign = 'center';
            ctx.fillText(this.enemyName.toUpperCase(), w / 2, 12);

            // Health bar background
            const barX = 8;
            const barY = 16;
            const barWidth = w - 16;
            const barHeight = 12;

            // Background (dark, semi-transparent)
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Health fill
            const healthPercent = Math.max(0, this.health / this.maxHealth);
            const fillWidth = barWidth * healthPercent;

            // Color based on health (green -> yellow -> red)
            let fillColor;
            if (healthPercent > 0.6) {
                fillColor = `rgba(50, 205, 50, 0.8)`; // Green
            } else if (healthPercent > 0.3) {
                fillColor = `rgba(255, 200, 0, 0.8)`; // Yellow
            } else {
                fillColor = `rgba(255, 60, 60, 0.8)`; // Red
            }
            ctx.fillStyle = fillColor;
            ctx.fillRect(barX, barY, fillWidth, barHeight);

            // Border
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // Update texture
            this.healthBarSprite.material.map.needsUpdate = true;
        }

        // Always update position (sprite follows enemy)
        if (this.mesh) {
            this.healthBarSprite.position.set(
                this.mesh.position.x,
                this.mesh.position.y + this.healthBarHeight,
                this.mesh.position.z
            );
        }
    }

    hideHealthBar() {
        if (this.healthBarSprite) {
            this.healthBarSprite.visible = false;
        }
    }

    takeDamage(amount, hitFrame) {
        // Prevent double hits from same attack
        if (hitFrame === this.lastHitFrame) return false;
        this.lastHitFrame = hitFrame;

        this.health -= amount;
        this.isFlashing = true;
        this.flashTimer = 0.08;

        if (this.health <= 0) {
            this.die();
            return 'killed'; // Enemy killed
        }
        return true; // Enemy damaged but alive
    }

    die() {
        this.isAlive = false;
        this.isDying = true;
        this.deathTimer = 0;
        this.state = 'DEAD';
        // Immediately hide health bar on death
        this.hideHealthBar();
    }

    update(deltaTime, playerPosition) {
        // Override in subclasses
    }

    updateFlash(deltaTime) {
        if (this.isFlashing) {
            this.flashTimer -= deltaTime;
            if (this.flashTimer <= 0) {
                this.isFlashing = false;
                this.restoreMaterials();
            } else {
                this.applyFlash();
            }
        }
    }

    applyFlash() {
        // Override in subclasses
    }

    restoreMaterials() {
        // Override in subclasses
    }

    destroy() {
        if (this.mesh) {
            this.scene.remove(this.mesh);
        }
        if (this.healthBarSprite) {
            this.scene.remove(this.healthBarSprite);
            this.healthBarSprite = null;
        }
    }
}

// â”€â”€â”€ TICK ENEMY CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Tick extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Tick';
        this.healthBarHeight = 1.5;

        // V2: Apply difficulty modifiers
        const baseDamage = 8; // Low damage - player can take ~12 hits on Normal
        const baseSpeed = 5; // Slower approach
        const baseHealth = 40; // With light attack (25 dmg): Easy=1hit, Normal=2hits, Hard=3hits, Nightmare=4hits
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 100;

        // State timings - V2: telegraph affected by difficulty
        const baseTelegraph = 0.6;
        this.stateTimes = {
            SPAWN: 1.0,
            IDLE: 0.5,
            APPROACH: 0, // Until within range
            TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            ATTACK: 0.3,
            RECOVER: 0.8
        };

        // Attack properties
        this.attackRange = 3;
        this.lungeDistance = 4;
        this.lungeDirection = new THREE.Vector3();

        // Animation
        this.legPhase = 0;
        this.clockHandRotation = 0;

        // Materials (stored for flash effect)
        this.materials = {};

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b7355,
            metalness: 0.7,
            roughness: 0.3
        });
        this.materials.body = bodyMaterial;

        const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90b8,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.3,
            transparent: true,
            opacity: 0.7,
            metalness: 0.2,
            roughness: 0.1
        });
        this.materials.glass = glassMaterial;

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });
        this.materials.gold = goldMaterial;

        // Main body - spherical clock face
        const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        this.mesh.add(body);
        this.bodyMesh = body;

        // Clock face (front)
        const faceGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.1, 24);
        const face = new THREE.Mesh(faceGeometry, glassMaterial);
        face.position.set(0, 0, 0.35);
        face.rotation.x = Math.PI / 2;
        face.castShadow = true;
        this.mesh.add(face);

        // Clock ring
        const ringGeometry = new THREE.TorusGeometry(0.45, 0.05, 8, 24);
        const ring = new THREE.Mesh(ringGeometry, goldMaterial);
        ring.position.set(0, 0, 0.4);
        this.mesh.add(ring);

        // Eye in center
        const eyeGeometry = new THREE.SphereGeometry(0.1, 12, 12);
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444
        });
        this.materials.eye = eyeMaterial;
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.set(0, 0, 0.45);
        this.mesh.add(eye);
        this.eye = eye;

        // Clock hands
        const hourHandGeometry = new THREE.BoxGeometry(0.03, 0.2, 0.02);
        const hourHand = new THREE.Mesh(hourHandGeometry, goldMaterial);
        hourHand.position.set(0, 0.1, 0.42);
        this.mesh.add(hourHand);
        this.hourHand = hourHand;

        const minuteHandGeometry = new THREE.BoxGeometry(0.02, 0.3, 0.02);
        const minuteHand = new THREE.Mesh(minuteHandGeometry, goldMaterial);
        minuteHand.position.set(0, 0.15, 0.42);
        this.mesh.add(minuteHand);
        this.minuteHand = minuteHand;

        // Roman numerals (small marks)
        for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI * 2) / 12;
            const markGeometry = new THREE.BoxGeometry(0.02, 0.06, 0.02);
            const mark = new THREE.Mesh(markGeometry, goldMaterial);
            mark.position.set(
                Math.sin(angle) * 0.35,
                Math.cos(angle) * 0.35,
                0.42
            );
            mark.rotation.z = -angle;
            this.mesh.add(mark);
        }

        // Spider legs (4 legs)
        this.legs = [];
        const legMaterial = new THREE.MeshStandardMaterial({
            color: 0x6b5344,
            metalness: 0.6,
            roughness: 0.4
        });
        this.materials.leg = legMaterial;

        for (let i = 0; i < 4; i++) {
            const legGroup = new THREE.Group();

            // Upper leg
            const upperLegGeometry = new THREE.CylinderGeometry(0.04, 0.03, 0.4, 8);
            const upperLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
            upperLeg.position.y = -0.2;
            legGroup.add(upperLeg);

            // Lower leg
            const lowerLegGroup = new THREE.Group();
            const lowerLegGeometry = new THREE.CylinderGeometry(0.03, 0.02, 0.5, 8);
            const lowerLeg = new THREE.Mesh(lowerLegGeometry, legMaterial);
            lowerLeg.position.y = -0.25;
            lowerLegGroup.add(lowerLeg);

            // Foot (claw)
            const footGeometry = new THREE.ConeGeometry(0.03, 0.1, 4);
            const foot = new THREE.Mesh(footGeometry, goldMaterial);
            foot.position.y = -0.55;
            foot.rotation.x = Math.PI;
            lowerLegGroup.add(foot);

            lowerLegGroup.position.y = -0.4;
            lowerLegGroup.rotation.x = 0.5;
            legGroup.add(lowerLegGroup);

            // Position legs around body
            const angle = (i * Math.PI * 2) / 4 + Math.PI / 4;
            legGroup.position.set(
                Math.cos(angle) * 0.35,
                0,
                Math.sin(angle) * 0.35
            );
            legGroup.rotation.z = Math.cos(angle) * 0.5;
            legGroup.rotation.x = Math.sin(angle) * 0.5;

            this.mesh.add(legGroup);
            this.legs.push({ group: legGroup, lower: lowerLegGroup, baseAngle: angle });
        }

        // Trailing gears/springs
        const gearGeometry = new THREE.TorusGeometry(0.1, 0.02, 6, 12);
        const trailGear1 = new THREE.Mesh(gearGeometry, bodyMaterial);
        trailGear1.position.set(0, -0.3, -0.3);
        trailGear1.rotation.x = Math.random() * Math.PI;
        this.mesh.add(trailGear1);
        this.trailGear = trailGear1;

        const springGeometry = new THREE.TorusGeometry(0.05, 0.015, 4, 12, Math.PI * 3);
        const spring = new THREE.Mesh(springGeometry, goldMaterial);
        spring.position.set(0.2, -0.2, -0.2);
        this.mesh.add(spring);

        // Point light for eye glow
        const eyeLight = new THREE.PointLight(0xff4444, 0.3, 2);
        eyeLight.position.set(0, 0, 0.5);
        this.mesh.add(eyeLight);
        this.eyeLight = eyeLight;

        // Position mesh
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 0.6; // Hover height
        this.scene.add(this.mesh);

        // Start invisible for spawn animation
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        // Handle death animation
        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // V4: Pulsing core glow effect
        const pulseSpeed = 4 + (1 - this.health / this.maxHealth) * 4; // Faster when damaged
        const pulseIntensity = 0.3 + Math.sin(this.stateTimer * pulseSpeed) * 0.15;
        this.materials.glass.emissiveIntensity = pulseIntensity;
        this.materials.gold.emissiveIntensity = 0.2 + Math.sin(this.stateTimer * pulseSpeed + 1) * 0.1;

        // Eye pulses more intensely when low health
        const healthRatio = this.health / this.maxHealth;
        if (healthRatio < 0.3) {
            this.eye.material.emissiveIntensity = 0.5 + Math.sin(this.stateTimer * 10) * 0.5;
            this.eyeLight.intensity = 0.5 + Math.sin(this.stateTimer * 10) * 0.3;
        }

        // Animate clock hands (erratic spinning)
        this.clockHandRotation += deltaTime * 5;
        this.hourHand.rotation.z = Math.sin(this.clockHandRotation * 2) * Math.PI;
        this.minuteHand.rotation.z = Math.sin(this.clockHandRotation * 3 + 1) * Math.PI;

        // Rotate trailing gear
        this.trailGear.rotation.x += deltaTime * 2;
        this.trailGear.rotation.y += deltaTime;

        // Direction to player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        // State machine
        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'IDLE':
                this.updateIdle(deltaTime, toPlayer);
                break;
            case 'APPROACH':
                this.updateApproach(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'TELEGRAPH':
                this.updateTelegraph(deltaTime, toPlayer);
                break;
            case 'ATTACK':
                this.updateAttack(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
        }

        // Update mesh position
        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        // Scale up animation
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        const scale = Math.min(1, progress * 1.5);
        this.mesh.scale.set(scale, scale, scale);

        // Spin clock hands rapidly
        this.hourHand.rotation.z = this.stateTimer * 20;
        this.minuteHand.rotation.z = this.stateTimer * 30;

        // Invulnerable during spawn
        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'IDLE';
            this.stateTimer = 0;
            this.mesh.scale.set(1, 1, 1);
        }
    }

    updateIdle(deltaTime, toPlayer) {
        // Brief pause, "noticing" player
        // Point clock hands at player
        const angleToPlayer = Math.atan2(toPlayer.x, toPlayer.z);
        this.hourHand.rotation.z = angleToPlayer;
        this.minuteHand.rotation.z = angleToPlayer;

        // Face player
        this.rotation = angleToPlayer;
        this.mesh.rotation.y = this.rotation;

        if (this.stateTimer >= this.stateTimes.IDLE) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
        }
    }

    updateApproach(deltaTime, toPlayer, distanceToPlayer) {
        // Move toward player
        this.velocity.x = toPlayer.x * this.speed;
        this.velocity.z = toPlayer.z * this.speed;

        this.position.x += this.velocity.x * deltaTime;
        this.position.z += this.velocity.z * deltaTime;

        // Face movement direction
        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Animate legs (skittering)
        this.legPhase += deltaTime * this.speed * 2;
        for (let i = 0; i < this.legs.length; i++) {
            const leg = this.legs[i];
            const phase = this.legPhase + (i * Math.PI / 2);
            leg.group.rotation.x += Math.sin(phase) * 0.1;
            leg.lower.rotation.x = 0.5 + Math.sin(phase + Math.PI / 4) * 0.3;
        }

        // Bob up and down
        this.mesh.position.y = 0.6 + Math.sin(this.legPhase * 2) * 0.1;

        // Intensify eye glow as getting closer
        this.eyeLight.intensity = 0.3 + (1 - distanceToPlayer / 20) * 0.5;

        // Stop when within attack range
        if (distanceToPlayer <= this.attackRange) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
            this.velocity.set(0, 0, 0);
        }
    }

    updateTelegraph(deltaTime, toPlayer) {
        // Rear back, prepare attack
        const progress = this.stateTimer / this.stateTimes.TELEGRAPH;

        // Rear back animation
        this.mesh.position.y = 0.6 + progress * 0.4;
        this.mesh.rotation.x = -progress * 0.5;

        // Lock clock hands to 12 o'clock
        this.hourHand.rotation.z = THREE.MathUtils.lerp(this.hourHand.rotation.z, 0, progress);
        this.minuteHand.rotation.z = THREE.MathUtils.lerp(this.minuteHand.rotation.z, 0, progress);

        // Eye glows brighter
        this.eyeLight.intensity = 0.5 + progress * 1.0;
        this.eye.material.emissiveIntensity = progress;

        // Store lunge direction
        this.lungeDirection.copy(toPlayer);

        if (this.stateTimer >= this.stateTimes.TELEGRAPH) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
            this.hasHitPlayer = false; // Reset hit flag for new attack
        }
    }

    updateAttack(deltaTime) {
        // Lunge forward
        const progress = this.stateTimer / this.stateTimes.ATTACK;
        const lungeSpeed = this.lungeDistance / this.stateTimes.ATTACK;

        // Fast forward movement
        this.position.x += this.lungeDirection.x * lungeSpeed * deltaTime;
        this.position.z += this.lungeDirection.z * lungeSpeed * deltaTime;

        // Lunge animation - lean forward
        this.mesh.rotation.x = 0.5 - progress * 0.3;
        this.mesh.position.y = 1.0 - progress * 0.6;

        // Leg slash animation
        for (let i = 0; i < this.legs.length; i++) {
            this.legs[i].group.rotation.x = progress * 1.0;
        }

        if (this.stateTimer >= this.stateTimes.ATTACK) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateRecover(deltaTime) {
        // Recovery - vulnerable
        const progress = this.stateTimer / this.stateTimes.RECOVER;

        // Return to normal position
        this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, progress);
        this.mesh.position.y = THREE.MathUtils.lerp(this.mesh.position.y, 0.6, progress);

        // Clock hands spin randomly
        this.hourHand.rotation.z = Math.sin(this.stateTimer * 10) * Math.PI;
        this.minuteHand.rotation.z = Math.cos(this.stateTimer * 12) * Math.PI;

        // Return legs to normal
        for (let i = 0; i < this.legs.length; i++) {
            this.legs[i].group.rotation.x *= 0.9;
        }

        // Eye dims
        this.eyeLight.intensity = 0.3;

        if (this.stateTimer >= this.stateTimes.RECOVER) {
            this.state = 'IDLE';
            this.stateTimer = 0;
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 1.0; // V4: Slightly longer for more dramatic death

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            // V4: Enhanced dissolve death animation
            // Chaotic spinning acceleration
            const spinSpeed = 10 + progress * 20;
            this.mesh.rotation.y += deltaTime * spinSpeed;
            this.mesh.rotation.x += deltaTime * spinSpeed * 0.5;
            this.mesh.rotation.z += deltaTime * spinSpeed * 0.3;

            // Rise up dramatically then implode
            if (progress < 0.4) {
                this.mesh.position.y += deltaTime * 5;
                // Expand slightly before implode
                const expandScale = 1 + progress * 0.5;
                this.mesh.scale.set(expandScale, expandScale, expandScale);
            } else {
                // Implode and fall
                const implodeProgress = (progress - 0.4) / 0.6;
                const implodeScale = 1.5 * (1 - implodeProgress * implodeProgress);
                this.mesh.scale.set(implodeScale, implodeScale, implodeScale);
                this.mesh.position.y -= deltaTime * 8 * implodeProgress;
            }

            // Dissolve effect - materials become emissive then fade
            this.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.transparent = true;
                    child.material.opacity = Math.max(0, 1 - progress * 1.2);
                    // Glow bright before fading
                    if (child.material.emissive && progress < 0.5) {
                        child.material.emissiveIntensity = progress * 3;
                    }
                }
            });

            // Eye goes supernova then fades
            if (progress < 0.5) {
                this.eyeLight.intensity = 0.5 + progress * 8;
                this.eyeLight.distance = 2 + progress * 6;
            } else {
                this.eyeLight.intensity = Math.max(0, 4 - (progress - 0.5) * 8);
            }

            // Legs flail wildly
            for (let i = 0; i < this.legs.length; i++) {
                this.legs[i].group.rotation.x = Math.sin(this.deathTimer * 15 + i) * progress * 2;
                this.legs[i].group.rotation.z = Math.cos(this.deathTimer * 12 + i) * progress * 1.5;
            }
        } else {
            // Death complete
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        // Simple scale pulse instead of material changes to avoid rendering issues
        if (this.mesh) {
            this.mesh.scale.setScalar(1.3);
        }
    }

    restoreMaterials() {
        // Restore normal scale
        if (this.mesh) {
            this.mesh.scale.setScalar(1.0);
        }
    }

    // Check if this enemy's attack hits the player
    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if (this.state !== 'ATTACK') return false;
        if (this.hasHitPlayer) return false; // Only hit once per attack

        const dist = Vec3.distance(this.position, playerPosition);
        if (dist < (playerRadius + 0.8)) {
            this.hasHitPlayer = true; // Mark as hit
            return true;
        }
        return false;
    }

    // Reset hit flag when entering new attack
    resetAttackHit() {
        this.hasHitPlayer = false;
    }

    // Check if in vulnerable recovery state
    isVulnerable() {
        return this.state === 'RECOVER';
    }
}

// â”€â”€â”€ TOCK ENEMY CLASS (Fast Flanker) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Tock extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Tock';
        this.healthBarHeight = 2.0;

        // V2: Apply difficulty modifiers
        const baseDamage = 6; // Fast but very weak
        const baseSpeed = 8; // Still fast but not insane
        const baseHealth = 40; // Same as Tick for consistent hit-to-kill scaling
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 200;

        // State timings - V2: telegraph affected by difficulty
        const baseTelegraph = 0.4;
        this.stateTimes = {
            SPAWN: 0.8,
            CIRCLE: 2.5,
            BLINK: 0.1,
            TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            ATTACK: 0.5,
            RETREAT: 0.3
        };

        // Orbit properties
        this.orbitAngle = Math.random() * Math.PI * 2;
        this.orbitRadius = 8;
        this.orbitDirection = Math.random() > 0.5 ? 1 : -1;

        // Attack properties
        this.dashTarget = new THREE.Vector3();
        this.hasHitPlayer = false;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x6b5344,
            metalness: 0.7,
            roughness: 0.3
        });

        const clockMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90b8,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.4,
            transparent: true,
            opacity: 0.8
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });

        // Two clock faces connected (figure-8 shape)
        // First clock face
        const face1Geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.15, 16);
        const face1 = new THREE.Mesh(face1Geometry, clockMaterial);
        face1.position.set(0, 0.4, 0);
        face1.rotation.x = Math.PI / 2;
        this.mesh.add(face1);
        this.face1 = face1;

        // Second clock face
        const face2 = new THREE.Mesh(face1Geometry, clockMaterial);
        face2.position.set(0, -0.4, 0);
        face2.rotation.x = Math.PI / 2;
        this.mesh.add(face2);
        this.face2 = face2;

        // Connecting spine
        const spineGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8);
        const spine = new THREE.Mesh(spineGeometry, bodyMaterial);
        spine.rotation.x = Math.PI / 2;
        this.mesh.add(spine);

        // Eyes on each face
        const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0xffcc00
        });

        const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        eye1.position.set(0, 0.4, 0.15);
        this.mesh.add(eye1);
        this.eye1 = eye1;

        const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        eye2.position.set(0, -0.4, 0.15);
        this.mesh.add(eye2);
        this.eye2 = eye2;

        // Pendulum beneath
        const pendulumRodGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8);
        const pendulumRod = new THREE.Mesh(pendulumRodGeometry, goldMaterial);
        pendulumRod.position.set(0, -0.9, 0);
        this.mesh.add(pendulumRod);
        this.pendulumRod = pendulumRod;

        const pendulumWeightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const pendulumWeight = new THREE.Mesh(pendulumWeightGeometry, goldMaterial);
        pendulumWeight.position.set(0, -1.2, 0);
        this.mesh.add(pendulumWeight);
        this.pendulumWeight = pendulumWeight;

        // Clock hands on faces
        const handGeometry = new THREE.BoxGeometry(0.02, 0.25, 0.02);
        this.hands = [];
        for (let i = 0; i < 4; i++) {
            const hand = new THREE.Mesh(handGeometry, goldMaterial);
            hand.position.y = i < 2 ? 0.4 : -0.4;
            hand.position.z = 0.08;
            this.mesh.add(hand);
            this.hands.push(hand);
        }

        // Point light
        const light = new THREE.PointLight(0xffcc00, 0.4, 3);
        light.position.set(0, 0, 0.2);
        this.mesh.add(light);
        this.light = light;

        // Position mesh
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 1.2;
        this.scene.add(this.mesh);

        // Start invisible for spawn
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate pendulum
        this.pendulumRod.rotation.z = Math.sin(this.stateTimer * 4) * 0.3;
        this.pendulumWeight.position.x = Math.sin(this.stateTimer * 4) * 0.15;

        // Animate hands
        for (let i = 0; i < this.hands.length; i++) {
            this.hands[i].rotation.z = this.stateTimer * (i + 2);
        }

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'CIRCLE':
                this.updateCircle(deltaTime, playerPosition);
                break;
            case 'TELEGRAPH':
                this.updateTelegraph(deltaTime, playerPosition);
                break;
            case 'ATTACK':
                this.updateAttack(deltaTime, playerPosition);
                break;
            case 'RETREAT':
                this.updateRetreat(deltaTime, playerPosition);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        this.mesh.scale.setScalar(Math.min(1, progress * 1.5));

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'CIRCLE';
            this.stateTimer = 0;
        }
    }

    updateCircle(deltaTime, playerPosition) {
        // Orbit around player
        this.orbitAngle += this.orbitDirection * this.speed * 0.1 * deltaTime;

        this.position.x = playerPosition.x + Math.cos(this.orbitAngle) * this.orbitRadius;
        this.position.z = playerPosition.z + Math.sin(this.orbitAngle) * this.orbitRadius;

        // Face player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Transition to attack
        if (this.stateTimer >= this.stateTimes.CIRCLE) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
        }
    }

    updateTelegraph(deltaTime, playerPosition) {
        const progress = this.stateTimer / this.stateTimes.TELEGRAPH;

        // Lock hands
        for (let i = 0; i < this.hands.length; i++) {
            this.hands[i].rotation.z = Math.PI;
        }

        // Eyes glow brighter
        this.light.intensity = 0.4 + progress * 1.0;

        // Store dash target
        this.dashTarget.copy(playerPosition);
        this.hasHitPlayer = false;

        if (this.stateTimer >= this.stateTimes.TELEGRAPH) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
            this.hasHitPlayer = false; // Reset hit flag for new attack
        }
    }

    updateAttack(deltaTime, playerPosition) {
        // Dash through player position
        const toTarget = new THREE.Vector3(
            this.dashTarget.x - this.position.x,
            0,
            this.dashTarget.z - this.position.z
        );

        if (toTarget.length() > 0.5) {
            toTarget.normalize();
            this.position.x += toTarget.x * this.speed * 3 * deltaTime;
            this.position.z += toTarget.z * this.speed * 3 * deltaTime;
        }

        if (this.stateTimer >= this.stateTimes.ATTACK) {
            this.state = 'RETREAT';
            this.stateTimer = 0;
        }
    }

    updateRetreat(deltaTime, playerPosition) {
        // Continue moving away
        const fromPlayer = new THREE.Vector3(
            this.position.x - playerPosition.x,
            0,
            this.position.z - playerPosition.z
        ).normalize();

        this.position.x += fromPlayer.x * this.speed * deltaTime;
        this.position.z += fromPlayer.z * this.speed * deltaTime;

        if (this.stateTimer >= this.stateTimes.RETREAT) {
            this.state = 'CIRCLE';
            this.stateTimer = 0;
            this.orbitAngle = Math.atan2(
                this.position.z - playerPosition.z,
                this.position.x - playerPosition.x
            );
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 0.6;

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            this.mesh.scale.setScalar(1 - progress);
            this.mesh.rotation.y += deltaTime * 15;
            this.mesh.position.y = 1.2 + progress * 2;
            this.light.intensity = (1 - progress) * 3;
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.3);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if (this.state !== 'ATTACK' || this.hasHitPlayer) return false;

        const dist = Vec3.distance(this.position, playerPosition);
        if (dist < (playerRadius + 0.6)) {
            this.hasHitPlayer = true;
            return true;
        }
        return false;
    }

    isVulnerable() {
        return this.state === 'RETREAT';
    }
}

// â”€â”€â”€ GRANDFATHER ENEMY CLASS (Heavy Tank) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Grandfather extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Grandfather';
        this.healthBarHeight = 4.5;

        // V2: Apply difficulty modifiers
        const baseDamage = 35;
        const baseSpeed = 3;
        const baseHealth = 150; // Mini-boss - ~6 hits on Normal
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 1000;

        // State timings - V2: telegraph affected by difficulty
        const baseSweepTel = 1.0;
        const baseSlamTel = 1.2;
        this.stateTimes = {
            SPAWN: 2.0,
            APPROACH: 0,
            SWEEP_TELEGRAPH: getDifficultyValue(baseSweepTel, 'telegraphTime'),
            SWEEP_ATTACK: 0.8,
            SLAM_TELEGRAPH: getDifficultyValue(baseSlamTel, 'telegraphTime'),
            SLAM_ATTACK: 0.6,
            RECOVER: 1.5
        };

        // Attack properties
        this.attackType = 'sweep';
        this.hasHitPlayer = false;
        this.armor = 50; // First 50 damage reduced

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d2817,
            roughness: 0.9,
            metalness: 0.1
        });

        const brassMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b7355,
            metalness: 0.8,
            roughness: 0.3
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });

        const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90b8,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.3,
            transparent: true,
            opacity: 0.6
        });

        // Main body (grandfather clock shape)
        const bodyGeometry = new THREE.BoxGeometry(1.5, 4, 0.8);
        const body = new THREE.Mesh(bodyGeometry, woodMaterial);
        body.position.y = 2;
        body.castShadow = true;
        this.mesh.add(body);
        this.body = body;

        // Clock face (top section)
        const faceGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.2, 24);
        const face = new THREE.Mesh(faceGeometry, glassMaterial);
        face.position.set(0, 3.5, 0.5);
        face.rotation.x = Math.PI / 2;
        this.mesh.add(face);
        this.face = face;

        // Clock face ring
        const ringGeometry = new THREE.TorusGeometry(0.6, 0.06, 8, 24);
        const ring = new THREE.Mesh(ringGeometry, goldMaterial);
        ring.position.set(0, 3.5, 0.55);
        this.mesh.add(ring);

        // Clock hands
        const hourHandGeometry = new THREE.BoxGeometry(0.06, 0.35, 0.03);
        const hourHand = new THREE.Mesh(hourHandGeometry, goldMaterial);
        hourHand.position.set(0, 3.67, 0.6);
        this.mesh.add(hourHand);
        this.hourHand = hourHand;

        const minuteHandGeometry = new THREE.BoxGeometry(0.04, 0.5, 0.03);
        const minuteHand = new THREE.Mesh(minuteHandGeometry, goldMaterial);
        minuteHand.position.set(0, 3.75, 0.6);
        this.mesh.add(minuteHand);
        this.minuteHand = minuteHand;

        // Pendulum cabinet (glass front)
        const cabinetGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.1);
        const cabinet = new THREE.Mesh(cabinetGeometry, glassMaterial);
        cabinet.position.set(0, 1.5, 0.45);
        this.mesh.add(cabinet);

        // Pendulum
        const pendulumGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1.2, 8);
        const pendulum = new THREE.Mesh(pendulumGeometry, brassMaterial);
        pendulum.position.set(0, 1.0, 0.3);
        this.mesh.add(pendulum);
        this.pendulum = pendulum;

        const pendulumDiscGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
        const pendulumDisc = new THREE.Mesh(pendulumDiscGeometry, goldMaterial);
        pendulumDisc.position.set(0, 0.4, 0.3);
        pendulumDisc.rotation.x = Math.PI / 2;
        this.mesh.add(pendulumDisc);
        this.pendulumDisc = pendulumDisc;

        // Legs
        const legGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
        const leftLeg = new THREE.Mesh(legGeometry, brassMaterial);
        leftLeg.position.set(-0.5, -0.5, 0);
        leftLeg.castShadow = true;
        this.mesh.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, brassMaterial);
        rightLeg.position.set(0.5, -0.5, 0);
        rightLeg.castShadow = true;
        this.mesh.add(rightLeg);

        // Arms (clock hands as weapons)
        const armGeometry = new THREE.BoxGeometry(0.15, 2, 0.08);
        const leftArm = new THREE.Mesh(armGeometry, goldMaterial);
        leftArm.position.set(-1.2, 2.5, 0);
        leftArm.rotation.z = 0.3;
        this.mesh.add(leftArm);
        this.leftArm = leftArm;

        const rightArm = new THREE.Mesh(armGeometry, goldMaterial);
        rightArm.position.set(1.2, 2.5, 0);
        rightArm.rotation.z = -0.3;
        this.mesh.add(rightArm);
        this.rightArm = rightArm;

        // Eye glow
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444,
            transparent: true,
            opacity: 0.8
        });
        const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.set(0, 3.5, 0.65);
        this.mesh.add(eye);
        this.eye = eye;

        // Point lights
        const faceLight = new THREE.PointLight(0xff4444, 0.5, 4);
        faceLight.position.set(0, 3.5, 0.8);
        this.mesh.add(faceLight);
        this.faceLight = faceLight;

        // Position mesh
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 0;
        this.scene.add(this.mesh);

        // Start at small scale
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate pendulum
        this.pendulum.rotation.z = Math.sin(this.stateTimer * 2) * 0.4;
        this.pendulumDisc.position.x = Math.sin(this.stateTimer * 2) * 0.2;

        // Animate clock hands
        this.hourHand.rotation.z = this.stateTimer * 0.1;
        this.minuteHand.rotation.z = this.stateTimer * 1.2;

        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'APPROACH':
                this.updateApproach(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'SWEEP_TELEGRAPH':
                this.updateSweepTelegraph(deltaTime, toPlayer);
                break;
            case 'SWEEP_ATTACK':
                this.updateSweepAttack(deltaTime);
                break;
            case 'SLAM_TELEGRAPH':
                this.updateSlamTelegraph(deltaTime);
                break;
            case 'SLAM_ATTACK':
                this.updateSlamAttack(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        this.mesh.scale.setScalar(Math.min(1, progress));

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
        }
    }

    updateApproach(deltaTime, toPlayer, distanceToPlayer) {
        if (distanceToPlayer > 6) {
            this.position.x += toPlayer.x * this.speed * deltaTime;
            this.position.z += toPlayer.z * this.speed * deltaTime;
        }

        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        if (distanceToPlayer <= 6) {
            // Choose attack type
            this.attackType = Math.random() > 0.5 ? 'sweep' : 'slam';
            this.state = this.attackType === 'sweep' ? 'SWEEP_TELEGRAPH' : 'SLAM_TELEGRAPH';
            this.stateTimer = 0;
            this.hasHitPlayer = false;
        }
    }

    updateSweepTelegraph(deltaTime, toPlayer) {
        const progress = this.stateTimer / this.stateTimes.SWEEP_TELEGRAPH;

        // Raise arm
        this.rightArm.rotation.z = -0.3 - progress * 1.5;
        this.rightArm.position.y = 2.5 + progress * 0.5;

        // Glow
        this.faceLight.intensity = 0.5 + progress * 1.5;

        if (this.stateTimer >= this.stateTimes.SWEEP_TELEGRAPH) {
            this.state = 'SWEEP_ATTACK';
            this.stateTimer = 0;
        }
    }

    updateSweepAttack(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SWEEP_ATTACK;

        // Sweep arm across
        this.rightArm.rotation.z = -1.8 + progress * 3.6;

        if (this.stateTimer >= this.stateTimes.SWEEP_ATTACK) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateSlamTelegraph(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SLAM_TELEGRAPH;

        // Raise both arms
        this.leftArm.rotation.z = 0.3 + progress * 2;
        this.rightArm.rotation.z = -0.3 - progress * 2;
        this.leftArm.position.y = 2.5 + progress;
        this.rightArm.position.y = 2.5 + progress;

        // Face glows red
        this.faceLight.intensity = 0.5 + progress * 2;

        if (this.stateTimer >= this.stateTimes.SLAM_TELEGRAPH) {
            this.state = 'SLAM_ATTACK';
            this.stateTimer = 0;
        }
    }

    updateSlamAttack(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SLAM_ATTACK;

        // Slam arms down
        this.leftArm.rotation.z = 2.3 - progress * 2;
        this.rightArm.rotation.z = -2.3 + progress * 2;
        this.leftArm.position.y = 3.5 - progress * 2;
        this.rightArm.position.y = 3.5 - progress * 2;

        if (this.stateTimer >= this.stateTimes.SLAM_ATTACK) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateRecover(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.RECOVER;

        // Return arms to normal
        this.leftArm.rotation.z = THREE.MathUtils.lerp(this.leftArm.rotation.z, 0.3, progress);
        this.rightArm.rotation.z = THREE.MathUtils.lerp(this.rightArm.rotation.z, -0.3, progress);
        this.leftArm.position.y = THREE.MathUtils.lerp(this.leftArm.position.y, 2.5, progress);
        this.rightArm.position.y = THREE.MathUtils.lerp(this.rightArm.position.y, 2.5, progress);

        this.faceLight.intensity = 0.5;

        if (this.stateTimer >= this.stateTimes.RECOVER) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 1.5;

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            // Stagger and fall
            this.mesh.rotation.x = progress * 0.5;
            this.mesh.position.y = -progress * 2;
            this.faceLight.intensity = (1 - progress) * 5;

            this.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 1 - progress;
                }
            });
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    takeDamage(amount, hitFrame) {
        if (hitFrame === this.lastHitFrame) return false;
        this.lastHitFrame = hitFrame;

        // Armor reduces damage
        if (this.armor > 0) {
            const absorbed = Math.min(this.armor, amount * 0.5);
            this.armor -= absorbed;
            amount -= absorbed;
        }

        this.health -= amount;
        this.isFlashing = true;
        this.flashTimer = 0.08;

        if (this.health <= 0) {
            this.die();
            return 'killed';
        }
        return true;
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.15);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if ((this.state !== 'SWEEP_ATTACK' && this.state !== 'SLAM_ATTACK') || this.hasHitPlayer) {
            return false;
        }

        const dist = Vec3.distance(this.position, playerPosition);
        const range = this.state === 'SLAM_ATTACK' ? 6 : 8;

        if (dist < range) {
            this.hasHitPlayer = true;
            return true;
        }
        return false;
    }

    isVulnerable() {
        return this.state === 'RECOVER';
    }
}

// â”€â”€â”€ PENDULUM ENEMY CLASS (Ranged Support) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Pendulum extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Pendulum';
        this.healthBarHeight = 3.0;

        // V2: Apply difficulty modifiers
        const baseDamage = 20;
        const baseSpeed = 5;
        const baseHealth = 40; // Same as basic enemies
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 300;

        // State timings - V2: telegraph affected by difficulty
        const baseTelegraph = 0.6;
        this.stateTimes = {
            SPAWN: 1.0,
            HOVER: 2.0,
            SHOOT_TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            SHOOT: 0.1,
            REPOSITION: 0.5
        };

        // Projectiles
        this.projectiles = [];

        // Preferred distance
        this.preferredDistance = 15;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x6688aa,
            transparent: true,
            opacity: 0.7,
            metalness: 0.3,
            roughness: 0.5
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.3,
            metalness: 0.9,
            roughness: 0.2
        });

        // Inverted pendulum shape
        const topGeometry = new THREE.ConeGeometry(0.5, 0.8, 6);
        const top = new THREE.Mesh(topGeometry, bodyMaterial);
        top.position.y = 0.4;
        top.rotation.x = Math.PI;
        this.mesh.add(top);
        this.top = top;

        // Clock face head
        const headGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.15, 16);
        const head = new THREE.Mesh(headGeometry, goldMaterial);
        head.position.y = 0.9;
        head.rotation.x = Math.PI / 2;
        this.mesh.add(head);
        this.head = head;

        // Eye
        const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0x44ff44
        });
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.y = 0.9;
        eye.position.z = 0.1;
        this.mesh.add(eye);
        this.eye = eye;

        // Pendulum rod and weight below
        const rodGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1, 8);
        const rod = new THREE.Mesh(rodGeometry, goldMaterial);
        rod.position.y = -0.5;
        this.mesh.add(rod);
        this.rod = rod;

        const weightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const weight = new THREE.Mesh(weightGeometry, goldMaterial);
        weight.position.y = -1;
        this.mesh.add(weight);
        this.weight = weight;

        // Point light
        const light = new THREE.PointLight(0x44ff44, 0.5, 4);
        light.position.y = 0.9;
        this.mesh.add(light);
        this.light = light;

        this.mesh.position.copy(this.position);
        this.mesh.position.y = 3;
        this.scene.add(this.mesh);

        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate pendulum swing
        const swingAngle = Math.sin(this.stateTimer * 3) * 0.5;
        this.rod.rotation.z = swingAngle;
        this.weight.position.x = Math.sin(swingAngle) * 0.5;
        this.weight.position.y = -1 + Math.cos(swingAngle) * 0.1;

        // Face player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const dist = toPlayer.length();
        toPlayer.normalize();

        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Update projectiles
        this.updateProjectiles(deltaTime);

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'HOVER':
                this.updateHover(deltaTime, toPlayer, dist, playerPosition);
                break;
            case 'SHOOT_TELEGRAPH':
                this.updateShootTelegraph(deltaTime, toPlayer);
                break;
            case 'SHOOT':
                this.updateShoot(deltaTime, playerPosition);
                break;
            case 'REPOSITION':
                this.updateReposition(deltaTime, playerPosition);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        this.mesh.scale.setScalar(Math.min(1, progress * 1.5));

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'HOVER';
            this.stateTimer = 0;
        }
    }

    updateHover(deltaTime, toPlayer, dist, playerPosition) {
        // Maintain preferred distance
        if (dist < this.preferredDistance - 2) {
            this.position.x -= toPlayer.x * this.speed * deltaTime;
            this.position.z -= toPlayer.z * this.speed * deltaTime;
        } else if (dist > this.preferredDistance + 2) {
            this.position.x += toPlayer.x * this.speed * deltaTime;
            this.position.z += toPlayer.z * this.speed * deltaTime;
        }

        // Bob up and down
        this.mesh.position.y = 3 + Math.sin(this.stateTimer * 2) * 0.3;

        if (this.stateTimer >= this.stateTimes.HOVER) {
            this.state = 'SHOOT_TELEGRAPH';
            this.stateTimer = 0;
        }
    }

    updateShootTelegraph(deltaTime, toPlayer) {
        const progress = this.stateTimer / this.stateTimes.SHOOT_TELEGRAPH;

        // Eye glows brighter
        this.light.intensity = 0.5 + progress * 2;

        // Pendulum freezes
        this.rod.rotation.z = 0;
        this.weight.position.x = 0;

        if (this.stateTimer >= this.stateTimes.SHOOT_TELEGRAPH) {
            this.state = 'SHOOT';
            this.stateTimer = 0;
        }
    }

    updateShoot(deltaTime, playerPosition) {
        // Fire projectile
        if (this.stateTimer === 0 || this.stateTimer < deltaTime * 2) {
            this.fireProjectile(playerPosition);
        }

        if (this.stateTimer >= this.stateTimes.SHOOT) {
            this.state = 'HOVER';
            this.stateTimer = 0;
            this.light.intensity = 0.5;
        }
    }

    updateReposition(deltaTime, playerPosition) {
        // Quick move to new position
        if (this.stateTimer >= this.stateTimes.REPOSITION) {
            this.state = 'HOVER';
            this.stateTimer = 0;
        }
    }

    fireProjectile(playerPosition) {
        const direction = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        ).normalize();

        // Create projectile mesh
        const projGeometry = new THREE.SphereGeometry(0.3, 8, 8);
        const projMaterial = new THREE.MeshBasicMaterial({
            color: 0xd4af37,
            transparent: true,
            opacity: 0.8
        });
        const projMesh = new THREE.Mesh(projGeometry, projMaterial);
        projMesh.position.set(this.position.x, 2, this.position.z);

        const projLight = new THREE.PointLight(0xd4af37, 0.5, 3);
        projMesh.add(projLight);

        this.scene.add(projMesh);

        this.projectiles.push({
            mesh: projMesh,
            direction: direction,
            speed: 20,
            lifetime: 3
        });
    }

    updateProjectiles(deltaTime) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.lifetime -= deltaTime;

            proj.mesh.position.x += proj.direction.x * proj.speed * deltaTime;
            proj.mesh.position.z += proj.direction.z * proj.speed * deltaTime;

            if (proj.lifetime <= 0) {
                this.scene.remove(proj.mesh);
                this.projectiles.splice(i, 1);
            }
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 0.8;

        // Hide health bar on death
        this.hideHealthBar();

        // Clean up projectiles
        for (const proj of this.projectiles) {
            this.scene.remove(proj.mesh);
        }
        this.projectiles = [];

        if (progress < 1) {
            this.mesh.scale.setScalar(1 - progress);
            this.mesh.rotation.y += deltaTime * 10;
            this.mesh.position.y = 3 - progress * 3;
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.3);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        // Check projectiles - V3: Use XZ distance only (ignore Y height difference)
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            // Calculate 2D distance on XZ plane (projectiles fly at different height)
            const dx = proj.mesh.position.x - playerPosition.x;
            const dz = proj.mesh.position.z - playerPosition.z;
            const distXZ = Math.sqrt(dx * dx + dz * dz);

            if (distXZ < playerRadius + 0.5) { // Increased hitbox for better detection
                this.scene.remove(proj.mesh);
                this.projectiles.splice(i, 1);
                return true;
            }
        }
        return false;
    }

    isVulnerable() {
        return true; // V3 fix: Ranged enemies ARE vulnerable (false was wrong)
    }

    destroy() {
        for (const proj of this.projectiles) {
            this.scene.remove(proj.mesh);
        }
        this.projectiles = [];
        super.destroy();
    }
}

// â”€â”€â”€ SECOND HAND CLASS (Elite Assassin) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class SecondHand extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Second Hand';
        this.healthBarHeight = 2.5;

        // V2: Apply difficulty modifiers
        const baseDamage = 15;
        const baseSpeed = 8;
        const baseHealth = 60; // Elite enemy - slightly tougher than basics
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.comboDamage = [15, 15, 25].map(d => getDifficultyValue(d, 'enemyDamage')); // 3-hit combo
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 500;

        // State timings - V2: telegraph affected by difficulty
        const baseTelegraph = 0.3;
        this.stateTimes = {
            SPAWN: 1.2,
            STALK: 0, // indefinite until close
            FREEZE: 0, // indefinite while looked at
            TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            ATTACK_1: 0.15,
            ATTACK_2: 0.15,
            ATTACK_3: 0.25,
            RECOVER: 0.8
        };

        // Combo state
        this.comboStep = 0;
        this.hasHitPlayer = false;

        // Stalking behavior
        this.stalkDistance = 4; // Attack when this close
        this.isBeingWatched = false;
        this.freezeGlitchTimer = 0;

        // Rewind ability (at 30% HP)
        this.hasUsedRewind = false;
        this.positionHistory = [];
        this.historyInterval = 0.1;
        this.historyTimer = 0;
        this.historyDuration = 3; // seconds of history to keep
        this.isRewinding = false;
        this.rewindTimer = 0;
        this.rewindDuration = 0.5;
        this.rewindTarget = null;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials - dark with clock hand aesthetics
        const handMaterial = new THREE.MeshStandardMaterial({
            color: 0x222233,
            metalness: 0.8,
            roughness: 0.3
        });

        const glowMaterial = new THREE.MeshStandardMaterial({
            color: 0x8844aa,
            emissive: 0x8844aa,
            emissiveIntensity: 0.5,
            metalness: 0.5,
            roughness: 0.4
        });

        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444
        });

        // Body made of overlapping clock hands
        // Central torso - vertical hand
        const torsoGeometry = new THREE.BoxGeometry(0.15, 1.8, 0.08);
        const torso = new THREE.Mesh(torsoGeometry, handMaterial);
        torso.position.y = 1.1;
        this.mesh.add(torso);

        // Overlapping diagonal hands for body texture
        for (let i = 0; i < 4; i++) {
            const diagGeometry = new THREE.BoxGeometry(0.1, 1.2, 0.05);
            const diag = new THREE.Mesh(diagGeometry, handMaterial);
            diag.position.y = 1.0;
            diag.rotation.z = (i - 1.5) * 0.3;
            diag.position.x = (i - 1.5) * 0.08;
            this.mesh.add(diag);
        }

        // Head - pointed like hour hand tip
        const headGeometry = new THREE.ConeGeometry(0.2, 0.5, 4);
        const head = new THREE.Mesh(headGeometry, handMaterial);
        head.position.y = 2.2;
        this.mesh.add(head);
        this.head = head;

        // Single red eye
        const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.y = 2.0;
        eye.position.z = 0.15;
        this.mesh.add(eye);
        this.eye = eye;

        // Arms - long clock hands
        const armGeometry = new THREE.BoxGeometry(0.8, 0.08, 0.04);
        const leftArm = new THREE.Mesh(armGeometry, handMaterial);
        leftArm.position.set(-0.5, 1.5, 0);
        leftArm.rotation.z = 0.3;
        this.mesh.add(leftArm);
        this.leftArm = leftArm;

        const rightArm = new THREE.Mesh(armGeometry, handMaterial);
        rightArm.position.set(0.5, 1.5, 0);
        rightArm.rotation.z = -0.3;
        this.mesh.add(rightArm);
        this.rightArm = rightArm;

        // Clawed fingers (multiple thin hands at arm ends)
        for (let side = -1; side <= 1; side += 2) {
            for (let i = 0; i < 3; i++) {
                const clawGeometry = new THREE.BoxGeometry(0.25, 0.03, 0.02);
                const claw = new THREE.Mesh(clawGeometry, glowMaterial);
                claw.position.set(side * 0.9, 1.5 + (i - 1) * 0.06, 0);
                claw.rotation.z = side * 0.5;
                this.mesh.add(claw);
            }
        }

        // Legs - thin hand shapes
        const legGeometry = new THREE.BoxGeometry(0.08, 1.0, 0.05);
        const leftLeg = new THREE.Mesh(legGeometry, handMaterial);
        leftLeg.position.set(-0.15, 0.5, 0);
        this.mesh.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, handMaterial);
        rightLeg.position.set(0.15, 0.5, 0);
        this.mesh.add(rightLeg);

        // Subtle glow
        const light = new THREE.PointLight(0x8844aa, 0.3, 3);
        light.position.y = 1.5;
        this.mesh.add(light);
        this.light = light;

        this.mesh.position.copy(this.position);
        this.scene.add(this.mesh);

        // Start small (spawn animation)
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition, playerRotation = 0) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        // Handle rewind animation
        if (this.isRewinding) {
            this.updateRewind(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Record position history for rewind
        this.historyTimer += deltaTime;
        if (this.historyTimer >= this.historyInterval) {
            this.historyTimer = 0;
            this.positionHistory.push({
                x: this.position.x,
                z: this.position.z,
                health: this.health
            });
            // Keep only last 3 seconds
            const maxHistory = Math.ceil(this.historyDuration / this.historyInterval);
            while (this.positionHistory.length > maxHistory) {
                this.positionHistory.shift();
            }
        }

        // Check if being watched (player facing this enemy)
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        // Calculate if player is looking at us
        const playerForward = new THREE.Vector3(
            Math.sin(playerRotation),
            0,
            Math.cos(playerRotation)
        );
        const toEnemy = new THREE.Vector3(-toPlayer.x, 0, -toPlayer.z);
        const dot = playerForward.dot(toEnemy);
        this.isBeingWatched = dot > 0.7 && distanceToPlayer < 20; // Within ~45 degree cone

        // Face player (always)
        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'STALK':
                this.updateStalk(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'FREEZE':
                this.updateFreeze(deltaTime, distanceToPlayer);
                break;
            case 'TELEGRAPH':
                this.updateTelegraph(deltaTime);
                break;
            case 'ATTACK_1':
            case 'ATTACK_2':
            case 'ATTACK_3':
                this.updateAttack(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.y = 0;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;

        // Glitchy spawn - flicker in
        const flicker = Math.sin(this.stateTimer * 30) > 0 ? 1 : 0.3;
        const scale = Math.min(1, progress * 1.5) * flicker;
        this.mesh.scale.setScalar(scale);

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.mesh.scale.setScalar(1);
            this.state = 'STALK';
            this.stateTimer = 0;
        }
    }

    updateStalk(deltaTime, toPlayer, distanceToPlayer) {
        // Check if player is watching
        if (this.isBeingWatched) {
            this.state = 'FREEZE';
            this.stateTimer = 0;
            return;
        }

        // Move silently towards player
        this.position.x += toPlayer.x * this.speed * deltaTime;
        this.position.z += toPlayer.z * this.speed * deltaTime;

        // Subtle gliding animation
        this.mesh.position.y = Math.sin(this.stateTimer * 5) * 0.05;

        // Attack when close enough
        if (distanceToPlayer <= this.stalkDistance) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
            this.comboStep = 0;
            this.hasHitPlayer = false;
        }
    }

    updateFreeze(deltaTime, distanceToPlayer) {
        // Glitch effect while frozen
        this.freezeGlitchTimer += deltaTime;
        if (this.freezeGlitchTimer > 0.1) {
            this.freezeGlitchTimer = 0;
            // Random small position jitter
            this.mesh.position.x = this.position.x + (Math.random() - 0.5) * 0.05;
            this.mesh.position.z = this.position.z + (Math.random() - 0.5) * 0.05;
        }

        // If player looks away, resume stalking
        if (!this.isBeingWatched) {
            this.state = 'STALK';
            this.stateTimer = 0;
        }

        // If player gets too close while we're frozen, attack anyway
        if (distanceToPlayer <= this.stalkDistance * 0.5) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
            this.comboStep = 0;
        }
    }

    updateTelegraph(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.TELEGRAPH;

        // Quick raise of arms
        this.leftArm.rotation.z = 0.3 + progress * 1.2;
        this.rightArm.rotation.z = -0.3 - progress * 1.2;

        // Eye glows brighter
        this.light.intensity = 0.3 + progress * 0.7;

        if (this.stateTimer >= this.stateTimes.TELEGRAPH) {
            this.state = 'ATTACK_1';
            this.stateTimer = 0;
            this.comboStep = 1;
            this.hasHitPlayer = false;
        }
    }

    updateAttack(deltaTime) {
        const attackTime = this.stateTimes[this.state];
        const progress = this.stateTimer / attackTime;

        // Animate based on combo step
        if (this.comboStep === 1 || this.comboStep === 2) {
            // Quick slash (alternate sides)
            const side = this.comboStep === 1 ? 1 : -1;
            this.leftArm.rotation.z = side > 0 ? 1.5 - progress * 2 : 0.3;
            this.rightArm.rotation.z = side < 0 ? -1.5 + progress * 2 : -0.3;
        } else if (this.comboStep === 3) {
            // Double overhead slam
            this.leftArm.rotation.z = 1.5 - progress * 3;
            this.rightArm.rotation.z = -1.5 + progress * 3;
        }

        if (this.stateTimer >= attackTime) {
            this.comboStep++;
            this.stateTimer = 0;
            this.hasHitPlayer = false;

            if (this.comboStep === 2) {
                this.state = 'ATTACK_2';
            } else if (this.comboStep === 3) {
                this.state = 'ATTACK_3';
            } else {
                this.state = 'RECOVER';
                this.comboStep = 0;
            }
        }
    }

    updateRecover(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.RECOVER;

        // Arms return to neutral
        this.leftArm.rotation.z = 0.3;
        this.rightArm.rotation.z = -0.3;
        this.light.intensity = 0.3;

        if (this.stateTimer >= this.stateTimes.RECOVER) {
            this.state = 'STALK';
            this.stateTimer = 0;
        }
    }

    updateRewind(deltaTime) {
        this.rewindTimer += deltaTime;
        const progress = this.rewindTimer / this.rewindDuration;

        if (progress >= 1 && this.rewindTarget) {
            // Complete rewind
            this.position.x = this.rewindTarget.x;
            this.position.z = this.rewindTarget.z;
            this.health = Math.min(this.maxHealth, this.rewindTarget.health + this.maxHealth * 0.3);
            this.mesh.position.x = this.position.x;
            this.mesh.position.z = this.position.z;
            this.mesh.scale.setScalar(1);
            this.isRewinding = false;
            this.state = 'STALK';
            this.stateTimer = 0;
            this.light.color.setHex(0x8844aa);
        } else {
            // Glitchy rewind animation
            const glitch = Math.sin(progress * 50) > 0 ? 1 : 0.5;
            this.mesh.scale.setScalar(glitch);

            // Interpolate position backwards
            if (this.rewindTarget) {
                this.mesh.position.x = this.position.x + (this.rewindTarget.x - this.position.x) * progress;
                this.mesh.position.z = this.position.z + (this.rewindTarget.z - this.position.z) * progress;
            }

            // Purple glow during rewind
            this.light.color.setHex(0xff44ff);
            this.light.intensity = 1 + Math.sin(progress * 20) * 0.5;
        }
    }

    takeDamage(damage, hitFrame) {
        if (this.lastHitFrame === hitFrame) return false;
        this.lastHitFrame = hitFrame;

        this.health -= damage;
        this.flashTimer = 0.1;
        this.applyFlash();

        // Check for rewind trigger (at 30% HP, once only)
        if (!this.hasUsedRewind && this.health <= this.maxHealth * 0.3 && this.health > 0) {
            this.triggerRewind();
            return true; // Still counts as a hit
        }

        if (this.health <= 0) {
            this.die();
            return 'killed';
        }

        return true;
    }

    triggerRewind() {
        this.hasUsedRewind = true;
        this.isRewinding = true;
        this.rewindTimer = 0;

        // Get position from 3 seconds ago (or earliest if less history)
        if (this.positionHistory.length > 0) {
            this.rewindTarget = this.positionHistory[0];
        } else {
            // No history, just heal in place
            this.rewindTarget = {
                x: this.position.x,
                z: this.position.z,
                health: this.health
            };
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 1.0;

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            // Glitchy disintegration
            const glitch = Math.random() > 0.3 ? 1 : 0;
            this.mesh.scale.setScalar((1 - progress) * glitch);
            this.mesh.rotation.y += deltaTime * 15;
            this.mesh.position.y = progress * -0.5;

            // Flicker light
            this.light.intensity = (1 - progress) * (Math.random() > 0.5 ? 1 : 0);
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.2);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        // Only hit during attack states
        if (!this.state.startsWith('ATTACK_')) return false;
        if (this.hasHitPlayer) return false;

        const dist = Vec3.distance(this.position, playerPosition);
        if (dist < 2.0) { // Attack range
            this.hasHitPlayer = true;
            this.damage = this.comboDamage[this.comboStep - 1] || 15;
            return true;
        }

        return false;
    }

    isVulnerable() {
        return this.state === 'RECOVER' || this.isRewinding;
    }
}

// â”€â”€â”€ MINUTE MITE CLASS (Splitter Enemy) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class MinuteMite extends Enemy {
    constructor(scene, position, size = 1.0, game = null) {
        super(scene, position);
        this.game = game;
        this.size = size; // 1.0 = full, 0.5 = half (after split)

        // Enemy name for health bar
        this.enemyName = size >= 1.0 ? 'Minute Mite' : 'Mite Fragment';
        this.healthBarHeight = 1.2 * size;

        // V2: Apply difficulty modifiers - scales with size
        const baseDamage = Math.floor(10 * size);
        const baseSpeed = 6 + (1 - size) * 4; // Smaller = faster
        const baseHealth = Math.floor(30 * size); // Smaller = less HP
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = Math.floor(150 * size);

        // Can only split if full size
        this.canSplit = size >= 1.0;

        // State timings
        const baseTelegraph = 0.4;
        this.stateTimes = {
            SPAWN: 0.6 * size,
            APPROACH: 0,
            TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            ATTACK: 0.25,
            RECOVER: 0.5
        };

        // Attack properties
        this.attackRange = 2.5;
        this.hasHitPlayer = false;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials - crystalline time shard look
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x88aacc,
            emissive: 0x4488aa,
            emissiveIntensity: 0.3,
            metalness: 0.6,
            roughness: 0.3,
            transparent: true,
            opacity: 0.85
        });

        const coreMaterial = new THREE.MeshStandardMaterial({
            color: 0xffdd44,
            emissive: 0xffaa00,
            emissiveIntensity: 0.8,
            metalness: 0.2,
            roughness: 0.2
        });

        // Main body - icosahedron (gem-like)
        const bodyGeometry = new THREE.IcosahedronGeometry(0.4 * this.size, 0);
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        this.mesh.add(body);
        this.bodyMesh = body;

        // Inner core (glowing)
        const coreGeometry = new THREE.IcosahedronGeometry(0.2 * this.size, 0);
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        this.mesh.add(core);
        this.core = core;

        // Orbiting time fragments
        this.fragments = [];
        const fragmentCount = this.canSplit ? 3 : 1;
        const fragmentGeometry = new THREE.TetrahedronGeometry(0.1 * this.size, 0);
        for (let i = 0; i < fragmentCount; i++) {
            const fragment = new THREE.Mesh(fragmentGeometry, coreMaterial.clone());
            fragment.userData.orbitAngle = (i / fragmentCount) * Math.PI * 2;
            fragment.userData.orbitSpeed = 2 + Math.random();
            fragment.userData.orbitRadius = 0.5 * this.size;
            this.mesh.add(fragment);
            this.fragments.push(fragment);
        }

        // Point light
        const light = new THREE.PointLight(0x88ccff, 0.4 * this.size, 3);
        this.mesh.add(light);
        this.light = light;

        // Position mesh
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 0.5 * this.size;
        this.scene.add(this.mesh);

        // Start small for spawn
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate core rotation
        this.core.rotation.x += deltaTime * 2;
        this.core.rotation.y += deltaTime * 3;

        // Animate orbiting fragments
        for (const fragment of this.fragments) {
            fragment.userData.orbitAngle += fragment.userData.orbitSpeed * deltaTime;
            const angle = fragment.userData.orbitAngle;
            const radius = fragment.userData.orbitRadius;
            fragment.position.x = Math.cos(angle) * radius;
            fragment.position.z = Math.sin(angle) * radius;
            fragment.position.y = Math.sin(angle * 2) * 0.1;
            fragment.rotation.x += deltaTime * 5;
            fragment.rotation.y += deltaTime * 3;
        }

        // Direction to player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'APPROACH':
                this.updateApproach(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'TELEGRAPH':
                this.updateTelegraph(deltaTime, toPlayer);
                break;
            case 'ATTACK':
                this.updateAttack(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        const scale = Math.min(1, progress * 1.5);
        this.mesh.scale.set(scale, scale, scale);

        // Spin during spawn
        this.mesh.rotation.y += deltaTime * 10;

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
            this.mesh.scale.set(1, 1, 1);
        }
    }

    updateApproach(deltaTime, toPlayer, distanceToPlayer) {
        // Move toward player
        this.position.x += toPlayer.x * this.speed * deltaTime;
        this.position.z += toPlayer.z * this.speed * deltaTime;

        // Hover bobbing
        this.mesh.position.y = 0.5 * this.size + Math.sin(this.stateTimer * 4) * 0.1;

        // Face player
        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Attack when close
        if (distanceToPlayer <= this.attackRange) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
            this.hasHitPlayer = false;
        }
    }

    updateTelegraph(deltaTime, toPlayer) {
        const progress = this.stateTimer / this.stateTimes.TELEGRAPH;

        // Pulse and glow brighter
        const pulse = 1 + Math.sin(progress * Math.PI * 4) * 0.2;
        this.mesh.scale.set(pulse, pulse, pulse);
        this.light.intensity = 0.4 * this.size + progress * 0.6;

        // Store attack direction
        this.attackDirection = toPlayer.clone();

        if (this.stateTimer >= this.stateTimes.TELEGRAPH) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
        }
    }

    updateAttack(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.ATTACK;

        // Lunge forward
        const lungeSpeed = 15 * this.size;
        this.position.x += this.attackDirection.x * lungeSpeed * deltaTime;
        this.position.z += this.attackDirection.z * lungeSpeed * deltaTime;

        // Spin during attack
        this.mesh.rotation.y += deltaTime * 20;

        if (this.stateTimer >= this.stateTimes.ATTACK) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateRecover(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.RECOVER;

        // Slow down rotation
        this.mesh.rotation.y += deltaTime * (10 - progress * 8);
        this.light.intensity = THREE.MathUtils.lerp(1.0, 0.4, progress) * this.size;

        if (this.stateTimer >= this.stateTimes.RECOVER) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
        }
    }

    die() {
        // Override die to spawn smaller mites if we can split
        if (this.canSplit && this.game) {
            // Spawn 2 smaller mites
            for (let i = 0; i < 2; i++) {
                const angle = (i / 2) * Math.PI * 2 + Math.random() * 0.5;
                const offset = 1.0;
                const spawnPos = new THREE.Vector3(
                    this.position.x + Math.cos(angle) * offset,
                    0,
                    this.position.z + Math.sin(angle) * offset
                );
                // Create smaller mite (half size)
                const smallMite = new MinuteMite(this.scene, spawnPos, 0.5, this.game);
                this.game.enemies.push(smallMite);
            }
        }

        // Normal death
        this.isAlive = false;
        this.isDying = true;
        this.deathTimer = 0;
        this.state = 'DEAD';
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 0.5;

        // Hide health bar
        this.hideHealthBar();

        if (progress < 1) {
            // Shatter effect
            this.mesh.scale.setScalar((1 - progress) * 1.5);
            this.mesh.rotation.y += deltaTime * 20;
            this.mesh.rotation.x += deltaTime * 15;

            // Fragments fly outward
            for (const fragment of this.fragments) {
                fragment.userData.orbitRadius += deltaTime * 5;
            }

            this.light.intensity = (1 - progress) * 2;
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.bodyMesh) {
            this.bodyMesh.material.emissiveIntensity = 1.0;
        }
    }

    restoreMaterials() {
        if (this.bodyMesh) {
            this.bodyMesh.material.emissiveIntensity = 0.3;
        }
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if (this.state !== 'ATTACK' || this.hasHitPlayer) return false;

        const dist = Math.sqrt(
            Math.pow(this.position.x - playerPosition.x, 2) +
            Math.pow(this.position.z - playerPosition.z, 2)
        );

        if (dist < (playerRadius + 0.5 * this.size)) {
            this.hasHitPlayer = true;
            return true;
        }
        return false;
    }

    resetAttackHit() {
        this.hasHitPlayer = false;
    }

    isVulnerable() {
        return this.state === 'RECOVER';
    }
}

// â”€â”€â”€ CHRONOPHAGE PRIME CLASS (Final Boss) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ChronophagePrime extends Enemy {
    constructor(scene, position, game) {
        super(scene, position);
        this.game = game; // Reference to game for spawning minions

        // Enemy name for health bar
        this.enemyName = 'Chronophage Prime';
        this.healthBarHeight = 6.0;

        // V2: Apply difficulty modifiers
        const baseDamage = 30;
        const baseSpeed = 4;
        const baseHealth = 400; // Final boss - ~16 hits on Normal
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 10000;

        // Boss phases
        this.phase = 1; // 1, 2, or 3
        this.phaseThresholds = [0.66, 0.33]; // Phase transitions at 66% and 33% HP

        // State timings - V2: telegraph affected by difficulty
        const baseSweepTel = 1.0;
        const basePoundTel = 1.2;
        const baseSummonTel = 1.5;
        this.stateTimes = {
            SPAWN: 3.0,
            IDLE: 1.5,
            APPROACH: 0, // Continuous
            SWEEP_TELEGRAPH: getDifficultyValue(baseSweepTel, 'telegraphTime'),
            SWEEP: 0.8,
            POUND_TELEGRAPH: getDifficultyValue(basePoundTel, 'telegraphTime'),
            POUND: 0.5,
            SUMMON_TELEGRAPH: getDifficultyValue(baseSummonTel, 'telegraphTime'),
            SUMMON: 0.5,
            // V3: New attack timings
            BARRAGE_TELEGRAPH: getDifficultyValue(0.8, 'telegraphTime'),
            BARRAGE: 2.0, // Fires multiple projectiles over time
            SWARM_TELEGRAPH: getDifficultyValue(1.0, 'telegraphTime'),
            SWARM: 0.8, // Larger summon
            REWIND: 1.5, // Time rewind heal effect
            RECOVER: 1.5,
            TRANSITION: 2.0, // Phase transition
            RAGE: 0 // Final phase continuous
        };

        // Attack tracking
        this.attackPattern = ['SWEEP', 'POUND', 'SWEEP', 'SUMMON'];
        this.phase2Pattern = ['SWEEP', 'BARRAGE', 'POUND', 'SWEEP', 'SUMMON', 'BARRAGE'];
        this.phase3Pattern = ['SWEEP', 'BARRAGE', 'SWEEP', 'POUND', 'SWARM', 'BARRAGE'];
        this.currentAttackIndex = 0;
        this.hasHitPlayer = false;

        // V3: Temporal Barrage projectiles
        this.barrageProjectiles = [];
        this.barrageFired = 0;

        // Summon tracking
        this.summonedTicks = [];
        this.maxSummons = 4;

        // V3: Time Rewind (Phase 3 heal)
        this.hasRewindHealed = false;

        // Time distortion zones (Phase 2+)
        this.distortionZones = [];

        // Rage mode (Phase 3)
        this.rageTimer = 0;
        this.ragePulse = 0;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            metalness: 0.7,
            roughness: 0.3
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.3,
            metalness: 0.9,
            roughness: 0.2
        });

        const clockMaterial = new THREE.MeshStandardMaterial({
            color: 0xeeeedd,
            metalness: 0.2,
            roughness: 0.5
        });

        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444,
            transparent: true,
            opacity: 0.8
        });

        // Massive central clock body
        const bodyGeometry = new THREE.CylinderGeometry(2, 2.5, 1.5, 32);
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 2.5;
        body.rotation.x = Math.PI / 2;
        this.mesh.add(body);
        this.body = body;

        // Clock face (front)
        const faceGeometry = new THREE.CircleGeometry(1.8, 32);
        const face = new THREE.Mesh(faceGeometry, clockMaterial);
        face.position.set(0, 2.5, 1.3);
        this.mesh.add(face);
        this.face = face;

        // Clock rim
        const rimGeometry = new THREE.TorusGeometry(1.9, 0.15, 16, 64);
        const rim = new THREE.Mesh(rimGeometry, goldMaterial);
        rim.position.set(0, 2.5, 1.3);
        this.mesh.add(rim);

        // Clock hands (animated)
        const hourHandGeom = new THREE.BoxGeometry(0.15, 0.8, 0.05);
        const hourHand = new THREE.Mesh(hourHandGeom, bodyMaterial);
        hourHand.position.set(0, 2.9, 1.35);
        this.mesh.add(hourHand);
        this.hourHand = hourHand;

        const minuteHandGeom = new THREE.BoxGeometry(0.1, 1.2, 0.05);
        const minuteHand = new THREE.Mesh(minuteHandGeom, bodyMaterial);
        minuteHand.position.set(0, 2.9, 1.4);
        this.mesh.add(minuteHand);
        this.minuteHand = minuteHand;

        // Central eye
        const eyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const eye = new THREE.Mesh(eyeGeometry, glowMaterial);
        eye.position.set(0, 2.5, 1.5);
        this.mesh.add(eye);
        this.eye = eye;

        // Massive arms (sweeping appendages)
        const armGeometry = new THREE.BoxGeometry(3, 0.3, 0.2);

        const leftArm = new THREE.Mesh(armGeometry, goldMaterial);
        leftArm.position.set(-2.5, 2.5, 0);
        this.mesh.add(leftArm);
        this.leftArm = leftArm;

        const rightArm = new THREE.Mesh(armGeometry, goldMaterial);
        rightArm.position.set(2.5, 2.5, 0);
        this.mesh.add(rightArm);
        this.rightArm = rightArm;

        // Clawed hands at arm ends
        for (let side = -1; side <= 1; side += 2) {
            for (let i = 0; i < 3; i++) {
                const clawGeom = new THREE.ConeGeometry(0.15, 0.6, 4);
                const claw = new THREE.Mesh(clawGeom, goldMaterial);
                claw.position.set(side * 4.2, 2.5 + (i - 1) * 0.3, 0);
                claw.rotation.z = side * Math.PI / 2;
                this.mesh.add(claw);
            }
        }

        // Lower body / base (floating gears)
        const baseGeometry = new THREE.TorusGeometry(1.5, 0.3, 8, 32);
        const base = new THREE.Mesh(baseGeometry, goldMaterial);
        base.position.y = 0.8;
        base.rotation.x = Math.PI / 2;
        this.mesh.add(base);

        // Floating gear rings
        for (let i = 0; i < 3; i++) {
            const gearGeom = new THREE.TorusGeometry(0.8 + i * 0.4, 0.08, 8, 16);
            const gear = new THREE.Mesh(gearGeom, bodyMaterial);
            gear.position.y = 0.3 - i * 0.2;
            gear.rotation.x = Math.PI / 2;
            gear.userData.rotSpeed = (i % 2 === 0 ? 1 : -1) * (0.5 + i * 0.2);
            this.mesh.add(gear);
        }

        // Boss glow
        const bossLight = new THREE.PointLight(0xff4444, 1, 15);
        bossLight.position.y = 2.5;
        this.mesh.add(bossLight);
        this.bossLight = bossLight;

        // Secondary lights
        const goldLight1 = new THREE.PointLight(0xd4af37, 0.8, 8);
        goldLight1.position.set(-3, 2.5, 0);
        this.mesh.add(goldLight1);

        const goldLight2 = new THREE.PointLight(0xd4af37, 0.8, 8);
        goldLight2.position.set(3, 2.5, 0);
        this.mesh.add(goldLight2);

        this.mesh.position.copy(this.position);
        this.scene.add(this.mesh);

        // Start with scale 0 for spawn animation
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate clock hands
        this.hourHand.rotation.z = -this.stateTimer * 0.1;
        this.minuteHand.rotation.z = -this.stateTimer * 0.5;

        // Animate floating gears
        this.mesh.children.forEach(child => {
            if (child.userData.rotSpeed) {
                child.rotation.z += child.userData.rotSpeed * deltaTime;
            }
        });

        // Face player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Phase checks
        this.checkPhaseTransition();

        // Update distortion zones
        this.updateDistortionZones(deltaTime);

        // State machine
        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'IDLE':
                this.updateIdle(deltaTime, distanceToPlayer);
                break;
            case 'APPROACH':
                this.updateApproach(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'SWEEP_TELEGRAPH':
                this.updateSweepTelegraph(deltaTime);
                break;
            case 'SWEEP':
                this.updateSweep(deltaTime);
                break;
            case 'POUND_TELEGRAPH':
                this.updatePoundTelegraph(deltaTime);
                break;
            case 'POUND':
                this.updatePound(deltaTime, playerPosition);
                break;
            case 'SUMMON_TELEGRAPH':
                this.updateSummonTelegraph(deltaTime);
                break;
            case 'SUMMON':
                this.updateSummon(deltaTime);
                break;
            // V3: New attacks
            case 'BARRAGE_TELEGRAPH':
                this.updateBarrageTelegraph(deltaTime);
                break;
            case 'BARRAGE':
                this.updateBarrage(deltaTime, playerPosition);
                break;
            case 'SWARM_TELEGRAPH':
                this.updateSwarmTelegraph(deltaTime);
                break;
            case 'SWARM':
                this.updateSwarm(deltaTime);
                break;
            case 'REWIND':
                this.updateRewind(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
            case 'TRANSITION':
                this.updateTransition(deltaTime);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Hover animation
        this.mesh.position.y = Math.sin(this.stateTimer * 2) * 0.2;

        // Update health bar position
        this.updateHealthBar();
    }

    checkPhaseTransition() {
        const healthPercent = this.health / this.maxHealth;

        if (this.phase === 1 && healthPercent <= this.phaseThresholds[0]) {
            this.startPhaseTransition(2);
        } else if (this.phase === 2 && healthPercent <= this.phaseThresholds[1]) {
            this.startPhaseTransition(3);
        }
    }

    startPhaseTransition(newPhase) {
        this.phase = newPhase;
        this.stateTimer = 0;

        // V3: Time Rewind - heal 15% on Phase 3 transition
        if (newPhase === 3 && !this.hasRewindHealed) {
            this.hasRewindHealed = true;
            this.state = 'REWIND';
            // Will heal during REWIND state
        } else {
            this.state = 'TRANSITION';
        }

        // Visual feedback
        this.bossLight.color.setHex(newPhase === 2 ? 0xff8844 : 0xff0000);
        this.bossLight.intensity = 2;

        // Spawn distortion zones in Phase 2+
        if (newPhase >= 2) {
            this.createDistortionZone();
        }
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        this.mesh.scale.setScalar(Math.min(1, progress));

        // Dramatic spawn effect
        this.bossLight.intensity = 1 + Math.sin(this.stateTimer * 10) * 0.5;

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.mesh.scale.setScalar(1);
            this.state = 'IDLE';
            this.stateTimer = 0;
        }
    }

    updateIdle(deltaTime, distanceToPlayer) {
        // Speed up in later phases
        const idleTime = this.stateTimes.IDLE / this.phase;

        if (this.stateTimer >= idleTime) {
            if (distanceToPlayer > 8) {
                this.state = 'APPROACH';
            } else {
                this.startNextAttack();
            }
            this.stateTimer = 0;
        }
    }

    updateApproach(deltaTime, toPlayer, distanceToPlayer) {
        const speed = this.speed * (this.phase === 3 ? 1.5 : 1);
        this.position.x += toPlayer.x * speed * deltaTime;
        this.position.z += toPlayer.z * speed * deltaTime;

        if (distanceToPlayer <= 8) {
            this.startNextAttack();
            this.stateTimer = 0;
        }
    }

    startNextAttack() {
        // V3: Phase-specific attack patterns
        let pattern;
        if (this.phase === 3) {
            pattern = this.phase3Pattern;
        } else if (this.phase === 2) {
            pattern = this.phase2Pattern;
        } else {
            pattern = this.attackPattern;
        }

        const attack = pattern[this.currentAttackIndex % pattern.length];
        this.currentAttackIndex++;

        this.state = attack + '_TELEGRAPH';
        this.stateTimer = 0;
        this.hasHitPlayer = false;
        this.barrageFired = 0; // Reset barrage counter
    }

    updateSweepTelegraph(deltaTime) {
        const progress = this.stateTimer / (this.stateTimes.SWEEP_TELEGRAPH / this.phase);

        // Raise arms
        this.leftArm.rotation.z = progress * 0.5;
        this.rightArm.rotation.z = -progress * 0.5;

        // Glow warning
        this.bossLight.intensity = 1 + progress;

        if (this.stateTimer >= this.stateTimes.SWEEP_TELEGRAPH / this.phase) {
            this.state = 'SWEEP';
            this.stateTimer = 0;
        }
    }

    updateSweep(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SWEEP;

        // Sweep arms down
        this.leftArm.rotation.z = 0.5 - progress * 1.5;
        this.rightArm.rotation.z = -0.5 + progress * 1.5;

        if (this.stateTimer >= this.stateTimes.SWEEP) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
            this.leftArm.rotation.z = 0;
            this.rightArm.rotation.z = 0;
        }
    }

    updatePoundTelegraph(deltaTime) {
        const progress = this.stateTimer / (this.stateTimes.POUND_TELEGRAPH / this.phase);

        // Rise up
        this.mesh.position.y = progress * 3;

        // Both arms up
        this.leftArm.rotation.z = progress * 1.5;
        this.rightArm.rotation.z = -progress * 1.5;

        this.bossLight.intensity = 1 + progress * 2;

        if (this.stateTimer >= this.stateTimes.POUND_TELEGRAPH / this.phase) {
            this.state = 'POUND';
            this.stateTimer = 0;
        }
    }

    updatePound(deltaTime, playerPosition) {
        const progress = this.stateTimer / this.stateTimes.POUND;

        // Slam down
        this.mesh.position.y = 3 * (1 - progress * 2);
        if (this.mesh.position.y < 0) this.mesh.position.y = 0;

        // Arms slam
        this.leftArm.rotation.z = 1.5 - progress * 3;
        this.rightArm.rotation.z = -1.5 + progress * 3;

        if (this.stateTimer >= this.stateTimes.POUND) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
            this.leftArm.rotation.z = 0;
            this.rightArm.rotation.z = 0;

            // Create shockwave effect at impact
            this.createShockwave();
        }
    }

    createShockwave() {
        const shockwaveGeom = new THREE.RingGeometry(0.5, 1.5, 32);
        const shockwaveMat = new THREE.MeshBasicMaterial({
            color: 0xd4af37,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        const shockwave = new THREE.Mesh(shockwaveGeom, shockwaveMat);
        shockwave.position.copy(this.position);
        shockwave.position.y = 0.1;
        shockwave.rotation.x = -Math.PI / 2;
        this.scene.add(shockwave);

        // Store for animation
        if (!this.shockwaves) this.shockwaves = [];
        this.shockwaves.push({ mesh: shockwave, timer: 0 });
    }

    updateSummonTelegraph(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SUMMON_TELEGRAPH;

        // Glow intensifies
        this.bossLight.intensity = 1 + progress * 2;
        this.eye.material.opacity = 0.8 + Math.sin(this.stateTimer * 20) * 0.2;

        if (this.stateTimer >= this.stateTimes.SUMMON_TELEGRAPH) {
            this.state = 'SUMMON';
            this.stateTimer = 0;
        }
    }

    updateSummon(deltaTime) {
        // Spawn Ticks around the boss
        if (this.stateTimer < deltaTime * 2 && this.game) {
            const tickCount = Math.min(this.maxSummons, 2 + this.phase);
            for (let i = 0; i < tickCount; i++) {
                const angle = (i / tickCount) * Math.PI * 2;
                const dist = 5;
                const pos = new THREE.Vector3(
                    this.position.x + Math.cos(angle) * dist,
                    0,
                    this.position.z + Math.sin(angle) * dist
                );
                this.game.spawnEnemy('tick', pos);
            }
        }

        if (this.stateTimer >= this.stateTimes.SUMMON) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    // V3: Temporal Barrage Telegraph
    updateBarrageTelegraph(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.BARRAGE_TELEGRAPH;

        // Eye glows intensely
        this.eye.material.opacity = 0.8 + Math.sin(this.stateTimer * 15) * 0.2;
        this.bossLight.intensity = 1 + progress * 2;
        this.bossLight.color.setHex(0xff00ff); // Purple for barrage

        if (this.stateTimer >= this.stateTimes.BARRAGE_TELEGRAPH) {
            this.state = 'BARRAGE';
            this.stateTimer = 0;
            this.barrageFired = 0;
        }
    }

    // V3: Temporal Barrage - fires multiple projectiles
    updateBarrage(deltaTime, playerPosition) {
        const projectileCount = this.phase === 3 ? 8 : 5;
        const fireInterval = this.stateTimes.BARRAGE / projectileCount;

        // Fire projectiles at intervals
        const shouldFire = Math.floor(this.stateTimer / fireInterval);
        while (this.barrageFired < shouldFire && this.barrageFired < projectileCount) {
            this.fireBarrageProjectile(playerPosition);
            this.barrageFired++;
        }

        // Update existing projectiles
        this.updateBarrageProjectiles(deltaTime, playerPosition);

        if (this.stateTimer >= this.stateTimes.BARRAGE) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
            this.bossLight.color.setHex(this.phase === 3 ? 0xff0000 : 0xff8844);
        }
    }

    fireBarrageProjectile(playerPosition) {
        const projGeom = new THREE.SphereGeometry(0.3, 8, 8);
        const projMat = new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.9
        });
        const proj = new THREE.Mesh(projGeom, projMat);

        // Start from boss eye position
        proj.position.set(this.position.x, 2.5, this.position.z);

        // Direction toward player with slight spread
        const spread = (Math.random() - 0.5) * 0.3;
        const direction = new THREE.Vector3(
            playerPosition.x - this.position.x + spread * 5,
            0,
            playerPosition.z - this.position.z + spread * 5
        ).normalize();

        // Add point light
        const light = new THREE.PointLight(0xff00ff, 0.5, 3);
        proj.add(light);

        this.scene.add(proj);
        this.barrageProjectiles.push({
            mesh: proj,
            direction: direction,
            speed: 15,
            timer: 0
        });
    }

    updateBarrageProjectiles(deltaTime, playerPosition) {
        for (let i = this.barrageProjectiles.length - 1; i >= 0; i--) {
            const proj = this.barrageProjectiles[i];
            proj.timer += deltaTime;

            // Move projectile
            proj.mesh.position.x += proj.direction.x * proj.speed * deltaTime;
            proj.mesh.position.z += proj.direction.z * proj.speed * deltaTime;

            // Remove if too old or out of arena
            const distFromCenter = Math.sqrt(
                proj.mesh.position.x * proj.mesh.position.x +
                proj.mesh.position.z * proj.mesh.position.z
            );

            if (proj.timer > 3 || distFromCenter > CONFIG.arenaRadius + 5) {
                this.scene.remove(proj.mesh);
                proj.mesh.geometry.dispose();
                proj.mesh.material.dispose();
                this.barrageProjectiles.splice(i, 1);
            }
        }
    }

    // V3: Swarm Telegraph (bigger summon)
    updateSwarmTelegraph(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SWARM_TELEGRAPH;

        this.bossLight.intensity = 1 + progress * 3;
        this.eye.material.opacity = 0.8 + Math.sin(this.stateTimer * 20) * 0.2;

        // Arms raise dramatically
        this.leftArm.rotation.z = progress * 1.0;
        this.rightArm.rotation.z = -progress * 1.0;

        if (this.stateTimer >= this.stateTimes.SWARM_TELEGRAPH) {
            this.state = 'SWARM';
            this.stateTimer = 0;
        }
    }

    // V3: Swarm - spawn many enemies at once
    updateSwarm(deltaTime) {
        if (this.stateTimer < deltaTime * 2 && this.game) {
            // Spawn 6-8 enemies based on phase
            const swarmCount = 6 + this.phase;
            for (let i = 0; i < swarmCount; i++) {
                const angle = (i / swarmCount) * Math.PI * 2 + Math.random() * 0.3;
                const dist = 6 + Math.random() * 4;
                const pos = new THREE.Vector3(
                    this.position.x + Math.cos(angle) * dist,
                    0,
                    this.position.z + Math.sin(angle) * dist
                );
                // Mix of tick and tock
                const type = Math.random() < 0.7 ? 'tick' : 'tock';
                this.game.spawnEnemy(type, pos);
            }
        }

        // Reset arm position
        this.leftArm.rotation.z = 0;
        this.rightArm.rotation.z = 0;

        if (this.stateTimer >= this.stateTimes.SWARM) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    // V3: Time Rewind - heal effect during Phase 3 transition
    updateRewind(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.REWIND;

        // Dramatic visual effect
        this.bossLight.intensity = 3 + Math.sin(progress * Math.PI * 8) * 2;
        this.bossLight.color.setHex(0x00ffff); // Cyan for time rewind

        // Heal 15% of max health over the duration
        const healPerSecond = (this.maxHealth * 0.15) / this.stateTimes.REWIND;
        this.health = Math.min(this.health + healPerSecond * deltaTime, this.maxHealth);

        // Spin effect
        this.mesh.rotation.y += deltaTime * 10;

        // Visual pulse
        const pulse = 1 + Math.sin(progress * Math.PI * 4) * 0.15;
        this.mesh.scale.setScalar(pulse);

        if (this.stateTimer >= this.stateTimes.REWIND) {
            this.state = 'TRANSITION';
            this.stateTimer = 0;
            this.mesh.scale.setScalar(1);
            this.bossLight.color.setHex(0xff0000);
        }
    }

    updateRecover(deltaTime) {
        const recoverTime = this.stateTimes.RECOVER / (this.phase === 3 ? 2 : 1);
        this.bossLight.intensity = 1;

        if (this.stateTimer >= recoverTime) {
            this.state = 'IDLE';
            this.stateTimer = 0;
        }
    }

    updateTransition(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.TRANSITION;

        // Dramatic pulsing
        const pulse = Math.sin(progress * Math.PI * 6);
        this.mesh.scale.setScalar(1 + pulse * 0.1);
        this.bossLight.intensity = 2 + pulse;

        if (this.stateTimer >= this.stateTimes.TRANSITION) {
            this.state = 'IDLE';
            this.stateTimer = 0;
            this.mesh.scale.setScalar(1);
            this.bossLight.intensity = 1;
        }
    }

    createDistortionZone() {
        // Create a time distortion zone
        const zoneGeom = new THREE.CylinderGeometry(4, 4, 0.2, 32);
        const zoneMat = new THREE.MeshBasicMaterial({
            color: 0x8844ff,
            transparent: true,
            opacity: 0.3
        });
        const zone = new THREE.Mesh(zoneGeom, zoneMat);

        // Random position in arena
        const angle = Math.random() * Math.PI * 2;
        const dist = 10 + Math.random() * 15;
        zone.position.set(
            Math.cos(angle) * dist,
            0.1,
            Math.sin(angle) * dist
        );

        this.scene.add(zone);
        this.distortionZones.push({
            mesh: zone,
            timer: 0,
            duration: 8 + Math.random() * 4
        });
    }

    updateDistortionZones(deltaTime) {
        for (let i = this.distortionZones.length - 1; i >= 0; i--) {
            const zone = this.distortionZones[i];
            zone.timer += deltaTime;

            // Pulse effect
            zone.mesh.material.opacity = 0.3 + Math.sin(zone.timer * 3) * 0.1;

            if (zone.timer >= zone.duration) {
                this.scene.remove(zone.mesh);
                this.distortionZones.splice(i, 1);

                // Create new zone in Phase 2+
                if (this.phase >= 2 && this.isAlive) {
                    this.createDistortionZone();
                }
            }
        }

        // Update shockwaves
        if (this.shockwaves) {
            for (let i = this.shockwaves.length - 1; i >= 0; i--) {
                const sw = this.shockwaves[i];
                sw.timer += deltaTime;
                const progress = sw.timer / 0.5;

                sw.mesh.scale.setScalar(1 + progress * 10);
                sw.mesh.material.opacity = 0.8 * (1 - progress);

                if (progress >= 1) {
                    this.scene.remove(sw.mesh);
                    this.shockwaves.splice(i, 1);
                }
            }
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 3.0; // Long death animation

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            // Dramatic death - explode outward
            const shake = Math.sin(progress * 50) * (1 - progress) * 0.3;
            this.mesh.position.x = this.position.x + shake;
            this.mesh.position.z = this.position.z + shake;

            this.mesh.rotation.y += deltaTime * progress * 10;
            this.mesh.scale.setScalar(1 + progress * 0.5);

            this.bossLight.intensity = 3 * (1 - progress);

            // Shrink at the end
            if (progress > 0.7) {
                this.mesh.scale.setScalar((1 - progress) * 3);
            }
        } else {
            // Clean up
            for (const zone of this.distortionZones) {
                this.scene.remove(zone.mesh);
            }
            this.distortionZones = [];

            if (this.shockwaves) {
                for (const sw of this.shockwaves) {
                    this.scene.remove(sw.mesh);
                }
                this.shockwaves = [];
            }

            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.1);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if (this.hasHitPlayer) return false;

        // Sweep attack - wide arc
        if (this.state === 'SWEEP') {
            const dist = Vec3.distance(this.position, playerPosition);
            if (dist < 6) { // Wide sweep range
                this.hasHitPlayer = true;
                this.damage = 25 * this.phase;
                return true;
            }
        }

        // Pound attack - AoE around boss
        if (this.state === 'POUND' && this.stateTimer > this.stateTimes.POUND * 0.8) {
            const dist = Vec3.distance(this.position, playerPosition);
            if (dist < 8) { // Shockwave range
                this.hasHitPlayer = true;
                this.damage = 35 * this.phase;
                return true;
            }
        }

        // Distortion zone damage (slow tick)
        for (const zone of this.distortionZones) {
            const dist = Vec3.distance(zone.mesh.position, playerPosition);
            if (dist < 4) {
                // Small damage tick (handled per frame, so very low)
                this.damage = 5;
                return true;
            }
        }

        // V3: Barrage projectile collision
        for (let i = this.barrageProjectiles.length - 1; i >= 0; i--) {
            const proj = this.barrageProjectiles[i];
            const dx = proj.mesh.position.x - playerPosition.x;
            const dz = proj.mesh.position.z - playerPosition.z;
            const dist = Math.sqrt(dx * dx + dz * dz);

            if (dist < playerRadius + 0.5) {
                // Remove projectile on hit
                this.scene.remove(proj.mesh);
                proj.mesh.geometry.dispose();
                proj.mesh.material.dispose();
                this.barrageProjectiles.splice(i, 1);

                this.damage = 20; // Barrage projectile damage
                return true;
            }
        }

        return false;
    }

    isVulnerable() {
        return this.state === 'RECOVER' || this.state === 'TRANSITION';
    }
}

// â”€â”€â”€ ELEMENTAL CHRONOPHAGE BOSS CONFIGURATIONS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const CHRONOPHAGE_TYPES = {
    WIND: {
        name: 'Wind Chronophage',
        wave: 10,
        colors: {
            primary: 0x88ccaa,      // Pale green
            secondary: 0xaaffcc,    // Light cyan-green
            glow: 0x44ff88,         // Bright green
            eye: 0x00ff66           // Neon green
        },
        minions: ['tick', 'tock'],   // Fast minions
        specialAttack: 'TORNADO',
        description: 'Master of temporal winds'
    },
    FIRE: {
        name: 'Fire Chronophage',
        wave: 20,
        colors: {
            primary: 0x8b0000,      // Dark red
            secondary: 0xff4500,    // Orange-red
            glow: 0xff6600,         // Bright orange
            eye: 0xff0000           // Pure red
        },
        minions: ['tick', 'grandfather'],
        specialAttack: 'INFERNO',
        description: 'Wielder of burning time'
    },
    ICE: {
        name: 'Ice Chronophage',
        wave: 30,
        colors: {
            primary: 0x1a1a4e,      // Deep blue
            secondary: 0x4488ff,    // Ice blue
            glow: 0x88ccff,         // Light blue
            eye: 0x00ffff           // Cyan
        },
        minions: ['pendulum', 'secondhand'],
        specialAttack: 'FREEZE',
        description: 'Frozen in eternal moments'
    },
    LIGHTNING: {
        name: 'Lightning Chronophage',
        wave: 40,
        colors: {
            primary: 0x4a0080,      // Deep purple
            secondary: 0xffff00,    // Yellow
            glow: 0xffff88,         // Pale yellow
            eye: 0xffffff           // White
        },
        minions: ['tock', 'secondhand', 'mite'],
        specialAttack: 'STORM',
        description: 'Strikes with temporal lightning'
    },
    TIME_EATER: {
        name: 'THE TIME EATER',
        wave: 50,
        colors: {
            primary: 0x000000,      // Void black
            secondary: 0x8800ff,    // Purple
            glow: 0xff00ff,         // Magenta
            eye: 0xffffff           // White core
        },
        minions: ['grandfather', 'secondhand', 'mite'],
        specialAttack: 'DEVOUR',
        isFinalBoss: true,
        description: 'The end of all time'
    }
};

// Get Chronophage type based on wave number
function getChronophageType(wave) {
    const bossNumber = Math.floor(wave / 10);
    switch (bossNumber) {
        case 1: return CHRONOPHAGE_TYPES.WIND;
        case 2: return CHRONOPHAGE_TYPES.FIRE;
        case 3: return CHRONOPHAGE_TYPES.ICE;
        case 4: return CHRONOPHAGE_TYPES.LIGHTNING;
        default: return CHRONOPHAGE_TYPES.TIME_EATER; // Wave 50+ is always Time Eater
    }
}

// â”€â”€â”€ ELEMENTAL CHRONOPHAGE CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ElementalChronophage extends ChronophagePrime {
    constructor(scene, position, game, chronophageType) {
        super(scene, position, game);

        this.chronophageType = chronophageType;
        this.enemyName = chronophageType.name;

        // Scale stats based on boss tier
        const bossNumber = Math.floor(game.wave / 10);
        const statMultiplier = 1 + (bossNumber - 1) * 0.5;

        this.health *= statMultiplier;
        this.maxHealth = this.health;
        this.damage *= statMultiplier;

        // Special attack tracking
        this.specialAttackCooldown = 0;
        this.specialAttackInterval = 8; // Seconds between special attacks
        this.isPerformingSpecialAttack = false;

        // Boss-specific projectiles/effects
        this.elementalProjectiles = [];
        this.elementalEffects = [];

        // Update visuals with elemental colors
        this.applyElementalColors();

        // Add elemental particles
        this.createElementalAura();
    }

    applyElementalColors() {
        const colors = this.chronophageType.colors;

        // Update body materials
        this.mesh.traverse((child) => {
            if (child.isMesh && child.material) {
                if (child === this.body) {
                    child.material.color.setHex(colors.primary);
                } else if (child === this.eye) {
                    child.material.color.setHex(colors.eye);
                    child.material.emissive = new THREE.Color(colors.eye);
                    child.material.emissiveIntensity = 1.0;
                } else if (child.material.color && child.material.emissive) {
                    // Gold parts become elemental color
                    if (child.material.color.getHex() === 0xd4af37) {
                        child.material.color.setHex(colors.secondary);
                        child.material.emissive.setHex(colors.secondary);
                    }
                }
            }
        });

        // Update boss light
        if (this.bossLight) {
            this.bossLight.color.setHex(colors.glow);
        }
    }

    createElementalAura() {
        // Create floating elemental particles around boss
        this.auraParticles = [];
        const colors = this.chronophageType.colors;

        for (let i = 0; i < 12; i++) {
            const particleGeom = new THREE.SphereGeometry(0.15, 8, 8);
            const particleMat = new THREE.MeshBasicMaterial({
                color: colors.glow,
                transparent: true,
                opacity: 0.7
            });
            const particle = new THREE.Mesh(particleGeom, particleMat);
            particle.userData.angle = (i / 12) * Math.PI * 2;
            particle.userData.radius = 3 + Math.random();
            particle.userData.speed = 0.5 + Math.random() * 0.5;
            particle.userData.yOffset = (Math.random() - 0.5) * 2;
            this.mesh.add(particle);
            this.auraParticles.push(particle);
        }
    }

    update(deltaTime, playerPosition) {
        super.update(deltaTime, playerPosition);

        if (!this.isAlive) return;

        // Update aura particles
        if (this.auraParticles) {
            for (const particle of this.auraParticles) {
                particle.userData.angle += particle.userData.speed * deltaTime;
                particle.position.x = Math.cos(particle.userData.angle) * particle.userData.radius;
                particle.position.z = Math.sin(particle.userData.angle) * particle.userData.radius;
                particle.position.y = 2.5 + particle.userData.yOffset + Math.sin(particle.userData.angle * 2) * 0.3;
            }
        }

        // Special attack cooldown
        this.specialAttackCooldown -= deltaTime;
        if (this.specialAttackCooldown <= 0 && !this.isPerformingSpecialAttack && this.state === 'IDLE') {
            this.startSpecialAttack();
        }

        // Update elemental projectiles
        this.updateElementalProjectiles(deltaTime, playerPosition);
    }

    startSpecialAttack() {
        this.isPerformingSpecialAttack = true;
        this.specialAttackCooldown = this.specialAttackInterval;

        const attackType = this.chronophageType.specialAttack;

        switch (attackType) {
            case 'TORNADO':
                this.performTornadoAttack();
                break;
            case 'INFERNO':
                this.performInfernoAttack();
                break;
            case 'FREEZE':
                this.performFreezeAttack();
                break;
            case 'STORM':
                this.performStormAttack();
                break;
            case 'DEVOUR':
                this.performDevourAttack();
                break;
        }

        // Spawn minions during special attack
        this.spawnElementalMinions();

        setTimeout(() => {
            this.isPerformingSpecialAttack = false;
        }, 2000);
    }

    performTornadoAttack() {
        // Wind Chronophage: Create swirling projectiles
        const numProjectiles = 8;
        for (let i = 0; i < numProjectiles; i++) {
            const angle = (i / numProjectiles) * Math.PI * 2;
            const projectile = this.createElementalProjectile(
                0x44ff88,
                new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))
            );
            projectile.userData.spiral = true;
            projectile.userData.baseAngle = angle;
            this.elementalProjectiles.push(projectile);
        }

        // VFX
        if (this.game.vfx) {
            this.game.vfx.screenFlash('#44ff88', 0.3);
        }
    }

    performInfernoAttack() {
        // Fire Chronophage: Ring of fire expanding outward
        const numFlames = 16;
        for (let i = 0; i < numFlames; i++) {
            const angle = (i / numFlames) * Math.PI * 2;
            const projectile = this.createElementalProjectile(
                0xff4500,
                new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))
            );
            projectile.userData.expanding = true;
            this.elementalProjectiles.push(projectile);
        }

        if (this.game.vfx) {
            this.game.vfx.screenFlash('#ff4500', 0.4);
        }
    }

    performFreezeAttack() {
        // Ice Chronophage: Create ice shards that slow player
        const numShards = 12;
        for (let i = 0; i < numShards; i++) {
            const angle = (i / numShards) * Math.PI * 2;
            const delay = i * 100;
            setTimeout(() => {
                if (!this.isAlive) return;
                const projectile = this.createElementalProjectile(
                    0x88ccff,
                    new THREE.Vector3(Math.cos(angle), 0, Math.sin(angle))
                );
                projectile.userData.freezing = true;
                this.elementalProjectiles.push(projectile);
            }, delay);
        }

        if (this.game.vfx) {
            this.game.vfx.screenFlash('#88ccff', 0.4);
        }
    }

    performStormAttack() {
        // Lightning Chronophage: Random lightning strikes
        const numStrikes = 6;
        for (let i = 0; i < numStrikes; i++) {
            setTimeout(() => {
                if (!this.isAlive || !this.game.player) return;

                // Strike near player position with some randomness
                const strikePos = this.game.player.position.clone();
                strikePos.x += (Math.random() - 0.5) * 8;
                strikePos.z += (Math.random() - 0.5) * 8;

                this.createLightningStrike(strikePos);
            }, i * 300);
        }

        if (this.game.vfx) {
            this.game.vfx.screenFlash('#ffff88', 0.5);
        }
    }

    performDevourAttack() {
        // Time Eater: Pulls player toward boss and spawns void zones
        if (this.game.player) {
            // Store reference to boss for dynamic pull direction
            const boss = this;

            // Apply pull force using player's external force system
            // This integrates properly with the movement system
            const pullStrength = 15;
            const pullDuration = 2000;
            const pullInterval = 100;
            let elapsed = 0;

            const pullTimer = setInterval(() => {
                if (!boss.isAlive || !this.game.player) {
                    clearInterval(pullTimer);
                    return;
                }

                // Calculate fresh pull direction each tick (dynamic)
                const towardsBoss = new THREE.Vector3(
                    boss.position.x - this.game.player.position.x,
                    0,
                    boss.position.z - this.game.player.position.z
                );

                const distance = towardsBoss.length();
                if (distance > 2) { // Don't pull if too close
                    towardsBoss.normalize().multiplyScalar(pullStrength);
                    this.game.player.externalForce.copy(towardsBoss);
                }

                elapsed += pullInterval;
                if (elapsed >= pullDuration) {
                    clearInterval(pullTimer);
                    // Clear remaining force
                    if (this.game.player) {
                        this.game.player.externalForce.set(0, 0, 0);
                    }
                }
            }, pullInterval);

            // Spawn void zones
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                const distance = 8;
                const voidPos = new THREE.Vector3(
                    this.position.x + Math.cos(angle) * distance,
                    0,
                    this.position.z + Math.sin(angle) * distance
                );
                this.createVoidZone(voidPos);
            }
        }

        if (this.game.vfx) {
            this.game.vfx.screenFlash('#ff00ff', 0.6);
            this.game.screenEffects.chromaticBurst(0.5);
        }
    }

    createElementalProjectile(color, direction) {
        const geom = new THREE.SphereGeometry(0.4, 8, 8);
        const mat = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.9
        });
        const projectile = new THREE.Mesh(geom, mat);
        projectile.position.copy(this.position);
        projectile.position.y = 2;
        projectile.userData.direction = direction.clone();
        projectile.userData.speed = 12;
        projectile.userData.lifetime = 5;
        projectile.userData.age = 0;
        projectile.userData.damage = this.damage * 0.5;

        // Add glow
        const light = new THREE.PointLight(color, 0.5, 3);
        projectile.add(light);

        this.scene.add(projectile);
        return projectile;
    }

    createLightningStrike(position) {
        // Create visual lightning bolt
        const boltGroup = new THREE.Group();

        // Main bolt
        const points = [];
        const segments = 8;
        for (let i = 0; i <= segments; i++) {
            const y = 15 - (i / segments) * 15;
            const x = (Math.random() - 0.5) * 1;
            const z = (Math.random() - 0.5) * 1;
            points.push(new THREE.Vector3(x, y, z));
        }

        const boltGeom = new THREE.BufferGeometry().setFromPoints(points);
        const boltMat = new THREE.LineBasicMaterial({ color: 0xffff00, linewidth: 3 });
        const bolt = new THREE.Line(boltGeom, boltMat);
        boltGroup.add(bolt);

        // Impact flash
        const flashGeom = new THREE.CircleGeometry(2, 16);
        const flashMat = new THREE.MeshBasicMaterial({
            color: 0xffff88,
            transparent: true,
            opacity: 0.8
        });
        const flash = new THREE.Mesh(flashGeom, flashMat);
        flash.rotation.x = -Math.PI / 2;
        flash.position.y = 0.1;
        boltGroup.add(flash);

        boltGroup.position.copy(position);
        this.scene.add(boltGroup);

        // Check if player is hit
        if (this.game.player) {
            const dist = position.distanceTo(this.game.player.position);
            if (dist < 3) {
                this.game.onPlayerHit(this.damage * 0.3, this);
            }
        }

        // Remove after short time
        setTimeout(() => {
            this.scene.remove(boltGroup);
            boltGroup.traverse((child) => {
                if (child.geometry) child.geometry.dispose();
                if (child.material) child.material.dispose();
            });
        }, 200);
    }

    createVoidZone(position) {
        const zoneGeom = new THREE.CircleGeometry(3, 32);
        const zoneMat = new THREE.MeshBasicMaterial({
            color: 0x8800ff,
            transparent: true,
            opacity: 0.5
        });
        const zone = new THREE.Mesh(zoneGeom, zoneMat);
        zone.rotation.x = -Math.PI / 2;
        zone.position.copy(position);
        zone.position.y = 0.1;
        this.scene.add(zone);

        // Damage player if in zone
        const damageInterval = setInterval(() => {
            if (!this.isAlive || !this.game.player) {
                clearInterval(damageInterval);
                return;
            }
            const dist = position.distanceTo(this.game.player.position);
            if (dist < 3) {
                this.game.onPlayerHit(this.damage * 0.1, this);
            }
        }, 500);

        // Remove after duration
        setTimeout(() => {
            clearInterval(damageInterval);
            this.scene.remove(zone);
            zone.geometry.dispose();
            zone.material.dispose();
        }, 5000);
    }

    updateElementalProjectiles(deltaTime, playerPosition) {
        for (let i = this.elementalProjectiles.length - 1; i >= 0; i--) {
            const proj = this.elementalProjectiles[i];
            proj.userData.age += deltaTime;

            if (proj.userData.age > proj.userData.lifetime) {
                this.scene.remove(proj);
                proj.geometry.dispose();
                proj.material.dispose();
                this.elementalProjectiles.splice(i, 1);
                continue;
            }

            // Movement patterns
            if (proj.userData.spiral) {
                proj.userData.baseAngle += deltaTime * 2;
                const radius = 3 + proj.userData.age * 3;
                proj.position.x = this.position.x + Math.cos(proj.userData.baseAngle) * radius;
                proj.position.z = this.position.z + Math.sin(proj.userData.baseAngle) * radius;
            } else if (proj.userData.expanding) {
                const expandSpeed = proj.userData.speed;
                proj.position.add(proj.userData.direction.clone().multiplyScalar(expandSpeed * deltaTime));
            } else {
                proj.position.add(proj.userData.direction.clone().multiplyScalar(proj.userData.speed * deltaTime));
            }

            // Check player collision
            if (this.game.player) {
                const dist = proj.position.distanceTo(this.game.player.position);
                if (dist < 1.5) {
                    this.game.onPlayerHit(proj.userData.damage, this);

                    // Freezing projectiles slow player
                    if (proj.userData.freezing && this.game.player) {
                        this.game.player.applySlowEffect(0.5, 2);
                    }

                    this.scene.remove(proj);
                    proj.geometry.dispose();
                    proj.material.dispose();
                    this.elementalProjectiles.splice(i, 1);
                }
            }
        }
    }

    spawnElementalMinions() {
        if (!this.game) return;

        const minionTypes = this.chronophageType.minions;
        const numMinions = 2 + Math.floor(this.game.wave / 20);

        for (let i = 0; i < numMinions; i++) {
            const minionType = minionTypes[Math.floor(Math.random() * minionTypes.length)];
            const angle = Math.random() * Math.PI * 2;
            const distance = 8 + Math.random() * 5;
            const pos = new THREE.Vector3(
                this.position.x + Math.cos(angle) * distance,
                0,
                this.position.z + Math.sin(angle) * distance
            );

            setTimeout(() => {
                if (this.isAlive && this.game) {
                    this.game.spawnEnemy(minionType, pos);
                }
            }, i * 300);
        }
    }

    die() {
        // Clean up elemental projectiles
        for (const proj of this.elementalProjectiles) {
            this.scene.remove(proj);
            proj.geometry.dispose();
            proj.material.dispose();
        }
        this.elementalProjectiles = [];

        // Clean up aura particles
        if (this.auraParticles) {
            for (const particle of this.auraParticles) {
                this.mesh.remove(particle);
                particle.geometry.dispose();
                particle.material.dispose();
            }
        }

        // Dramatic death effects
        this.performDramaticDeath();

        super.die();
    }

    performDramaticDeath() {
        if (!this.game || !this.game.vfx) return;

        const colors = this.chronophageType.colors;

        // Multiple lightning strikes at boss position
        for (let i = 0; i < 8; i++) {
            setTimeout(() => {
                if (this.game && this.game.vfx) {
                    const strikePos = this.position.clone();
                    strikePos.x += (Math.random() - 0.5) * 4;
                    strikePos.z += (Math.random() - 0.5) * 4;
                    this.createDeathLightning(strikePos);
                }
            }, i * 150);
        }

        // Screen effects
        this.game.screenEffects.chromaticBurst(0.8);
        this.game.screenEffects.shake(1.0, 1.5);
        this.game.screenEffects.slowmo(0.2, 2.0);
        this.game.vfx.screenFlash(colors.glow, 1.0);

        // Massive particle explosion
        this.game.vfx.spawnHitSparks(this.position, 100, 'gold', {
            speed: 20,
            gravity: 5,
            lifetime: 2.0
        });

        // Final boss specific effects
        if (this.chronophageType.isFinalBoss) {
            // Victory sequence
            setTimeout(() => {
                if (this.game) {
                    this.game.showVictoryScreen();
                }
            }, 3000);
        }
    }

    createDeathLightning(position) {
        const colors = this.chronophageType.colors;

        // Create dramatic lightning bolt
        const boltGroup = new THREE.Group();

        // Multiple branching bolts
        for (let b = 0; b < 3; b++) {
            const points = [];
            const segments = 12;
            let x = 0, z = 0;
            for (let i = 0; i <= segments; i++) {
                const y = 20 - (i / segments) * 20;
                x += (Math.random() - 0.5) * 2;
                z += (Math.random() - 0.5) * 2;
                points.push(new THREE.Vector3(x, y, z));
            }

            const boltGeom = new THREE.BufferGeometry().setFromPoints(points);
            const boltMat = new THREE.LineBasicMaterial({
                color: colors.glow,
                linewidth: 2
            });
            const bolt = new THREE.Line(boltGeom, boltMat);
            boltGroup.add(bolt);
        }

        // Large impact effect
        const impactGeom = new THREE.SphereGeometry(2, 16, 16);
        const impactMat = new THREE.MeshBasicMaterial({
            color: colors.glow,
            transparent: true,
            opacity: 0.8
        });
        const impact = new THREE.Mesh(impactGeom, impactMat);
        impact.position.y = 1;
        boltGroup.add(impact);

        boltGroup.position.copy(position);
        this.scene.add(boltGroup);

        // Animate and remove
        let scale = 1;
        const animInterval = setInterval(() => {
            scale += 0.3;
            impact.scale.set(scale, scale, scale);
            impact.material.opacity -= 0.1;
            if (impact.material.opacity <= 0) {
                clearInterval(animInterval);
                this.scene.remove(boltGroup);
                boltGroup.traverse((child) => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
        }, 50);
    }
}

// â”€â”€â”€ PLAYER CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Player {
    constructor(scene) {
        this.scene = scene;

        // Position and rotation
        this.position = new THREE.Vector3(0, 0, 0);
        this.rotation = 0; // Y-axis rotation (facing direction)
        this.targetRotation = 0;

        // Velocity
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.currentSpeed = 0;

        // External forces (for boss pull effects, etc.)
        this.externalForce = new THREE.Vector3(0, 0, 0);

        // Stats V2 - Health based on difficulty
        this.maxHealth = getPlayerMaxHealth();
        this.health = this.maxHealth;
        this.stamina = CONFIG.maxStamina;
        this.temporalCharge = 0;
        this.staminaRegenTimer = 0;
        this.slowMultiplier = 1.0; // For Ice Chronophage slow effect

        // Health Regeneration V2
        this.outOfCombatTimer = 0; // Time since last damage
        this.isRegenerating = false;
        this.regenPulseTimer = 0;
        this.lastHealth = this.health; // For tracking damage

        // State flags
        this.isSprinting = false;
        this.isDashing = false;
        this.dashTimer = 0;
        this.dashCooldownTimer = 0;
        this.dashDirection = new THREE.Vector3(0, 0, -1);

        // Combat
        this.isAttacking = false;
        this.sword = null;

        // Temporal Abilities
        this.timeFractureCooldown = 0;
        this.temporalEchoCooldown = 0;
        this.chronostasisCooldown = 0;

        // Temporal Echo state
        this.temporalEchoActive = false;
        this.temporalEchoTimer = 0;
        this.temporalEchoPosition = null;
        this.temporalEchoGhost = null;

        // Key press tracking (for single-press abilities)
        this.keyPressed = { q: false, e: false, r: false };

        // Animation
        this.bobOffset = 0;
        this.stepTimer = 0;

        // Mesh group
        this.mesh = null;
        this.bodyParts = {};

        // Ability effects container
        this.abilityEffects = [];

        // V2 Weapon System
        this.weapons = ['blade', 'pistol', 'scythe'];
        this.currentWeapon = 'blade';
        this.weaponIndex = 0;

        // Pistol state
        this.pistolAmmo = CONFIG.weapons.pistol.maxAmmo;
        this.pistolReloading = false;
        this.pistolReloadTimer = 0;
        this.lastFireTime = 0;
        this.projectiles = []; // For pistol bullets

        // Scythe state
        this.scytheTrailTimer = 0;

        // V2.7 Dash afterimages
        this.dashAfterimages = [];
        this.dashAfterimageTimer = 0;

        // V4 INFINITE - Shield System
        this.shieldSystem = null; // Initialized after mesh creation

        // V4 INFINITE - Equipment & Inventory
        try {
            this.equipment = new EquipmentSystem();
            this.inventory = new InventorySystem(20);

            // V4 INFINITE - Setup equipment callbacks
            this.equipment.onEquipmentChange = (slot, item, previousItem) => {
                this.onEquipmentChange(slot, item, previousItem);
            };
        } catch (e) {
            console.error('V4 Equipment init error:', e);
            this.equipment = null;
            this.inventory = null;
        }

        // Create the player mesh
        this.createMesh();

        // Create sword (after mesh so it can be attached)
        this.sword = new Sword(scene, this);
        this.mesh.add(this.sword.mesh);

        // Create all weapon meshes (hidden by default, blade shown)
        this.createWeaponMeshes();

        // V4 INFINITE - Initialize shield system after mesh
        try {
            this.shieldSystem = new ShieldSystem(this);
            this.shieldSystem.attachToPlayer(this.mesh);
        } catch (e) {
            console.error('V4 Shield init error:', e);
            this.shieldSystem = null;
        }
    }

    // V2 - Create weapon meshes
    createWeaponMeshes() {
        // Weapons are attached to hand position on the mesh
        // Blade is the default Sword mesh already created
        // Create pistol mesh
        const pistolGroup = new THREE.Group();
        const pistolMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a6080,
            metalness: 0.8,
            roughness: 0.2
        });
        const glowMaterial = new THREE.MeshStandardMaterial({
            color: 0x7eb8da,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.5
        });

        // Pistol body
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.3, 0.5),
            pistolMaterial
        );
        body.position.set(0, 0, 0.15);
        pistolGroup.add(body);

        // Barrel
        const barrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8),
            pistolMaterial
        );
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0, 0.05, 0.5);
        pistolGroup.add(barrel);

        // Glow ring
        const glowRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.06, 0.015, 8, 16),
            glowMaterial
        );
        glowRing.rotation.y = Math.PI / 2;
        glowRing.position.set(0, 0.05, 0.6);
        pistolGroup.add(glowRing);

        pistolGroup.visible = false;
        pistolGroup.position.set(0.35, 1.1, 0.2);
        this.mesh.add(pistolGroup);
        this.pistolMesh = pistolGroup;

        // Create scythe mesh
        const scytheGroup = new THREE.Group();
        const handleMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a1a3a,
            roughness: 0.7,
            metalness: 0.3
        });
        const bladeMaterial = new THREE.MeshStandardMaterial({
            color: 0x8866aa,
            emissive: 0x442255,
            emissiveIntensity: 0.3,
            metalness: 0.9,
            roughness: 0.1
        });

        // Handle
        const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.04, 2.0, 8),
            handleMaterial
        );
        handle.position.set(0, 0, 0);
        scytheGroup.add(handle);

        // Blade curve (made from a curved shape)
        const bladeShape = new THREE.Shape();
        bladeShape.moveTo(0, 0);
        bladeShape.quadraticCurveTo(0.8, 0.2, 1.0, -0.5);
        bladeShape.lineTo(0.95, -0.55);
        bladeShape.quadraticCurveTo(0.7, 0.1, 0.05, -0.05);
        bladeShape.lineTo(0, 0);

        const bladeGeom = new THREE.ExtrudeGeometry(bladeShape, {
            depth: 0.03,
            bevelEnabled: false
        });
        const blade = new THREE.Mesh(bladeGeom, bladeMaterial);
        blade.rotation.z = Math.PI;
        blade.position.set(0, 1.0, 0);
        scytheGroup.add(blade);

        scytheGroup.visible = false;
        scytheGroup.position.set(0.5, 0.8, 0);
        scytheGroup.rotation.z = -Math.PI / 6;
        this.mesh.add(scytheGroup);
        this.scytheMesh = scytheGroup;
    }

    // V2 - Switch weapon
    switchWeapon(weaponName) {
        if (this.currentWeapon === weaponName) return;
        if (!this.weapons.includes(weaponName)) return;

        this.currentWeapon = weaponName;
        this.weaponIndex = this.weapons.indexOf(weaponName);

        // Update weapon visibility
        this.sword.mesh.visible = (weaponName === 'blade');
        this.pistolMesh.visible = (weaponName === 'pistol');
        this.scytheMesh.visible = (weaponName === 'scythe');

        // Update HUD
        this.updateWeaponHUD();
    }

    // V2 - Cycle to next weapon
    cycleWeapon(direction = 1) {
        this.weaponIndex = (this.weaponIndex + direction + this.weapons.length) % this.weapons.length;
        this.switchWeapon(this.weapons[this.weaponIndex]);
    }

    // V2 - Update weapon HUD display
    updateWeaponHUD() {
        const slots = document.querySelectorAll('.weapon-slot');
        slots.forEach(slot => {
            const weapon = slot.dataset.weapon;
            slot.classList.toggle('active', weapon === this.currentWeapon);
        });

        // Update pistol ammo display
        document.getElementById('pistol-ammo').textContent =
            `${this.pistolAmmo}/${CONFIG.weapons.pistol.maxAmmo}`;
    }

    // V2 - Fire pistol (V3: with aim assist)
    firePistol(enemies = null) {
        const now = performance.now() / 1000;
        const fireInterval = 1 / CONFIG.weapons.pistol.fireRate;

        if (this.pistolReloading) return false;
        if (now - this.lastFireTime < fireInterval) return false;
        if (this.pistolAmmo <= 0) {
            this.reloadPistol();
            return false;
        }

        this.lastFireTime = now;
        this.pistolAmmo--;

        // V3: Find aim assist target before creating projectile
        this.aimAssistTarget = enemies ? this.findAimAssistTarget(enemies) : null;

        // Create projectile
        const projectile = this.createPistolProjectile();
        this.projectiles.push(projectile);

        // V2.8 Pistol shot sound
        audioManager.playPistolShot();

        this.updateWeaponHUD();
        return true;
    }

    // V3 - Find nearest enemy for aim assist (increased cone by 30%)
    findAimAssistTarget(enemies, maxRange = 25, maxAngle = 0.52) {
        if (!enemies || enemies.length === 0) return null;

        const forwardDir = new THREE.Vector3(
            Math.sin(this.rotation),
            0,
            Math.cos(this.rotation)
        );

        let bestTarget = null;
        let bestScore = Infinity;

        for (const enemy of enemies) {
            if (!enemy.isAlive || !enemy.mesh) continue;

            // Get direction to enemy
            const toEnemy = new THREE.Vector3(
                enemy.position.x - this.position.x,
                0,
                enemy.position.z - this.position.z
            );
            const distance = toEnemy.length();

            if (distance > maxRange || distance < 1) continue;

            toEnemy.normalize();

            // Check angle (dot product)
            const dot = forwardDir.dot(toEnemy);
            const angle = Math.acos(Math.min(1, Math.max(-1, dot)));

            if (angle > maxAngle) continue; // Outside aim cone

            // Score: prefer closer enemies with smaller angles
            const score = distance * 0.5 + angle * 20;
            if (score < bestScore) {
                bestScore = score;
                bestTarget = enemy;
            }
        }

        return bestTarget;
    }

    // V2 - Create pistol projectile (V3: with aim assist)
    createPistolProjectile() {
        const projectileMaterial = new THREE.MeshStandardMaterial({
            color: 0x7eb8da,
            emissive: 0x4a90b8,
            emissiveIntensity: 1.0
        });

        const projectile = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 8, 8),
            projectileMaterial
        );

        // Start position at player
        const startPos = this.position.clone();
        startPos.y += 1.2;

        // Base direction based on player facing
        let direction = new THREE.Vector3(
            Math.sin(this.rotation),
            0,
            Math.cos(this.rotation)
        ).normalize();

        // V3: Apply aim assist - bend toward nearest enemy
        if (this.aimAssistTarget) {
            const toTarget = new THREE.Vector3(
                this.aimAssistTarget.position.x - this.position.x,
                0,
                this.aimAssistTarget.position.z - this.position.z
            ).normalize();

            // Blend 40% toward target (subtle assist)
            direction.lerp(toTarget, 0.4).normalize();
        }

        // Offset start position slightly forward
        startPos.add(direction.clone().multiplyScalar(0.8));

        projectile.position.copy(startPos);

        // Add point light for glow effect
        const light = new THREE.PointLight(0x7eb8da, 0.5, 3);
        projectile.add(light);

        this.scene.add(projectile);

        return {
            mesh: projectile,
            direction: direction,
            speed: 40,
            damage: CONFIG.weapons.pistol.damage,
            lifetime: 2,
            timer: 0
        };
    }

    // V2 - Update pistol projectiles (V4: with particle trails)
    updateProjectiles(deltaTime, vfx = null) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.timer += deltaTime;

            // Move projectile
            proj.mesh.position.add(
                proj.direction.clone().multiplyScalar(proj.speed * deltaTime)
            );

            // V4: Spawn trail particles
            if (vfx) {
                proj.trailTimer = (proj.trailTimer || 0) + deltaTime;
                if (proj.trailTimer >= 0.03) { // Every 30ms
                    proj.trailTimer = 0;
                    vfx.spawnTrailSegment(proj.mesh.position.clone(), 0x7eb8da, 0.08);
                }
            }

            // Remove if lifetime exceeded or out of arena
            if (proj.timer > proj.lifetime ||
                proj.mesh.position.length() > CONFIG.arenaRadius + 10) {
                this.scene.remove(proj.mesh);
                this.projectiles.splice(i, 1);
            }
        }
    }

    // V2 - Reload pistol
    reloadPistol() {
        if (this.pistolReloading) return;
        if (this.pistolAmmo >= CONFIG.weapons.pistol.maxAmmo) return;

        this.pistolReloading = true;
        this.pistolReloadTimer = CONFIG.weapons.pistol.reloadTime;

        // V2.8 Reload sound
        audioManager.playPistolReload();
    }

    // V2 - Update reload
    updateReload(deltaTime) {
        if (!this.pistolReloading) return;

        this.pistolReloadTimer -= deltaTime;
        if (this.pistolReloadTimer <= 0) {
            this.pistolAmmo = CONFIG.weapons.pistol.maxAmmo;
            this.pistolReloading = false;
            this.updateWeaponHUD();
        }
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const robeMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            roughness: 0.8,
            metalness: 0.2
        });

        const robeAccentMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a3a5a,
            roughness: 0.6,
            metalness: 0.3
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });

        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 0.9
        });

        // Body - main robe (tapered cylinder)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.6, 1.4, 8);
        const body = new THREE.Mesh(bodyGeometry, robeMaterial);
        body.position.y = 0.7;
        body.castShadow = true;
        this.mesh.add(body);
        this.bodyParts.body = body;

        // Lower robe (flared bottom)
        const lowerRobeGeometry = new THREE.CylinderGeometry(0.6, 0.8, 0.6, 8);
        const lowerRobe = new THREE.Mesh(lowerRobeGeometry, robeMaterial);
        lowerRobe.position.y = 0.3;
        lowerRobe.castShadow = true;
        this.mesh.add(lowerRobe);

        // Hood
        const hoodGeometry = new THREE.SphereGeometry(0.35, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const hood = new THREE.Mesh(hoodGeometry, robeMaterial);
        hood.position.y = 1.6;
        hood.scale.set(1, 1.2, 1);
        hood.castShadow = true;
        this.mesh.add(hood);

        // Hood rim (gold accent)
        const hoodRimGeometry = new THREE.TorusGeometry(0.35, 0.03, 8, 16, Math.PI);
        const hoodRim = new THREE.Mesh(hoodRimGeometry, goldMaterial);
        hoodRim.position.set(0, 1.5, 0.1);
        hoodRim.rotation.x = Math.PI / 2;
        hoodRim.rotation.z = Math.PI;
        this.mesh.add(hoodRim);

        // Face area (dark void)
        const faceGeometry = new THREE.SphereGeometry(0.25, 8, 8, 0, Math.PI, 0, Math.PI);
        const faceMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            side: THREE.DoubleSide
        });
        const face = new THREE.Mesh(faceGeometry, faceMaterial);
        face.position.set(0, 1.55, 0.15);
        face.rotation.y = Math.PI;
        this.mesh.add(face);

        // Glowing eyes
        const eyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.08, 1.55, 0.25);
        this.mesh.add(leftEye);
        this.bodyParts.leftEye = leftEye;

        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.08, 1.55, 0.25);
        this.mesh.add(rightEye);
        this.bodyParts.rightEye = rightEye;

        // Eye glow (point light)
        const eyeGlow = new THREE.PointLight(0x7eb8da, 0.3, 2);
        eyeGlow.position.set(0, 1.55, 0.3);
        this.mesh.add(eyeGlow);
        this.bodyParts.eyeGlow = eyeGlow;

        // Shoulder pauldrons (left)
        const pauldronGeometry = new THREE.SphereGeometry(0.18, 8, 8);
        const leftPauldron = new THREE.Mesh(pauldronGeometry, goldMaterial);
        leftPauldron.position.set(-0.45, 1.3, 0);
        leftPauldron.scale.set(1, 0.8, 0.8);
        leftPauldron.castShadow = true;
        this.mesh.add(leftPauldron);

        const rightPauldron = new THREE.Mesh(pauldronGeometry, goldMaterial);
        rightPauldron.position.set(0.45, 1.3, 0);
        rightPauldron.scale.set(1, 0.8, 0.8);
        rightPauldron.castShadow = true;
        this.mesh.add(rightPauldron);

        // Clock motif on pauldrons (small circles)
        const clockDetailGeometry = new THREE.TorusGeometry(0.08, 0.015, 8, 16);
        const leftClockDetail = new THREE.Mesh(clockDetailGeometry, robeAccentMaterial);
        leftClockDetail.position.set(-0.55, 1.3, 0.1);
        leftClockDetail.rotation.y = Math.PI / 4;
        this.mesh.add(leftClockDetail);

        const rightClockDetail = new THREE.Mesh(clockDetailGeometry, robeAccentMaterial);
        rightClockDetail.position.set(0.55, 1.3, 0.1);
        rightClockDetail.rotation.y = -Math.PI / 4;
        this.mesh.add(rightClockDetail);

        // Arms
        const armGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.6, 8);
        const leftArm = new THREE.Mesh(armGeometry, robeAccentMaterial);
        leftArm.position.set(-0.5, 1.0, 0);
        leftArm.rotation.z = 0.3;
        leftArm.castShadow = true;
        this.mesh.add(leftArm);
        this.bodyParts.leftArm = leftArm;

        const rightArm = new THREE.Mesh(armGeometry, robeAccentMaterial);
        rightArm.position.set(0.5, 1.0, 0);
        rightArm.rotation.z = -0.3;
        rightArm.castShadow = true;
        this.mesh.add(rightArm);
        this.bodyParts.rightArm = rightArm;

        // Forearms
        const forearmGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.5, 8);
        const leftForearm = new THREE.Mesh(forearmGeometry, robeAccentMaterial);
        leftForearm.position.set(-0.6, 0.55, 0.2);
        leftForearm.rotation.x = -0.5;
        leftForearm.rotation.z = 0.2;
        leftForearm.castShadow = true;
        this.mesh.add(leftForearm);
        this.bodyParts.leftForearm = leftForearm;

        const rightForearm = new THREE.Mesh(forearmGeometry, robeAccentMaterial);
        rightForearm.position.set(0.5, 0.55, 0.3);
        rightForearm.rotation.x = -0.8;
        rightForearm.rotation.z = -0.2;
        rightForearm.castShadow = true;
        this.mesh.add(rightForearm);
        this.bodyParts.rightForearm = rightForearm;

        // Gauntlets with clock faces
        const gauntletGeometry = new THREE.BoxGeometry(0.12, 0.15, 0.08);
        const leftGauntlet = new THREE.Mesh(gauntletGeometry, goldMaterial);
        leftGauntlet.position.set(-0.65, 0.35, 0.35);
        this.mesh.add(leftGauntlet);

        const rightGauntlet = new THREE.Mesh(gauntletGeometry, goldMaterial);
        rightGauntlet.position.set(0.45, 0.3, 0.5);
        this.mesh.add(rightGauntlet);

        // Gauntlet clock faces
        const gauntletClockGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 12);
        const gauntletClockMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a90b8,
            transparent: true,
            opacity: 0.8
        });

        const leftGauntletClock = new THREE.Mesh(gauntletClockGeometry, gauntletClockMaterial);
        leftGauntletClock.position.set(-0.65, 0.35, 0.4);
        leftGauntletClock.rotation.x = Math.PI / 2;
        this.mesh.add(leftGauntletClock);

        const rightGauntletClock = new THREE.Mesh(gauntletClockGeometry, gauntletClockMaterial);
        rightGauntletClock.position.set(0.45, 0.3, 0.55);
        rightGauntletClock.rotation.x = Math.PI / 2;
        this.mesh.add(rightGauntletClock);

        // Belt with clock buckle
        const beltGeometry = new THREE.TorusGeometry(0.55, 0.04, 8, 24);
        const belt = new THREE.Mesh(beltGeometry, goldMaterial);
        belt.position.y = 0.6;
        belt.rotation.x = Math.PI / 2;
        this.mesh.add(belt);

        const buckleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16);
        const buckle = new THREE.Mesh(buckleGeometry, goldMaterial);
        buckle.position.set(0, 0.6, 0.55);
        buckle.rotation.x = Math.PI / 2;
        this.mesh.add(buckle);

        // Position the mesh
        this.mesh.position.copy(this.position);
        this.scene.add(this.mesh);
    }

    update(deltaTime, input, elapsedTime, enemies = null) {
        // V3: Store enemies reference for aim assist
        this.currentEnemies = enemies;
        // Handle dashing
        if (this.isDashing) {
            this.updateDash(deltaTime);
            // Still update sword during dash
            if (this.sword) {
                this.sword.update(deltaTime, elapsedTime);
            }
            return;
        }

        // Update dash cooldown
        if (this.dashCooldownTimer > 0) {
            this.dashCooldownTimer -= deltaTime;
        }

        // Check if currently in attack recovery (can't move during attack)
        this.isAttacking = this.sword && this.sword.isAttacking;

        // Get movement input
        const moveInput = this.getMovementInput(input);

        // Check for sprint (can't sprint while attacking)
        this.isSprinting = (input.isKeyDown('ShiftLeft') || input.isKeyDown('ShiftRight')) && !this.isAttacking;

        // Check stamina for sprint
        if (this.isSprinting && this.stamina <= 0) {
            this.isSprinting = false;
        }

        // Handle attack inputs (V2 - weapon-specific)
        if (input.mouseButtons.left) {
            if (this.currentWeapon === 'pistol') {
                // Pistol fires on left click (V3: with aim assist)
                this.firePistol(this.currentEnemies);
            } else if (this.sword) {
                // Blade and Scythe use melee
                this.sword.startLightAttack();
            }
        }
        // V4 INFINITE - Right click is now SHIELD (not heavy attack)
        if (input.mouseButtons.right) {
            if (this.currentWeapon === 'pistol') {
                // Pistol reload on right click
                this.reloadPistol();
            } else if (this.shieldSystem) {
                // Shield block for melee weapons
                if (!this.isBlocking()) {
                    this.startBlocking();
                }
            } else if (this.sword) {
                // Fallback: heavy attack if no shield system
                this.sword.startHeavyAttack();
            }
        } else {
            // Release shield when right mouse released
            if (this.shieldSystem && this.isBlocking()) {
                this.stopBlocking();
            }
        }

        // Calculate target speed (reduced during attack)
        let targetSpeed = 0;
        if (moveInput.length() > 0 && !this.isAttacking) {
            targetSpeed = CONFIG.playerSpeed;
            if (this.isSprinting) {
                targetSpeed *= CONFIG.sprintMultiplier;
            }
        } else if (moveInput.length() > 0 && this.isAttacking) {
            // Can still move slowly during attack
            targetSpeed = CONFIG.playerSpeed * 0.3;
        }

        // Smooth speed transition
        const acceleration = targetSpeed > this.currentSpeed ? 50 : 80;
        this.currentSpeed = THREE.MathUtils.lerp(
            this.currentSpeed,
            targetSpeed,
            Math.min(1, acceleration * deltaTime)
        );

        // Apply movement
        if (moveInput.length() > 0.01) {
            const moveDir = moveInput.normalize();
            this.velocity.x = moveDir.x * this.currentSpeed;
            this.velocity.z = moveDir.z * this.currentSpeed;

            // Update target rotation to face movement direction (slower during attack)
            if (!this.isAttacking) {
                this.targetRotation = Math.atan2(moveDir.x, moveDir.z);
            }
        } else {
            this.velocity.x *= 0.8;
            this.velocity.z *= 0.8;
        }

        // Smooth rotation
        let rotationDiff = this.targetRotation - this.rotation;
        while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
        while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
        this.rotation += rotationDiff * Math.min(1, 15 * deltaTime);

        // Apply velocity to position
        this.position.x += this.velocity.x * deltaTime;
        this.position.z += this.velocity.z * deltaTime;

        // Apply external forces (boss pull effects, etc.)
        if (this.externalForce.lengthSq() > 0.001) {
            this.position.x += this.externalForce.x * deltaTime;
            this.position.z += this.externalForce.z * deltaTime;
            // Decay external force
            this.externalForce.multiplyScalar(0.95);
        }

        // Arena boundary check
        const distFromCenter = Math.sqrt(
            this.position.x * this.position.x +
            this.position.z * this.position.z
        );

        if (distFromCenter > CONFIG.arenaRadius - 1) {
            const angle = Math.atan2(this.position.z, this.position.x);
            this.position.x = Math.cos(angle) * (CONFIG.arenaRadius - 1);
            this.position.z = Math.sin(angle) * (CONFIG.arenaRadius - 1);
        }

        // Stamina management (V2 - difficulty adjusted)
        const staminaRegenMult = getStaminaRegenMultiplier();
        if (this.isSprinting && this.currentSpeed > CONFIG.playerSpeed) {
            this.stamina -= 20 * deltaTime;
            this.staminaRegenTimer = CONFIG.staminaRegenDelay;
            if (this.stamina < 0) this.stamina = 0;
        } else {
            if (this.staminaRegenTimer > 0) {
                this.staminaRegenTimer -= deltaTime;
            } else {
                this.stamina += CONFIG.staminaRegen * staminaRegenMult * deltaTime;
                if (this.stamina > CONFIG.maxStamina) {
                    this.stamina = CONFIG.maxStamina;
                }
            }
        }

        // Health Regeneration V2
        this.updateHealthRegen(deltaTime);

        // Handle dash/strafe input (can dash during attack recovery to cancel it)
        if ((input.isKeyDown('Space')) && this.dashCooldownTimer <= 0 && this.stamina >= CONFIG.dashStaminaCost) {
            // Dash cancels attack
            if (this.sword && this.sword.isAttacking && this.sword.attackPhase === 'recovery') {
                this.sword.endAttack();
                // Extra stamina cost for dash cancel
                this.stamina -= 10;
            }
            if (!this.sword || !this.sword.isAttacking || this.sword.attackPhase === 'recovery') {
                // Determine strafe direction based on A/D keys
                let strafeDir = 0;
                if (input.isKeyDown('KeyA') || input.isKeyDown('ArrowLeft')) {
                    strafeDir = -1; // Strafe left
                } else if (input.isKeyDown('KeyD') || input.isKeyDown('ArrowRight')) {
                    strafeDir = 1; // Strafe right
                }
                this.startDash(moveInput, strafeDir);
            }
        }

        // Update sword
        if (this.sword) {
            this.sword.update(deltaTime, elapsedTime);
        }

        // Update ability cooldowns
        this.updateAbilityCooldowns(deltaTime);

        // Update Temporal Echo
        this.updateTemporalEcho(deltaTime);

        // Update ability effects
        this.updateAbilityEffects(deltaTime);

        // Handle ability inputs (Q, E, R)
        this.handleAbilityInput(input);

        // Update mesh position and rotation
        this.updateMesh(deltaTime);

        // V2.7 Update dash afterimages
        this.updateAfterimages(deltaTime);

        // Update HUD
        this.updateHUD();
    }

    updateAbilityCooldowns(deltaTime) {
        if (this.timeFractureCooldown > 0) {
            this.timeFractureCooldown -= deltaTime;
        }
        if (this.temporalEchoCooldown > 0) {
            this.temporalEchoCooldown -= deltaTime;
        }
        if (this.chronostasisCooldown > 0) {
            this.chronostasisCooldown -= deltaTime;
        }
    }

    // V3: Pillar collision detection - prevents walking through pillars
    applyPillarCollision(pillars) {
        if (!pillars || pillars.length === 0) return;

        const PILLAR_RADIUS = 1.5;  // Base is 2.5x2.5, so ~1.25 + padding
        const PLAYER_RADIUS = 0.5;
        const COLLISION_DIST = PILLAR_RADIUS + PLAYER_RADIUS;

        for (const pillar of pillars) {
            // Calculate XZ distance to pillar center
            const dx = this.position.x - pillar.position.x;
            const dz = this.position.z - pillar.position.z;
            const distance = Math.sqrt(dx * dx + dz * dz);

            if (distance < COLLISION_DIST && distance > 0.001) {
                // Push player out of pillar
                const pushDir = { x: dx / distance, z: dz / distance };
                const pushAmount = COLLISION_DIST - distance;

                this.position.x += pushDir.x * pushAmount;
                this.position.z += pushDir.z * pushAmount;

                // Update mesh position
                this.mesh.position.x = this.position.x;
                this.mesh.position.z = this.position.z;
            }
        }
    }

    // V2 Health Regeneration System
    updateHealthRegen(deltaTime) {
        const regenRate = getHealthRegenRate();

        // No regen if rate is 0 (hard/nightmare modes)
        if (regenRate <= 0) {
            this.isRegenerating = false;
            return;
        }

        // Track if we took damage this frame
        if (this.health < this.lastHealth) {
            this.outOfCombatTimer = 0;
            this.isRegenerating = false;
        }
        this.lastHealth = this.health;

        // Update out of combat timer
        this.outOfCombatTimer += deltaTime;

        // Start regenerating after delay
        if (this.outOfCombatTimer >= CONFIG.regenDelay && this.health < this.maxHealth) {
            this.isRegenerating = true;

            // Regenerate health
            this.health += regenRate * deltaTime;
            if (this.health > this.maxHealth) {
                this.health = this.maxHealth;
            }

            // Regen pulse timer for visual effect
            this.regenPulseTimer += deltaTime;
        } else {
            this.isRegenerating = false;
            this.regenPulseTimer = 0;
        }
    }

    handleAbilityInput(input) {
        // Q - Time Fracture (AoE burst)
        const qDown = input.isKeyDown('KeyQ');
        if (qDown && !this.keyPressed.q) {
            this.keyPressed.q = true;
            if (this.canUseTimeFracture()) {
                this.useTimeFracture();
            }
        } else if (!qDown) {
            this.keyPressed.q = false;
        }

        // E - Temporal Echo (teleport back)
        const eDown = input.isKeyDown('KeyE');
        if (eDown && !this.keyPressed.e) {
            this.keyPressed.e = true;
            if (this.canUseTemporalEcho()) {
                this.useTemporalEcho();
            }
        } else if (!eDown) {
            this.keyPressed.e = false;
        }

        // R - Chronostasis (freeze enemies) - handled in Game class, but we check here
        const rDown = input.isKeyDown('KeyR');
        if (rDown && !this.keyPressed.r) {
            this.keyPressed.r = true;
            if (this.canUseChronostasis()) {
                // Signal to game that we want to use Chronostasis
                this.wantsChronostasis = true;
            }
        } else if (!rDown) {
            this.keyPressed.r = false;
        }
    }

    // Time Fracture (Q) - AoE damage burst
    canUseTimeFracture() {
        return this.timeFractureCooldown <= 0 &&
               this.temporalCharge >= CONFIG.timeFractureCost;
    }

    useTimeFracture() {
        this.temporalCharge -= CONFIG.timeFractureCost;
        this.timeFractureCooldown = CONFIG.timeFractureCooldown;

        // Play Time Fracture sound
        audioManager.playTimeFracture();

        // Create visual effect - expanding ring
        this.createTimeFractureEffect();

        // Return hit info for Game to process damage
        return {
            type: 'timeFracture',
            position: this.position.clone(),
            radius: CONFIG.timeFractureRadius,
            damage: CONFIG.timeFractureDamage
        };
    }

    // Flag to track if Time Fracture damage was processed (prevents hitstop loop)
    markTimeFractureProcessed() {
        for (const effect of this.abilityEffects) {
            if (effect.type === 'timeFracture' && !effect.damageProcessed) {
                effect.damageProcessed = true;
            }
        }
    }

    createTimeFractureEffect() {
        // Create expanding ring effect
        const ringGeometry = new THREE.RingGeometry(0.5, 1, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.copy(this.position);
        ring.position.y = 0.1;
        ring.rotation.x = -Math.PI / 2;
        this.scene.add(ring);

        // Inner burst
        const burstGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const burstMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.8
        });
        const burst = new THREE.Mesh(burstGeometry, burstMaterial);
        burst.position.copy(this.position);
        burst.position.y = 1;
        this.scene.add(burst);

        // Add particles
        const particleCount = 30;
        const particles = [];
        for (let i = 0; i < particleCount; i++) {
            const pGeom = new THREE.SphereGeometry(0.1, 8, 8);
            const pMat = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0x7eb8da : 0xd4af37,
                transparent: true,
                opacity: 1
            });
            const p = new THREE.Mesh(pGeom, pMat);
            const angle = (i / particleCount) * Math.PI * 2;
            p.position.copy(this.position);
            p.position.y = 0.5 + Math.random();
            p.userData = {
                velocity: new THREE.Vector3(
                    Math.cos(angle) * (3 + Math.random() * 2),
                    1 + Math.random() * 2,
                    Math.sin(angle) * (3 + Math.random() * 2)
                )
            };
            this.scene.add(p);
            particles.push(p);
        }

        this.abilityEffects.push({
            type: 'timeFracture',
            timer: 0,
            duration: 0.5,
            ring: ring,
            burst: burst,
            particles: particles
        });
    }

    // Temporal Echo (E) - Leave ghost, teleport back
    canUseTemporalEcho() {
        return this.temporalEchoCooldown <= 0 &&
               this.temporalCharge >= CONFIG.temporalEchoCost &&
               !this.temporalEchoActive;
    }

    useTemporalEcho() {
        this.temporalCharge -= CONFIG.temporalEchoCost;
        this.temporalEchoCooldown = CONFIG.temporalEchoCooldown;
        this.temporalEchoActive = true;
        this.temporalEchoTimer = CONFIG.temporalEchoDuration;
        this.temporalEchoPosition = this.position.clone();

        // Play Temporal Echo sound
        audioManager.playTemporalEcho();

        // Create ghost mesh at current position
        this.createTemporalEchoGhost();
    }

    createTemporalEchoGhost() {
        // Create a ghostly copy of the player
        this.temporalEchoGhost = new THREE.Group();

        // Simple ghost representation - translucent silhouette
        const ghostMaterial = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 0.5
        });

        // Body
        const bodyGeom = new THREE.CylinderGeometry(0.3, 0.6, 1.4, 8);
        const body = new THREE.Mesh(bodyGeom, ghostMaterial);
        body.position.y = 0.7;
        this.temporalEchoGhost.add(body);

        // Hood
        const hoodGeom = new THREE.SphereGeometry(0.35, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const hood = new THREE.Mesh(hoodGeom, ghostMaterial);
        hood.position.y = 1.6;
        hood.scale.set(1, 1.2, 1);
        this.temporalEchoGhost.add(hood);

        // Pulsing light
        const light = new THREE.PointLight(0x7eb8da, 1, 5);
        light.position.y = 1;
        this.temporalEchoGhost.add(light);
        this.temporalEchoGhost.userData.light = light;

        this.temporalEchoGhost.position.copy(this.temporalEchoPosition);
        this.temporalEchoGhost.rotation.y = this.rotation;
        this.scene.add(this.temporalEchoGhost);
    }

    updateTemporalEcho(deltaTime) {
        if (!this.temporalEchoActive) return;

        this.temporalEchoTimer -= deltaTime;

        // Animate ghost
        if (this.temporalEchoGhost) {
            const pulse = Math.sin(this.temporalEchoTimer * 10) * 0.3 + 0.5;
            this.temporalEchoGhost.traverse(child => {
                if (child.material) {
                    child.material.opacity = pulse;
                }
            });
            if (this.temporalEchoGhost.userData.light) {
                this.temporalEchoGhost.userData.light.intensity = pulse * 2;
            }
        }

        // Timer expired - teleport back
        if (this.temporalEchoTimer <= 0) {
            this.triggerTemporalEchoReturn();
        }
    }

    triggerTemporalEchoReturn() {
        if (!this.temporalEchoActive) return;

        // Play echo return sound
        audioManager.playEchoReturn();

        // Create flash effect at current position
        this.createTeleportFlash(this.position.clone());

        // Teleport to saved position
        this.position.copy(this.temporalEchoPosition);

        // Create arrival flash
        this.createTeleportFlash(this.position.clone());

        // Clean up ghost
        if (this.temporalEchoGhost) {
            this.scene.remove(this.temporalEchoGhost);
            this.temporalEchoGhost = null;
        }

        this.temporalEchoActive = false;
        this.temporalEchoPosition = null;
    }

    createTeleportFlash(position) {
        const flashGeom = new THREE.SphereGeometry(1, 16, 16);
        const flashMat = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 1
        });
        const flash = new THREE.Mesh(flashGeom, flashMat);
        flash.position.copy(position);
        flash.position.y = 1;
        this.scene.add(flash);

        this.abilityEffects.push({
            type: 'teleportFlash',
            timer: 0,
            duration: 0.3,
            mesh: flash
        });
    }

    // Chronostasis (R) - Freeze enemies (handled mostly in Game class)
    canUseChronostasis() {
        return this.chronostasisCooldown <= 0 &&
               this.temporalCharge >= CONFIG.chronostasisCost;
    }

    useChronostasis() {
        this.temporalCharge -= CONFIG.chronostasisCost;
        this.chronostasisCooldown = CONFIG.chronostasisCooldown;

        // Play Chronostasis sound
        audioManager.playChronostasis();

        // Create visual effect
        this.createChronostasisEffect();

        return {
            type: 'chronostasis',
            duration: CONFIG.chronostasisDuration
        };
    }

    createChronostasisEffect() {
        // Create a time-freeze ripple effect
        const rippleCount = 3;
        const ripples = [];

        for (let i = 0; i < rippleCount; i++) {
            const ringGeom = new THREE.RingGeometry(0.5, 1.5, 64);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xd4af37,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.position.copy(this.position);
            ring.position.y = 0.5;
            ring.rotation.x = -Math.PI / 2;
            ring.scale.setScalar(0.1);
            ring.userData.delay = i * 0.1;
            ring.userData.started = false;
            this.scene.add(ring);
            ripples.push(ring);
        }

        this.abilityEffects.push({
            type: 'chronostasis',
            timer: 0,
            duration: 1.0,
            ripples: ripples
        });
    }

    updateAbilityEffects(deltaTime) {
        for (let i = this.abilityEffects.length - 1; i >= 0; i--) {
            const effect = this.abilityEffects[i];
            effect.timer += deltaTime;
            const progress = effect.timer / effect.duration;

            if (effect.type === 'timeFracture') {
                // Expand ring
                const scale = 1 + progress * CONFIG.timeFractureRadius * 2;
                effect.ring.scale.set(scale, scale, 1);
                effect.ring.material.opacity = 1 - progress;

                // Shrink and fade burst
                effect.burst.scale.setScalar(1 + progress * 2);
                effect.burst.material.opacity = 0.8 * (1 - progress);

                // Update particles
                for (const p of effect.particles) {
                    p.position.x += p.userData.velocity.x * deltaTime;
                    p.position.y += p.userData.velocity.y * deltaTime;
                    p.position.z += p.userData.velocity.z * deltaTime;
                    p.userData.velocity.y -= 10 * deltaTime; // gravity
                    p.material.opacity = 1 - progress;
                }

                if (progress >= 1) {
                    this.scene.remove(effect.ring);
                    this.scene.remove(effect.burst);
                    for (const p of effect.particles) {
                        this.scene.remove(p);
                    }
                    this.abilityEffects.splice(i, 1);
                }
            } else if (effect.type === 'teleportFlash') {
                effect.mesh.scale.setScalar(1 + progress * 3);
                effect.mesh.material.opacity = 1 - progress;

                if (progress >= 1) {
                    this.scene.remove(effect.mesh);
                    this.abilityEffects.splice(i, 1);
                }
            } else if (effect.type === 'chronostasis') {
                for (const ripple of effect.ripples) {
                    const rippleProgress = (effect.timer - ripple.userData.delay) / (effect.duration - ripple.userData.delay);
                    if (rippleProgress > 0 && rippleProgress < 1) {
                        ripple.userData.started = true;
                        const scale = 1 + rippleProgress * 50;
                        ripple.scale.setScalar(scale);
                        ripple.material.opacity = 0.8 * (1 - rippleProgress);
                    }
                }

                if (progress >= 1) {
                    for (const ripple of effect.ripples) {
                        this.scene.remove(ripple);
                    }
                    this.abilityEffects.splice(i, 1);
                }
            }
        }
    }

    getMovementInput(input) {
        const moveInput = new THREE.Vector3(0, 0, 0);

        // V2 - Get camera-relative directions using camera's yaw angle
        // The camera orbits around the player, so we use its yaw for direction
        const cameraAngle = game.cameraYaw;

        // Calculate forward and right vectors based on camera angle
        // Forward is the direction the camera is facing (into the screen from camera's POV)
        const forwardX = -Math.sin(cameraAngle);
        const forwardZ = -Math.cos(cameraAngle);

        // Right is perpendicular to forward
        const rightX = Math.cos(cameraAngle);
        const rightZ = -Math.sin(cameraAngle);

        // Accumulate input
        if (input.isKeyDown('KeyW') || input.isKeyDown('ArrowUp')) {
            moveInput.x += forwardX;
            moveInput.z += forwardZ;
        }
        if (input.isKeyDown('KeyS') || input.isKeyDown('ArrowDown')) {
            moveInput.x -= forwardX;
            moveInput.z -= forwardZ;
        }
        if (input.isKeyDown('KeyA') || input.isKeyDown('ArrowLeft')) {
            moveInput.x -= rightX;
            moveInput.z -= rightZ;
        }
        if (input.isKeyDown('KeyD') || input.isKeyDown('ArrowRight')) {
            moveInput.x += rightX;
            moveInput.z += rightZ;
        }

        return moveInput;
    }

    startDash(moveInput, strafeDirection = 0) {
        this.isDashing = true;
        this.dashTimer = CONFIG.dashDuration;
        this.dashCooldownTimer = CONFIG.dashCooldown;
        this.stamina -= CONFIG.dashStaminaCost;
        this.staminaRegenTimer = CONFIG.staminaRegenDelay;

        // Clear external force (break free from boss pull effects)
        this.externalForce.set(0, 0, 0);

        // Space = side strafe based on A/D input (or right by default)
        // strafeDirection: -1 = left (A), 1 = right (D), 0 = auto (right)
        const cameraAngle = game.cameraYaw || 0;
        const rightX = Math.cos(cameraAngle);
        const rightZ = -Math.sin(cameraAngle);

        if (strafeDirection !== 0) {
            // Strafe in the specified direction
            this.dashDirection = new THREE.Vector3(
                rightX * strafeDirection,
                0,
                rightZ * strafeDirection
            ).normalize();
        } else if (moveInput.length() > 0.01) {
            // If moving forward/back without A/D, strafe right by default
            this.dashDirection = new THREE.Vector3(rightX, 0, rightZ).normalize();
        } else {
            // No input = strafe right
            this.dashDirection = new THREE.Vector3(rightX, 0, rightZ).normalize();
        }

        // Play dash sound
        audioManager.playDash();
    }

    updateDash(deltaTime) {
        this.dashTimer -= deltaTime;

        // V2.7 Spawn afterimage every 0.04 seconds during dash
        this.dashAfterimageTimer -= deltaTime;
        if (this.dashAfterimageTimer <= 0) {
            this.spawnDashAfterimage();
            this.dashAfterimageTimer = 0.04;
        }

        // Move in dash direction
        const dashSpeed = CONFIG.dashDistance / CONFIG.dashDuration;
        this.position.x += this.dashDirection.x * dashSpeed * deltaTime;
        this.position.z += this.dashDirection.z * dashSpeed * deltaTime;

        // Arena boundary check during dash
        const distFromCenter = Math.sqrt(
            this.position.x * this.position.x +
            this.position.z * this.position.z
        );

        if (distFromCenter > CONFIG.arenaRadius - 1) {
            const angle = Math.atan2(this.position.z, this.position.x);
            this.position.x = Math.cos(angle) * (CONFIG.arenaRadius - 1);
            this.position.z = Math.sin(angle) * (CONFIG.arenaRadius - 1);
        }

        // Update mesh with dash effect
        this.mesh.position.copy(this.position);

        // Make player semi-transparent during dash
        this.mesh.traverse((child) => {
            if (child.isMesh && child.material) {
                child.material.transparent = true;
                child.material.opacity = 0.5;
            }
        });

        // End dash
        if (this.dashTimer <= 0) {
            this.isDashing = false;
            this.dashAfterimageTimer = 0;
            // Restore opacity
            this.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.opacity = 1;
                }
            });
        }
    }

    // V2.7 Spawn a dash afterimage
    spawnDashAfterimage() {
        const afterimageMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a90b8,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });

        const afterimage = new THREE.Group();

        // Simple silhouette
        const bodyGeom = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
        const body = new THREE.Mesh(bodyGeom, afterimageMaterial);
        body.position.y = 0.8;
        afterimage.add(body);

        const headGeom = new THREE.SphereGeometry(0.25, 8, 8);
        const head = new THREE.Mesh(headGeom, afterimageMaterial);
        head.position.y = 1.8;
        afterimage.add(head);

        afterimage.position.copy(this.position);
        afterimage.rotation.y = this.rotation;
        afterimage.userData.timer = 0.2; // Fade out time

        this.dashAfterimages.push(afterimage);
        this.scene.add(afterimage);
    }

    // V2.7 Update afterimages
    updateAfterimages(deltaTime) {
        for (let i = this.dashAfterimages.length - 1; i >= 0; i--) {
            const afterimage = this.dashAfterimages[i];
            afterimage.userData.timer -= deltaTime;

            // Fade out
            const opacity = Math.max(0, afterimage.userData.timer / 0.2) * 0.4;
            afterimage.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material.opacity = opacity;
                }
            });

            // Remove if faded
            if (afterimage.userData.timer <= 0) {
                this.scene.remove(afterimage);
                afterimage.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                this.dashAfterimages.splice(i, 1);
            }
        }
    }

    updateMesh(deltaTime) {
        // Position
        this.mesh.position.copy(this.position);

        // Rotation
        this.mesh.rotation.y = this.rotation;

        // Bobbing animation when moving
        if (this.currentSpeed > 1) {
            const prevStepPhase = Math.floor(this.stepTimer / Math.PI);
            this.stepTimer += deltaTime * this.currentSpeed * 0.5;
            const newStepPhase = Math.floor(this.stepTimer / Math.PI);

            // Play footstep sound on each step
            if (newStepPhase > prevStepPhase) {
                audioManager.playFootstep();
            }

            this.bobOffset = Math.sin(this.stepTimer * 2) * 0.15; // Increased from 0.05
            this.mesh.position.y = this.bobOffset;

            // Body sway when moving
            this.bodyParts.body.rotation.z = Math.sin(this.stepTimer) * 0.06; // Increased from 0.02
        } else {
            this.bobOffset *= 0.9;
            this.mesh.position.y = this.bobOffset;
        }

        // Eye glow intensity based on charge
        const chargeRatio = this.temporalCharge / CONFIG.maxCharge;
        this.bodyParts.eyeGlow.intensity = 0.3 + chargeRatio * 0.7;

        // Eye color based on charge
        const eyeColor = new THREE.Color();
        if (chargeRatio < 0.5) {
            eyeColor.setHex(0x7eb8da);
        } else if (chargeRatio < 0.75) {
            eyeColor.lerpColors(new THREE.Color(0x7eb8da), new THREE.Color(0xffffff), (chargeRatio - 0.5) * 4);
        } else {
            eyeColor.lerpColors(new THREE.Color(0xffffff), new THREE.Color(0xd4af37), (chargeRatio - 0.75) * 4);
        }
        this.bodyParts.leftEye.material.color = eyeColor;
        this.bodyParts.rightEye.material.color = eyeColor;
        this.bodyParts.eyeGlow.color = eyeColor;
    }

    updateHUD() {
        // V2 - Use player's maxHealth for correct percentage
        const healthPercent = (this.health / this.maxHealth) * 100;
        const healthBar = document.getElementById('health-fill');
        healthBar.style.width = `${healthPercent}%`;

        // V2 HUD - Update health value display
        document.getElementById('health-value').textContent = Math.ceil(this.health);

        // V2 - Health bar states (regenerating, critical)
        healthBar.classList.remove('regenerating', 'critical');
        if (healthPercent <= 25) {
            healthBar.classList.add('critical');
        } else if (this.isRegenerating) {
            healthBar.classList.add('regenerating');
        }

        // Stamina
        const staminaPercent = (this.stamina / CONFIG.maxStamina) * 100;
        document.getElementById('stamina-fill').style.width = `${staminaPercent}%`;
        document.getElementById('stamina-value').textContent = Math.ceil(this.stamina);

        // Temporal Charge
        const chargePercent = (this.temporalCharge / CONFIG.maxCharge) * 100;
        const chargeFill = document.getElementById('charge-fill');
        chargeFill.style.width = `${chargePercent}%`;

        // V2 - Charge bar full state
        if (this.temporalCharge >= CONFIG.maxCharge) {
            chargeFill.classList.add('full');
        } else {
            chargeFill.classList.remove('full');
        }
    }

    takeDamage(amount) {
        // Damage already has difficulty multiplier applied from enemy
        this.health -= amount;
        if (this.health < 0) this.health = 0;

        // V2 - Reset health regen timer
        this.outOfCombatTimer = 0;
        this.isRegenerating = false;

        // V2 Nightmare mode - Execute threshold
        if (currentDifficulty === 'nightmare' &&
            this.health > 0 &&
            this.health < this.maxHealth * CONFIG.difficulty.nightmare.executeThreshold) {
            // One-shot if below 20% HP
            this.health = 0;
        }
    }

    heal(amount) {
        this.health += amount;
        if (this.health > this.maxHealth) this.health = this.maxHealth;
    }

    addCharge(amount) {
        // V2 - Apply difficulty charge multiplier
        const adjustedCharge = amount * getChargeGainMultiplier();
        this.temporalCharge += adjustedCharge;
        if (this.temporalCharge > CONFIG.maxCharge) {
            this.temporalCharge = CONFIG.maxCharge;
        }
    }

    applySlowEffect(slowPercent, duration) {
        // Apply slow effect from Ice Chronophage
        this.slowMultiplier = slowPercent;
        this.slowDuration = duration;

        // Clear existing slow timer
        if (this.slowTimer) clearTimeout(this.slowTimer);

        // Remove slow after duration
        this.slowTimer = setTimeout(() => {
            this.slowMultiplier = 1.0;
        }, duration * 1000);
    }

    // â”€â”€â”€ V4 INFINITE - SHIELD METHODS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    startBlocking() {
        if (this.shieldSystem) {
            return this.shieldSystem.startBlocking();
        }
        return false;
    }

    stopBlocking() {
        if (this.shieldSystem) {
            this.shieldSystem.stopBlocking();
        }
    }

    isBlocking() {
        return this.shieldSystem && this.shieldSystem.isBlocking;
    }

    canBlock() {
        return this.shieldSystem && this.shieldSystem.canBlock();
    }

    // Called when player takes damage - routes through shield if blocking
    absorbDamageWithShield(damage, attacker = null) {
        if (this.shieldSystem && this.shieldSystem.isBlocking) {
            const result = this.shieldSystem.absorbDamage(damage, attacker);
            if (result.blocked) {
                // If perfect block, trigger counter bonus
                if (result.isPerfect) {
                    this.triggerPerfectBlockBonus();
                }
                return result.damage; // Return reduced damage
            }
        }
        return damage; // Full damage if not blocking
    }

    triggerPerfectBlockBonus() {
        // Add temporal charge on perfect block
        this.addCharge(15);

        // Slight time slowdown for counter opportunity
        if (window.game && window.game.screenEffects) {
            window.game.screenEffects.slowMotion(0.3, 0.3);
        }
    }

    isInCounterWindow() {
        return this.shieldSystem && this.shieldSystem.isInCounterWindow();
    }

    updateShield(deltaTime) {
        if (this.shieldSystem) {
            try {
                this.shieldSystem.update(deltaTime);
            } catch (e) {
                console.error('Shield update error:', e);
            }
        }
    }

    // â”€â”€â”€ V4 INFINITE - EQUIPMENT METHODS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    onEquipmentChange(slot, item, previousItem) {
        // Handle special equipment changes
        if (slot === 'shield' && this.shieldSystem) {
            this.shieldSystem.equipShield(item);
        }

        // Recalculate player stats from equipment
        this.applyEquipmentStats();

        // Return previous item to inventory if exists
        if (previousItem && this.inventory) {
            this.inventory.addItem(previousItem);
        }
    }

    applyEquipmentStats() {
        if (!this.equipment) return;

        // Get bonus stats from equipment
        const bonuses = this.equipment.bonusStats;

        // Apply health bonus (additive)
        const baseHealth = getPlayerMaxHealth();
        this.maxHealth = baseHealth + (bonuses.health || 0);
        if (this.health > this.maxHealth) this.health = this.maxHealth;

        // Other stats are applied dynamically when used
        // (damage in attack, moveSpeed in movement, etc.)
    }

    getEquipmentStat(statName) {
        return this.equipment ? this.equipment.getStat(statName) : 0;
    }

    equipItem(item, slot = null) {
        if (!this.equipment) return false;
        const previousItem = this.equipment.equip(item, slot);
        return previousItem !== false;
    }

    unequipItem(slot) {
        if (!this.equipment) return null;
        const item = this.equipment.unequip(slot);
        if (item && this.inventory) {
            this.inventory.addItem(item);
        }
        return item;
    }

    pickupItem(item) {
        if (!this.inventory) return false;
        return this.inventory.addItem(item);
    }

    // Get effective damage (base + equipment bonuses)
    getEffectiveDamage(baseDamage) {
        const damageBonus = this.getEquipmentStat('damage');
        return Math.floor(baseDamage * (1 + damageBonus / 100));
    }

    // Get effective move speed
    getEffectiveMoveSpeed() {
        const baseSpeed = CONFIG.playerSpeed;
        const speedBonus = this.getEquipmentStat('moveSpeed');
        return baseSpeed * (1 + speedBonus / 100);
    }

    // Get effective attack speed multiplier
    getAttackSpeedMultiplier() {
        const speedBonus = this.getEquipmentStat('attackSpeed');
        return 1 + speedBonus / 100;
    }

    // Get effective crit chance
    getCritChance() {
        return this.getEquipmentStat('critChance') / 100;
    }

    // Get effective crit damage multiplier
    getCritDamageMultiplier() {
        return 1.5 + (this.getEquipmentStat('critDamage') / 100);
    }

    // Calculate if attack is critical and return damage
    calculateCriticalHit(baseDamage) {
        const critChance = this.getCritChance();
        const isCrit = Math.random() < critChance;

        if (isCrit) {
            const critDamage = Math.floor(baseDamage * this.getCritDamageMultiplier());
            return { damage: critDamage, isCrit: true };
        }
        return { damage: baseDamage, isCrit: false };
    }
}

// â”€â”€â”€ MAIN GAME CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Game {
    constructor() {
        this.state = GameState.MENU;
        this.canvas = document.getElementById('game-canvas');
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.clock = new THREE.Clock();
        this.deltaTime = 0;
        this.elapsedTime = 0;
        this.gameTime = 0;

        // Arena reference
        this.arena = null;

        // Player
        this.player = null;
        this.input = null;

        // Camera control V2 - Proper third-person orbit camera
        this.cameraYaw = 0;
        this.cameraPitch = CONFIG.cameraDefaultPitch;
        this.cameraDistance = CONFIG.cameraDistance;
        this.cameraTarget = new THREE.Vector3();
        this.cameraActualPosition = new THREE.Vector3();
        this.cameraShakeOffset = new THREE.Vector3();
        this.cameraCombatDistance = CONFIG.cameraDistance; // Pulls back during combat

        // Enemies
        this.enemies = [];
        this.hitFrame = 0; // For tracking which attack frame hits

        // V3: Health drops
        this.healthDrops = [];

        // V4: Gold coin drops
        this.goldCoins = [];

        // V4: Boss treasure chest
        this.bossChest = null;
        this.awaitingChestOpen = false;

        // Combat stats
        this.combo = 0;
        this.comboTimer = 0;
        this.score = 0;

        // Statistics for game over screen
        this.totalKills = 0;
        this.maxCombo = 0;

        // High score (loaded from localStorage)
        this.highScore = this.loadHighScore();

        // Pause state
        this.isPaused = false;

        // Chronostasis state (freeze enemies)
        this.chronostasisActive = false;
        this.chronostasisTimer = 0;

        // Time Fracture damage queue
        this.pendingTimeFracture = null;

        // Wave system
        this.wave = 0;
        this.waveState = 'PREP';  // PREP, ACTIVE, COMPLETE, INTERMISSION
        this.waveTimer = 0;
        this.waveEnemiesSpawned = 0;
        this.waveEnemiesKilled = 0;
        this.waveEnemiesTotal = 0;
        this.spawnQueue = [];
        this.spawnTimer = 0;
        this.waveAnnouncement = null;

        // Screen effects
        this.screenEffects = new ScreenEffects();

        // V4: Visual Effects Manager (INSANE GRAPHICS)
        this.vfx = null; // Initialized after scene setup

        // V2.7 Hit sparks particle system
        this.hitSparks = [];

        // V2.8 Audio state
        this.heartbeatTimer = 0;

        // V6: Cached DOM elements for performance
        this.hudElements = {};

        // Initialize
        this.init();
    }

    init() {
        this.setupRenderer();
        this.setupScene();
        this.setupCamera();
        this.setupLighting();
        this.createArena();
        this.setupInput();
        this.setupEventListeners();
        this.setupPauseMenu();
        this.cacheHUDElements(); // V6: Cache DOM references
        this.animate();
    }

    // V6: Cache all HUD DOM elements to avoid per-frame getElementById calls
    cacheHUDElements() {
        this.hudElements = {
            hud: document.getElementById('hud'),
            crosshair: document.getElementById('crosshair'),
            timeDisplay: document.getElementById('time-display'),
            comboCount: document.getElementById('combo-count'),
            comboDisplay: document.querySelector('.combo-display'),
            scoreDisplay: document.getElementById('score-display'),
            abilityQ: document.getElementById('ability-q'),
            abilityQCooldown: document.getElementById('ability-q-cooldown'),
            abilityE: document.getElementById('ability-e'),
            abilityECooldown: document.getElementById('ability-e-cooldown'),
            abilityR: document.getElementById('ability-r'),
            abilityRCooldown: document.getElementById('ability-r-cooldown'),
            shieldFill: document.getElementById('shield-fill'),
            shieldValue: document.getElementById('shield-value'),
            goldDisplay: document.getElementById('gold-display'),
            finalScore: document.getElementById('final-score'),
            finalWave: document.getElementById('final-wave'),
            finalDifficulty: document.getElementById('final-difficulty'),
            statTime: document.getElementById('stat-time'),
            statKills: document.getElementById('stat-kills'),
            statMaxCombo: document.getElementById('stat-max-combo'),
            newHighScore: document.getElementById('new-high-score'),
            nightmareUnlock: document.getElementById('nightmare-unlock'),
            highScoreDisplay: document.getElementById('high-score-display'),
            highScoreValue: document.getElementById('high-score-value'),
            victoryScore: document.getElementById('victory-score'),
            victoryTime: document.getElementById('victory-time'),
            victoryKills: document.getElementById('victory-kills'),
            waveDisplay: document.getElementById('wave-display'),
            waveProgress: document.getElementById('wave-progress')
        };
    }

    setupInput() {
        this.input = new InputManager();
    }

    setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 0.8;
    }

    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x050510);
        this.scene.fog = new THREE.Fog(CONFIG.fogColor, CONFIG.fogNear, CONFIG.fogFar);

        // V4: Initialize VFX Manager
        this.vfx = new VFXManager(this.scene);

        // V4: Progressive sky colors based on wave
        this.skyColors = [
            new THREE.Color(0x050510), // Wave 1: Deep midnight blue
            new THREE.Color(0x0a1020), // Wave 2: Dark blue
            new THREE.Color(0x101530), // Wave 3: Navy
            new THREE.Color(0x151040), // Wave 4: Deep purple-blue
            new THREE.Color(0x200840), // Wave 5: Purple
            new THREE.Color(0x300850), // Wave 6: Deep magenta
            new THREE.Color(0x400830), // Wave 7: Dark crimson-purple
            new THREE.Color(0x500820), // Wave 8: Blood red-purple
            new THREE.Color(0x601010), // Wave 9: Dark crimson
            new THREE.Color(0x701515), // Wave 10+: Hellish red
        ];
        this.currentSkyColor = new THREE.Color(0x050510);
        this.targetSkyColor = new THREE.Color(0x050510);
    }

    // V4: Update sky color based on current wave
    updateSkyColor() {
        const waveIndex = Math.min(this.wave - 1, this.skyColors.length - 1);
        if (waveIndex >= 0) {
            this.targetSkyColor.copy(this.skyColors[waveIndex]);
        }
    }

    // V4: Smoothly transition sky color
    updateSkyTransition(deltaTime) {
        // Lerp current color toward target
        this.currentSkyColor.lerp(this.targetSkyColor, deltaTime * 0.5);
        this.scene.background.copy(this.currentSkyColor);

        // Also update fog color to match atmosphere
        const fogColor = this.currentSkyColor.clone().multiplyScalar(1.5);
        this.scene.fog.color.copy(fogColor);
    }

    setupCamera() {
        this.camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        // Initial camera position for menu view
        this.camera.position.set(0, 25, 45);
        this.camera.lookAt(0, 0, 0);
    }

    setupLighting() {
        // V6: Get graphics quality settings
        const shadowsEnabled = getGraphicsSetting('shadows');
        const shadowMapSize = getGraphicsSetting('shadowMapSize') || 1024;

        // Ambient light - deep blue for eerie atmosphere
        const ambientLight = new THREE.AmbientLight(0x1a2a4a, shadowsEnabled ? 0.4 : 0.6);
        this.scene.add(ambientLight);

        // Main directional light - moonlight feel
        const mainLight = new THREE.DirectionalLight(0x6688cc, 0.6);
        mainLight.position.set(10, 30, 10);

        // V6: Only enable shadows based on quality setting
        if (shadowsEnabled) {
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = shadowMapSize;
            mainLight.shadow.mapSize.height = shadowMapSize;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 100;
            mainLight.shadow.camera.left = -50;
            mainLight.shadow.camera.right = 50;
            mainLight.shadow.camera.top = 50;
            mainLight.shadow.camera.bottom = -50;
        } else {
            mainLight.castShadow = false;
            // V6: Disable shadow maps in renderer for low quality
            this.renderer.shadowMap.enabled = false;
        }
        this.scene.add(mainLight);

        // Point lights for golden temporal energy accents
        const goldLight1 = new THREE.PointLight(0xd4af37, 0.8, 30);
        goldLight1.position.set(20, 5, 0);
        this.scene.add(goldLight1);

        const goldLight2 = new THREE.PointLight(0xd4af37, 0.8, 30);
        goldLight2.position.set(-20, 5, 0);
        this.scene.add(goldLight2);

        const goldLight3 = new THREE.PointLight(0xd4af37, 0.6, 25);
        goldLight3.position.set(0, 5, 20);
        this.scene.add(goldLight3);

        const goldLight4 = new THREE.PointLight(0xd4af37, 0.6, 25);
        goldLight4.position.set(0, 5, -20);
        this.scene.add(goldLight4);

        // Center blue light from below
        const centerLight = new THREE.PointLight(0x4a90b8, 1.0, 40);
        centerLight.position.set(0, -2, 0);
        this.scene.add(centerLight);
    }

    createArena() {
        this.arena = new Arena(this.scene);
    }

    setupEventListeners() {
        // Window resize
        window.addEventListener('resize', () => this.onResize());

        // V2 Difficulty selection
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');
        const difficultyDesc = document.getElementById('difficulty-desc');
        const difficultyDescriptions = {
            easy: 'Relaxed experience. More health, slower enemies, higher regen.',
            normal: 'Standard challenge. Balanced for most players.',
            hard: 'Punishing combat. Faster enemies, less forgiveness.',
            nightmare: 'True suffering. One mistake can be fatal. Execute threshold active.'
        };

        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent start-screen click
                const diff = btn.dataset.difficulty;

                // Check if nightmare is locked
                if (diff === 'nightmare' && !nightmareUnlocked) {
                    return;
                }

                // Update selection
                difficultyBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                currentDifficulty = diff;
                difficultyDesc.textContent = difficultyDescriptions[diff];
            });

            // Hover descriptions
            btn.addEventListener('mouseenter', () => {
                const diff = btn.dataset.difficulty;
                if (diff === 'nightmare' && !nightmareUnlocked) {
                    difficultyDesc.textContent = 'ðŸ”’ Complete the game on Hard to unlock.';
                } else {
                    difficultyDesc.textContent = difficultyDescriptions[diff];
                }
            });

            btn.addEventListener('mouseleave', () => {
                difficultyDesc.textContent = difficultyDescriptions[currentDifficulty];
            });
        });

        // Check for nightmare unlock (stored in localStorage)
        if (localStorage.getItem('chronophage_nightmare_unlocked') === 'true') {
            nightmareUnlocked = true;
            const nightmareBtn = document.querySelector('.difficulty-btn.nightmare');
            if (nightmareBtn) {
                nightmareBtn.classList.remove('locked');
                nightmareBtn.textContent = 'NIGHTMARE';
                nightmareBtn.title = '';
            }
        }

        // V6: Graphics quality selection
        const graphicsBtns = document.querySelectorAll('.graphics-btn');
        graphicsBtns.forEach(btn => {
            // Set initial selection from saved/default quality
            if (btn.dataset.quality === currentGraphicsQuality) {
                graphicsBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            }

            btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const quality = btn.dataset.quality;
                setGraphicsQuality(quality);
                graphicsBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            });
        });

        // Start menu music on first click anywhere on the page
        let menuMusicStarted = false;
        const startMenuMusicOnce = async () => {
            if (!menuMusicStarted) {
                menuMusicStarted = true;
                await audioManager.initMenuMusic();
            }
        };

        // Start menu music on ANY click on the document (browsers require click for audio)
        document.addEventListener('click', startMenuMusicOnce, { once: true });

        // Start game when clicking start screen (not on difficulty buttons)
        document.getElementById('start-screen').addEventListener('click', async (e) => {
            await startMenuMusicOnce();
            if (e.target.classList.contains('difficulty-btn')) return;
            this.startGame();
        });

        // Restart game from game over screen
        document.getElementById('game-over-screen').addEventListener('click', () => {
            if (this.state === GameState.GAMEOVER) {
                this.restartGame();
            }
        });

        // Pause on ESC
        window.addEventListener('keydown', (e) => {
            // V4 INFINITE: Close inventory/shop with ESC
            if (e.code === 'Escape') {
                if (this.state === GameState.INVENTORY) {
                    this.closeInventory();
                    return;
                }
                if (this.state === GameState.SHOP) {
                    // Can't escape shop, must continue
                    return;
                }
                if (this.state === GameState.PLAYING) {
                    this.togglePause();
                }
            }

            // V4 INFINITE: Toggle inventory with I key
            if (e.code === 'KeyI' && this.state === GameState.PLAYING && !this.isPaused) {
                this.openInventory();
                return;
            }

            // V2 Weapon switching (1, 2, 3)
            if (this.state === GameState.PLAYING && !this.isPaused && this.player) {
                if (e.code === 'Digit1') {
                    this.player.switchWeapon('blade');
                } else if (e.code === 'Digit2') {
                    this.player.switchWeapon('pistol');
                } else if (e.code === 'Digit3') {
                    this.player.switchWeapon('scythe');
                }
            }

            // V4 INFINITE: Open boss chest with C key (not E, to avoid triggering ability)
            if (e.code === 'KeyC' && this.state === GameState.PLAYING && !this.isPaused) {
                this.tryOpenBossChest();
            }
        });

        // V3: Scroll wheel dedicated to weapon switching only (no camera zoom conflict)
        window.addEventListener('wheel', (e) => {
            if (this.state === GameState.PLAYING && !this.isPaused && this.player) {
                // Scroll wheel = weapon cycle (removed shift requirement)
                this.player.cycleWeapon(e.deltaY > 0 ? 1 : -1);
            }
        }, { passive: true });

        // Display high score on start screen
        this.updateHighScoreDisplay();
    }

    onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    async startGame() {
        this.state = GameState.PLAYING;
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('hud').classList.add('visible');
        document.getElementById('crosshair').classList.add('visible');
        this.gameTime = 0;

        // Ensure audio is initialized before starting
        if (audioManager.isMenuPlaying) {
            audioManager.transitionToGameMusic();
        } else {
            // Fallback: Initialize audio on first user interaction
            await audioManager.init();
        }
        console.log('Game started, audio state:', { initialized: audioManager.initialized, sfxGain: !!audioManager.sfxGain });

        // Reset stats
        this.score = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.enemies = [];
        this.hitFrame = 0;

        // V3: Clear health drops
        for (const drop of this.healthDrops) {
            drop.dispose();
        }
        this.healthDrops = [];

        // V4: Clear gold coins
        for (const coin of this.goldCoins) {
            coin.dispose();
        }
        this.goldCoins = [];

        this.totalKills = 0;
        this.maxCombo = 0;
        this.isPaused = false;

        // Reset wave system
        // Check for debug start wave - enable debug mode for testing
        const isDebugStart = this.debugStartWave !== null && this.debugStartWave > 0;
        this.wave = this.debugStartWave || 0;
        this.debugStartWave = null; // Reset for next game
        this.debugMode = isDebugStart; // Enable invincibility for debug testing
        this.waveState = 'PREP';
        this.waveTimer = CONFIG.wavePrepTime;
        this.waveEnemiesSpawned = 0;
        this.waveEnemiesKilled = 0;
        this.waveEnemiesTotal = 0;
        this.spawnQueue = [];
        this.spawnTimer = 0;

        // Reset boss/chest state
        this.currentBoss = null;
        if (this.bossChest) {
            this.bossChest.dispose();
            this.bossChest = null;
        }
        this.awaitingChestOpen = false;
        this.chestPromptShown = false;

        // Create player
        this.player = new Player(this.scene);

        // V4: Connect VFX to sword for trail particles
        if (this.vfx && this.player.sword) {
            this.player.sword.setVFX(this.vfx);
        }

        // Set initial camera position behind player (V2)
        this.cameraYaw = 0;
        this.cameraPitch = CONFIG.cameraDefaultPitch;
        this.cameraDistance = CONFIG.cameraDistance;
        this.cameraCombatDistance = CONFIG.cameraDistance;
        this.cameraTarget.copy(this.player.position);
        this.cameraActualPosition.set(
            this.player.position.x,
            this.player.position.y + CONFIG.cameraHeight,
            this.player.position.z + CONFIG.cameraDistance
        );

        // Show wave announcement
        this.showWaveAnnouncement('GET READY');

        // V2.6 Reset post-processing effects
        this.screenEffects.setLowHealthMode(false);
        this.screenEffects.setCombatMode(false);

        // V2.7 Clear any leftover hit sparks
        for (const spark of this.hitSparks) {
            this.scene.remove(spark);
            spark.geometry.dispose();
            spark.material.dispose();
        }
        this.hitSparks = [];

        // V2.11 Reset audio state
        this.heartbeatTimer = 0;

        // Request pointer lock
        this.canvas.requestPointerLock();
    }

    // V3: Get wave scaling multiplier - enemies get stronger instead of more numerous
    getWaveScaling(waveNumber) {
        // V5: Heavy strength scaling since enemy count stays low
        // Scaling starts at 1.0 and increases by 25% per wave after wave 3
        // Wave 10: 2.75x, Wave 20: 5.25x, Wave 50: 12.75x
        const baseScale = 1.0;
        const scalePerWave = 0.25; // Strong scaling to compensate for minimal enemy count growth
        const scaleStartWave = 3;

        if (waveNumber <= scaleStartWave) return baseScale;

        const wavesPastStart = waveNumber - scaleStartWave;
        return baseScale + wavesPastStart * scalePerWave;
    }

    // Wave System
    getWaveComposition(waveNumber) {
        // Define enemy composition based on wave number
        const composition = [];

        // V5: Minimal enemy count growth - strength scales instead
        // Start with 3 enemies, add +1 every boss wave (every 10 levels)
        // Wave 1-9: 3 enemies, Wave 10-19: 4 enemies, Wave 20-29: 5 enemies, etc.
        const bossesDefeated = Math.floor((waveNumber - 1) / 10);
        const diffMod = CONFIG.difficulty[currentDifficulty].waveCountMod || 0;
        const baseCount = 3 + bossesDefeated + diffMod;
        const maxCount = 6; // Hard cap at 6 enemies per wave (reached at wave 30+)
        const totalEnemies = Math.max(2, Math.min(baseCount, maxCount));

        // Wave 1-2: Mostly Ticks
        if (waveNumber <= 2) {
            for (let i = 0; i < totalEnemies; i++) {
                composition.push('tick');
            }
        }
        // Wave 3-4: Introduce Tocks and Mites
        else if (waveNumber <= 4) {
            const tocks = Math.floor(waveNumber / 2);
            const mites = Math.max(1, Math.floor(waveNumber / 3));
            for (let i = 0; i < totalEnemies; i++) {
                if (i < mites) composition.push('mite');
                else if (i < mites + tocks) composition.push('tock');
                else composition.push('tick');
            }
        }
        // Wave 5-6: Introduce Pendulum
        else if (waveNumber <= 6) {
            const tocks = Math.floor(waveNumber / 2);
            const pendulums = Math.floor(waveNumber / 3);
            const mites = Math.floor(waveNumber / 4);
            for (let i = 0; i < totalEnemies; i++) {
                if (i < pendulums) composition.push('pendulum');
                else if (i < pendulums + mites) composition.push('mite');
                else if (i < pendulums + mites + tocks) composition.push('tock');
                else composition.push('tick');
            }
        }
        // Wave 7-9: Introduce Grandfather
        else if (waveNumber <= 9) {
            const grandfathers = Math.floor((waveNumber - 6) / 2) + 1;
            const tocks = Math.floor(waveNumber / 3);
            const pendulums = Math.floor(waveNumber / 4);
            const mites = Math.floor(waveNumber / 5);
            for (let i = 0; i < totalEnemies; i++) {
                if (i < grandfathers) composition.push('grandfather');
                else if (i < grandfathers + pendulums) composition.push('pendulum');
                else if (i < grandfathers + pendulums + mites) composition.push('mite');
                else if (i < grandfathers + pendulums + mites + tocks) composition.push('tock');
                else composition.push('tick');
            }
        }
        // Wave 10+: Full variety including Second Hand
        else {
            const secondhands = Math.min(Math.floor((waveNumber - 9) / 2) + 1, 3);
            const grandfathers = Math.min(Math.floor(waveNumber / 5), 2);
            const pendulums = Math.floor(waveNumber / 4);
            const tocks = Math.floor(waveNumber / 3);
            const mites = Math.floor(waveNumber / 6);

            for (let i = 0; i < totalEnemies; i++) {
                if (i < secondhands) composition.push('secondhand');
                else if (i < secondhands + grandfathers) composition.push('grandfather');
                else if (i < secondhands + grandfathers + pendulums) composition.push('pendulum');
                else if (i < secondhands + grandfathers + pendulums + mites) composition.push('mite');
                else if (i < secondhands + grandfathers + pendulums + mites + tocks) composition.push('tock');
                else composition.push('tick');
            }
        }

        // Shuffle for variety
        for (let i = composition.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [composition[i], composition[j]] = [composition[j], composition[i]];
        }

        return composition;
    }

    startNextWave() {
        this.wave++;
        this.waveState = 'ACTIVE';
        this.waveEnemiesSpawned = 0;
        this.waveEnemiesKilled = 0;
        this.currentBoss = null;

        // V4: Update sky color for new wave
        this.updateSkyColor();

        // Check if this is a boss wave (every 10 waves starting at wave 10)
        const isBossWave = this.wave > 0 && this.wave % 10 === 0;

        // Play wave start sound
        audioManager.playWaveStart(this.wave);

        if (isBossWave) {
            // Boss wave - spawn elemental Chronophage
            this.spawnQueue = ['boss'];
            // Boss now spawns its own minions during special attacks
            this.waveEnemiesTotal = this.spawnQueue.length;
            this.spawnTimer = 0;

            // Get boss type for announcement
            const bossType = getChronophageType(this.wave);

            // Dramatic boss announcement
            this.showWaveAnnouncement(`BOSS WAVE ${this.wave}\n${bossType.name.toUpperCase()} APPROACHES`);

            // Play boss entrance sound
            audioManager.playBossEntrance();
        } else {
            // Get normal wave composition
            this.spawnQueue = this.getWaveComposition(this.wave);
            this.waveEnemiesTotal = this.spawnQueue.length;
            this.spawnTimer = 0;

            // Show wave announcement
            this.showWaveAnnouncement(`WAVE ${this.wave}`);
        }

        // Update HUD
        document.getElementById('wave-number').textContent = this.wave;
    }

    updateWaveSystem(deltaTime) {
        switch (this.waveState) {
            case 'PREP':
                this.waveTimer -= deltaTime;
                if (this.waveTimer <= 0) {
                    this.startNextWave();
                }
                break;

            case 'ACTIVE':
                // Spawn enemies from queue
                if (this.spawnQueue.length > 0 && this.enemies.length < CONFIG.maxEnemiesAlive) {
                    this.spawnTimer -= deltaTime;
                    if (this.spawnTimer <= 0) {
                        const type = this.spawnQueue.shift();
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 25 + Math.random() * 10;
                        const position = new THREE.Vector3(
                            Math.cos(angle) * distance,
                            0,
                            Math.sin(angle) * distance
                        );
                        this.spawnEnemy(type, position);
                        this.waveEnemiesSpawned++;

                        // Stagger spawns - faster in later waves
                        this.spawnTimer = Math.max(0.3, 1.5 - this.wave * 0.1);
                    }
                }

                // Check if wave is complete (all spawned AND all alive enemies dead)
                const aliveEnemies = this.enemies.filter(e => e.isAlive || e.isDying).length;
                if (this.waveEnemiesKilled >= this.waveEnemiesTotal &&
                    this.spawnQueue.length === 0 &&
                    aliveEnemies === 0) {
                    this.completeWave();
                }
                break;

            case 'COMPLETE':
                // Brief pause after wave completion
                this.waveTimer -= deltaTime;
                if (this.waveTimer <= 0) {
                    // V4 INFINITE: If awaiting chest open, wait for it
                    if (this.awaitingChestOpen) {
                        this.waveState = 'AWAITING_CHEST';
                    } else {
                        this.waveState = 'INTERMISSION';
                        this.waveTimer = CONFIG.waveIntervalTime;
                        this.showWaveAnnouncement('NEXT WAVE INCOMING');
                    }
                }
                break;

            case 'AWAITING_CHEST':
                // Wait for player to open the boss chest
                if (!this.awaitingChestOpen) {
                    // Chest was opened, proceed to shop after boss
                    this.waveState = 'INTERMISSION';
                    this.waveTimer = CONFIG.waveIntervalTime;
                    this.showWaveAnnouncement('NEXT WAVE INCOMING');
                }
                break;

            case 'INTERMISSION':
                this.waveTimer -= deltaTime;
                if (this.waveTimer <= 0) {
                    // V4 INFINITE: Check if shop should appear
                    if (!this.checkForShop()) {
                        this.startNextWave();
                    } else {
                        // Shop is open, wait for it to close
                        this.waveState = 'SHOP';
                    }
                }
                break;
        }
    }

    completeWave() {
        this.waveState = 'COMPLETE';
        this.waveTimer = 3; // V3: 3 second pause to show stats

        // Award wave completion bonus (scales with wave number)
        const waveBonus = CONFIG.waveCompletionBonus * this.wave;
        this.score += waveBonus;

        // Give player some charge for wave completion
        if (this.player) {
            this.player.addCharge(20);
        }

        // V4: Epic wave complete effects
        this.screenEffects.slowmo(0.3, 1.0); // Dramatic slowdown
        this.screenEffects.chromaticBurst(0.3);
        this.screenEffects.shake(0.3, 0.3);

        // V4: Lightning storm celebration
        if (this.vfx) {
            this.vfx.startMinorStorm();
            this.vfx.screenFlash('#d4af37', 0.3);

            // Spawn celebration particles around player
            if (this.player) {
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        if (this.vfx && this.player) {
                            const offset = new THREE.Vector3(
                                (Math.random() - 0.5) * 6,
                                1,
                                (Math.random() - 0.5) * 6
                            );
                            const pos = this.player.position.clone().add(offset);
                            this.vfx.spawnHitSparks(pos, 20, 'gold', {
                                speed: 10,
                                gravity: 5,
                                lifetime: 1.0
                            });
                        }
                    }, i * 200);
                }
            }
        }

        // Play wave complete sound
        audioManager.playWaveComplete();

        // V3: Show enhanced wave complete summary
        this.showWaveCompleteSummary(waveBonus);
    }

    // V3: Enhanced wave complete screen with stats
    showWaveCompleteSummary(waveBonus) {
        // Create or update wave summary element
        let summary = document.getElementById('wave-summary');
        if (!summary) {
            summary = document.createElement('div');
            summary.id = 'wave-summary';
            summary.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-family: 'Rajdhani', sans-serif;
                color: #d4af37;
                text-align: center;
                pointer-events: none;
                z-index: 100;
                opacity: 0;
                transition: opacity 0.5s;
                background: radial-gradient(ellipse at center, rgba(20, 15, 30, 0.95) 0%, rgba(20, 15, 30, 0.8) 70%, transparent 100%);
                padding: 40px 60px;
                border-radius: 10px;
                border: 2px solid rgba(212, 175, 55, 0.5);
                box-shadow: 0 0 30px rgba(212, 175, 55, 0.3);
            `;
            document.body.appendChild(summary);
        }

        // Calculate wave time (approximate based on game time)
        const waveTime = Math.floor(this.gameTime % 60);
        const maxHealth = this.player ? getPlayerMaxHealth() : 100;
        const currentHealth = this.player ? this.player.health : 0;
        const healthPercent = Math.round((currentHealth / maxHealth) * 100);

        // Build summary HTML
        summary.innerHTML = `
            <div style="font-family: 'ZCOOL KuaiLe', sans-serif; font-size: 4rem; margin-bottom: 20px; text-shadow: 0 0 20px rgba(212, 175, 55, 0.9);">
                WAVE ${this.wave} COMPLETE
            </div>
            <div style="font-size: 1.4rem; margin: 15px 0; color: #88ff88;">
                +${waveBonus.toLocaleString()} WAVE BONUS
            </div>
            <div style="display: flex; justify-content: center; gap: 50px; margin-top: 25px; font-size: 1.2rem;">
                <div style="text-align: center;">
                    <div style="color: #ff6666; font-size: 2rem; font-weight: bold;">${this.waveEnemiesKilled}</div>
                    <div style="color: #aaa;">KILLS</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #66ffff; font-size: 2rem; font-weight: bold;">${this.maxCombo}</div>
                    <div style="color: #aaa;">MAX COMBO</div>
                </div>
                <div style="text-align: center;">
                    <div style="color: #ffff66; font-size: 2rem; font-weight: bold;">${this.score.toLocaleString()}</div>
                    <div style="color: #aaa;">TOTAL SCORE</div>
                </div>
            </div>
            <div style="margin-top: 25px; font-size: 1.1rem; color: #888;">
                Health: <span style="color: ${healthPercent > 50 ? '#88ff88' : healthPercent > 25 ? '#ffff66' : '#ff6666'};">${healthPercent}%</span>
            </div>
        `;

        summary.style.opacity = '1';

        // Clear any existing timeout
        if (this.waveSummaryTimeout) {
            clearTimeout(this.waveSummaryTimeout);
        }

        // Fade out after showing stats
        this.waveSummaryTimeout = setTimeout(() => {
            summary.style.opacity = '0';
        }, 2500);
    }

    showWaveAnnouncement(text) {
        // Create or update wave announcement element
        let announcement = document.getElementById('wave-announcement');
        if (!announcement) {
            announcement = document.createElement('div');
            announcement.id = 'wave-announcement';
            announcement.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%) scale(1);
                font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
                font-size: 5rem;
                font-weight: 400;
                letter-spacing: 0.3rem;
                color: #d4af37;
                text-shadow:
                    0 0 20px rgba(212, 175, 55, 0.9),
                    0 0 40px rgba(212, 175, 55, 0.6),
                    0 0 60px rgba(212, 175, 55, 0.4),
                    0 4px 0 rgba(0, 0, 0, 0.3);
                text-align: center;
                pointer-events: none;
                z-index: 100;
                opacity: 0;
                transition: opacity 0.3s, transform 0.3s;
                white-space: pre-line;
            `;
            document.body.appendChild(announcement);
        }

        announcement.textContent = text;
        announcement.style.opacity = '1';

        // Clear any existing timeout
        if (this.waveAnnouncement) {
            clearTimeout(this.waveAnnouncement);
        }

        // Fade out after 2 seconds
        this.waveAnnouncement = setTimeout(() => {
            announcement.style.opacity = '0';
        }, 2000);
    }

    spawnEnemy(type, position) {
        let enemy;
        switch (type) {
            case 'tick':
                enemy = new Tick(this.scene, position);
                break;
            case 'tock':
                enemy = new Tock(this.scene, position);
                break;
            case 'grandfather':
                enemy = new Grandfather(this.scene, position);
                break;
            case 'pendulum':
                enemy = new Pendulum(this.scene, position);
                break;
            case 'secondhand':
                enemy = new SecondHand(this.scene, position);
                break;
            case 'mite':
                enemy = new MinuteMite(this.scene, position, 1.0, this);
                break;
            case 'boss':
                // Create elemental boss based on wave number
                const chronophageType = getChronophageType(this.wave);
                enemy = new ElementalChronophage(this.scene, position, this, chronophageType);
                this.currentBoss = enemy; // Track the boss
                break;
            default:
                enemy = new Tick(this.scene, position);
        }

        // V3: Apply wave scaling to enemy stats
        const waveScale = this.getWaveScaling(this.wave);
        if (waveScale > 1.0) {
            // Scale health
            enemy.health *= waveScale;
            enemy.maxHealth = enemy.health;

            // Scale damage (slightly less aggressive)
            enemy.damage *= (1 + (waveScale - 1) * 0.6);

            // Scale speed (very subtle)
            enemy.speed *= (1 + (waveScale - 1) * 0.3);

            // Scale points reward
            enemy.points = Math.floor(enemy.points * waveScale);
        }

        this.enemies.push(enemy);

        // Play spawn sound
        audioManager.playEnemySpawn();

        // V4: Spawn visual effect
        if (this.vfx) {
            this.vfx.spawnEnemySpawnEffect(position, type === 'boss' ? 'boss' : 'normal');
        }

        return enemy;
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        this.deltaTime = this.clock.getDelta();
        this.elapsedTime = this.clock.getElapsedTime();

        if (this.state === GameState.PLAYING && !this.isPaused) {
            this.gameTime += this.deltaTime;
            this.update();
        }

        // Update arena animations (always, even in menu)
        if (this.arena) {
            this.arena.update(this.deltaTime, this.elapsedTime);
        }

        // Slow camera rotation in menu
        if (this.state === GameState.MENU) {
            const angle = this.elapsedTime * 0.1;
            this.camera.position.x = Math.sin(angle) * 50;
            this.camera.position.z = Math.cos(angle) * 50;
            this.camera.position.y = 25 + Math.sin(this.elapsedTime * 0.2) * 3;
            this.camera.lookAt(0, 0, 0);
        }

        this.renderer.render(this.scene, this.camera);
    }

    update() {
        // Update screen effects (independently of time scale)
        this.screenEffects.update(this.deltaTime);

        // V4: Update VFX Manager
        if (this.vfx) {
            this.vfx.update(this.deltaTime, this.elapsedTime);
        }

        // V4: Smooth sky color transition
        this.updateSkyTransition(this.deltaTime);

        // Apply time scale from screen effects
        const timeScale = this.screenEffects.getTimeScale();
        const scaledDelta = this.deltaTime * timeScale;

        // Handle camera rotation from mouse input (V2 - smoother orbit)
        if (this.input.isPointerLocked) {
            const mouseMovement = this.input.consumeMouseMovement();
            const sensitivity = 0.003;

            // Horizontal orbit (yaw) - no limits, wraps around
            this.cameraYaw += mouseMovement.x * sensitivity;

            // Vertical orbit (pitch) - clamped to prevent flipping
            this.cameraPitch -= mouseMovement.y * sensitivity;
            this.cameraPitch = Math.max(CONFIG.cameraPitchMin, Math.min(CONFIG.cameraPitchMax, this.cameraPitch));
        }

        // Update Chronostasis timer
        this.updateChronostasis(this.deltaTime);

        // Update player (with scaled time, or reduced if in Chronostasis)
        if (this.player) {
            const playerDelta = this.chronostasisActive ?
                scaledDelta * CONFIG.chronostasisPlayerSpeed : scaledDelta;
            // V3: Pass enemies for aim assist
            this.player.update(playerDelta, this.input, this.elapsedTime, this.enemies);

            // V4 INFINITE: Update shield system
            this.player.updateShield(playerDelta);

            // V3: Apply pillar collision after movement
            if (this.arena && this.arena.pillars) {
                this.player.applyPillarCollision(this.arena.pillars);
            }

            this.updateCamera();

            // Check for Chronostasis request
            if (this.player.wantsChronostasis) {
                this.player.wantsChronostasis = false;
                this.activateChronostasis();
            }

            // Check for Time Fracture (process after player input handling)
            this.processTimeFracture();
        }

        // Update enemies (with scaled time, or frozen if Chronostasis)
        this.updateEnemies(scaledDelta);

        // V3: Update health drops
        this.updateHealthDrops(scaledDelta, this.elapsedTime);

        // V4: Update gold coins
        this.updateGoldCoins(scaledDelta, this.elapsedTime);

        // V4: Update boss chest
        this.updateBossChest(scaledDelta, this.elapsedTime);

        // Check combat (player attacks hitting enemies, enemy attacks hitting player)
        this.updateCombat();

        // Update wave system
        this.updateWaveSystem(this.deltaTime);

        // Update combo timer
        this.updateCombo();

        // Update HUD
        this.updateHUD();

        // V2.6 Update post-processing states
        if (this.player) {
            const maxHealth = getPlayerMaxHealth();
            const healthPercent = this.player.health / maxHealth;
            this.screenEffects.setLowHealthMode(healthPercent <= 0.3);

            // CoD-style damage vignette - updates smoothly based on health
            this.screenEffects.updateHealthVignette(healthPercent);
            this.screenEffects.updateDamageVignette(this.deltaTime);

            // Combat mode active when enemies nearby
            const hasNearbyEnemies = this.enemies.some(e =>
                e.isAlive && e.mesh && Vec3.length(Vec3.sub(e.mesh.position, this.player.mesh.position)) < 20
            );
            this.screenEffects.setCombatMode(hasNearbyEnemies);

            // V2.8 Dynamic audio - adjust ambient intensity based on combat
            audioManager.setAmbientIntensity(hasNearbyEnemies ? 1 : 0);

            // V2.8 Low health heartbeat
            if (healthPercent <= 0.3 && healthPercent > 0) {
                this.heartbeatTimer -= this.deltaTime;
                if (this.heartbeatTimer <= 0) {
                    audioManager.playHeartbeat(1 - healthPercent * 2);
                    this.heartbeatTimer = 1.2; // Heartbeat interval
                }
            } else {
                this.heartbeatTimer = 0;
            }
        }

        // V2.7 Update hit spark particles
        this.updateHitSparks(this.deltaTime);
    }

    updateChronostasis(deltaTime) {
        if (!this.chronostasisActive) return;

        this.chronostasisTimer -= deltaTime;
        if (this.chronostasisTimer <= 0) {
            this.chronostasisActive = false;
            this.chronostasisTimer = 0;

            // Play chronostasis end sound
            audioManager.playChronostasisEnd();
        }
    }

    activateChronostasis() {
        if (!this.player.canUseChronostasis()) return;

        const result = this.player.useChronostasis();
        this.chronostasisActive = true;
        this.chronostasisTimer = result.duration;

        // Big screen effect
        this.screenEffects.hitstop(0.1);
        this.screenEffects.flashVignette('#d4af37', 0.4);
        this.screenEffects.shake(0.15, 0.1);

        // V2.6 Chromatic aberration on ability use
        this.screenEffects.chromaticBurst(0.3);
    }

    processTimeFracture() {
        // Check if player just used Time Fracture (we detect by checking if effect was just created)
        if (!this.player) return;

        // Time Fracture was triggered in player, we need to deal damage
        // We check the ability effects to see if one was just added AND not yet processed
        const fractureEffects = this.player.abilityEffects.filter(e =>
            e.type === 'timeFracture' && !e.damageProcessed
        );

        for (const effect of fractureEffects) {
            // Mark as processed FIRST to prevent loop
            effect.damageProcessed = true;

            // Deal damage to all enemies in radius
            for (const enemy of this.enemies) {
                if (!enemy.isAlive || enemy.state === 'SPAWN') continue;

                const dist = Vec3.distance(this.player.position, enemy.position);
                if (dist <= CONFIG.timeFractureRadius) {
                    const result = enemy.takeDamage(CONFIG.timeFractureDamage, this.hitFrame++);
                    if (result === 'killed') {
                        this.onEnemyKilled(enemy);
                    } else if (result === true) {
                        this.onEnemyHit(enemy);
                    }
                }
            }

            // Screen effects - brief hitstop for impact
            this.screenEffects.hitstop(0.05);
            this.screenEffects.shake(0.25, 0.12);

            // V2.6 Chromatic aberration on Time Fracture
            this.screenEffects.chromaticBurst(0.25);
        }
    }

    updateEnemies(scaledDelta) {
        if (!this.player) return;

        // If Chronostasis is active, enemies are frozen
        const enemyDelta = this.chronostasisActive ? 0 : scaledDelta;

        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];

            // Update enemy with scaled delta time (or 0 if frozen)
            // Pass player rotation for enemies that need to know if they're being watched (SecondHand)
            enemy.update(enemyDelta, this.player.position, this.player.rotation);

            // Remove destroyed enemies
            if (!enemy.isAlive && !enemy.isDying) {
                this.enemies.splice(i, 1);
            }
        }
    }

    updateCombat() {
        if (!this.player) return;

        // V2 - Handle different weapon types
        const currentWeapon = this.player.currentWeapon;

        // Update projectiles for pistol (V4: pass VFX for trails)
        this.player.updateProjectiles(this.deltaTime, this.vfx);
        this.player.updateReload(this.deltaTime);

        // Check pistol projectiles hitting enemies
        for (let i = this.player.projectiles.length - 1; i >= 0; i--) {
            const proj = this.player.projectiles[i];
            for (const enemy of this.enemies) {
                if (!enemy.isAlive || enemy.state === 'SPAWN') continue;

                const dist = proj.mesh.position.distanceTo(enemy.mesh.position);
                if (dist < 1.5) {
                    // Hit!
                    let damage = proj.damage;
                    if (enemy.isVulnerable && enemy.isVulnerable()) {
                        damage *= 1.5;
                    }

                    const result = enemy.takeDamage(damage, this.hitFrame++);
                    if (result === 'killed') {
                        this.onEnemyKilled(enemy);
                    } else if (result === true) {
                        this.onEnemyHit(enemy);
                    }

                    // Remove projectile
                    this.scene.remove(proj.mesh);
                    this.player.projectiles.splice(i, 1);
                    break;
                }
            }
        }

        // Melee weapons (blade and scythe)
        if (this.player.sword && (currentWeapon === 'blade' || currentWeapon === 'scythe')) {
            const hitbox = this.player.sword.getAttackHitbox();
            if (hitbox) {
                // Increment hit frame ONLY when attack first becomes active (for preventing double hits)
                // This ensures each attack swing has a unique hitFrame
                if (this.player.sword.attackPhase === 'active' && !this.player.sword.hitFrameSet) {
                    this.hitFrame++;
                    this.player.sword.hitFrameSet = true;
                } else if (this.player.sword.attackPhase !== 'active') {
                    this.player.sword.hitFrameSet = false;
                }

                // V2 - Get weapon-specific arc and range
                const weaponConfig = CONFIG.weapons[currentWeapon];
                const attackArc = currentWeapon === 'scythe' ?
                    weaponConfig.arc : (hitbox.arc || weaponConfig.arc);
                const weaponRange = currentWeapon === 'scythe' ?
                    CONFIG.weapons.scythe.range : hitbox.radius;

                // Find the CLOSEST enemy within range and arc (blade hits one, scythe can hit multiple)
                let closestEnemy = null;
                let closestDist = Infinity;
                const enemiesInArc = [];

                for (const enemy of this.enemies) {
                    if (!enemy.isAlive || enemy.state === 'SPAWN') continue;

                    // Distance check - use weapon range
                    const dist = Vec3.distance(this.player.position, enemy.position);
                    if (dist > weaponRange) continue;

                    // Angle check (is enemy within attack arc?)
                    const toEnemy = new THREE.Vector3(
                        enemy.position.x - this.player.position.x,
                        0,
                        enemy.position.z - this.player.position.z
                    ).normalize();

                    const playerForward = new THREE.Vector3(
                        Math.sin(this.player.rotation),
                        0,
                        Math.cos(this.player.rotation)
                    );

                    const dot = toEnemy.dot(playerForward);
                    const angleToEnemy = Math.acos(Math.max(-1, Math.min(1, dot)));
                    const halfArc = (attackArc * Math.PI / 180) / 2;

                    if (angleToEnemy <= halfArc) {
                        enemiesInArc.push({ enemy, dist });
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    }
                }

                // Blade hits only closest enemy, scythe hits all in arc
                const enemiesToHit = currentWeapon === 'scythe' ?
                    enemiesInArc.map(e => e.enemy) :
                    (closestEnemy ? [closestEnemy] : []);

                for (const enemy of enemiesToHit) {
                    // Calculate damage (bonus if enemy is vulnerable)
                    let damage = hitbox.damage;

                    // V2 - Scythe does its own damage
                    if (currentWeapon === 'scythe') {
                        damage = CONFIG.weapons.scythe.damage;
                    }

                    if (enemy.isVulnerable && enemy.isVulnerable()) {
                        damage *= 1.5;
                    }

                    // Apply damage - returns false if already hit this frame, true if hit, 'killed' if killed
                    const result = enemy.takeDamage(damage, this.hitFrame);

                    if (result === 'killed') {
                        // Enemy killed
                        this.onEnemyKilled(enemy);
                    } else if (result === true) {
                        // Enemy hit but not killed
                        this.onEnemyHit(enemy);
                    }
                    // result === false means already hit this frame, do nothing
                }
            }
        }

        // Check enemy attacks hitting player
        if (!this.player.isDashing) {
            for (const enemy of this.enemies) {
                if (!enemy.isAlive) continue;

                if (enemy.checkAttackHit && enemy.checkAttackHit(this.player.position)) {
                    this.onPlayerHit(enemy.damage);
                }
            }
        }
    }

    onEnemyHit(enemy) {
        const prevCombo = this.combo;

        // Add to combo
        this.combo++;
        this.comboTimer = CONFIG.comboDecayTime;

        // V2.8 Check combo milestones and play sound
        const milestones = [10, 25, 50, 100];
        for (let i = 0; i < milestones.length; i++) {
            if (prevCombo < milestones[i] && this.combo >= milestones[i]) {
                audioManager.playComboMilestone(i + 1);
                break;
            }
        }

        // Track max combo
        if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
        }

        // Add temporal charge
        this.player.addCharge(CONFIG.chargePerHit);

        // Screen effects - small hitstop and shake
        this.screenEffects.hitstop(0.03);
        this.screenEffects.shake(0.1, 0.08);

        // V2.7 Spawn hit sparks at enemy position
        this.spawnHitSparks(enemy.position, 8);

        // V4: Enhanced hit sparks via VFX Manager
        if (this.vfx) {
            this.vfx.spawnHitSparks(enemy.position, 15, 'cyan', {
                speed: 12,
                lifetime: 0.4,
                glow: true
            });
            // Combat light flash on hit
            this.vfx.spawnCombatLight(enemy.position, 0x44ffff, 1.0, 4);
        }

        // Play hit sound
        audioManager.playHit(25);

        // Animate combo display
        this.animateComboHit();
    }

    // V2.7 Spawn hit spark particles (V6: optimized with pooled geometry)
    spawnHitSparks(position, count = 8) {
        // Safety check - ensure position is valid
        if (!position || isNaN(position.x) || isNaN(position.y) || isNaN(position.z)) return;

        // V6: Scale particle count based on graphics quality
        const qualityMult = getGraphicsSetting('particleMultiplier') || 1.0;
        const actualCount = Math.max(1, Math.floor(count * qualityMult));

        // V6: Use shared geometry from VFXManager if available
        const sharedGeometry = this.vfx ? this.vfx.sparkGeometry : null;

        for (let i = 0; i < actualCount; i++) {
            // V6: Reuse pooled geometry instead of creating new
            const geometry = sharedGeometry || new THREE.SphereGeometry(0.08, 4, 4);
            const spark = new THREE.Mesh(
                geometry,
                new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xd4af37 : 0x4a90b8,
                    transparent: true,
                    opacity: 1
                })
            );

            spark.position.set(position.x, position.y + 1 + Math.random() * 0.5, position.z);

            // Random velocity
            spark.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 8,
                Math.random() * 6 + 2,
                (Math.random() - 0.5) * 8
            );
            spark.userData.timer = 0.4 + Math.random() * 0.2;
            spark.userData.gravity = -20;

            this.hitSparks.push(spark);
            this.scene.add(spark);
        }
    }

    // V2.7 Update hit sparks
    updateHitSparks(deltaTime) {
        for (let i = this.hitSparks.length - 1; i >= 0; i--) {
            const spark = this.hitSparks[i];

            // Apply gravity
            spark.userData.velocity.y += spark.userData.gravity * deltaTime;

            // Move
            spark.position.x += spark.userData.velocity.x * deltaTime;
            spark.position.y += spark.userData.velocity.y * deltaTime;
            spark.position.z += spark.userData.velocity.z * deltaTime;

            // Fade out
            spark.userData.timer -= deltaTime;
            spark.material.opacity = Math.max(0, spark.userData.timer / 0.5);

            // Remove if expired
            if (spark.userData.timer <= 0 || spark.position.y < 0) {
                this.scene.remove(spark);
                spark.geometry.dispose();
                spark.material.dispose();
                this.hitSparks.splice(i, 1);
            }
        }
    }

    animateComboHit() {
        const comboDisplay = document.querySelector('.combo-display');
        comboDisplay.classList.add('hit');
        setTimeout(() => comboDisplay.classList.remove('hit'), 100);
    }

    onEnemyKilled(enemy) {
        // Track wave progress
        this.waveEnemiesKilled++;

        // Track total kills
        this.totalKills++;

        // Add to combo
        this.combo += 5;
        this.comboTimer = CONFIG.comboDecayTime;

        // Track max combo
        if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
        }

        // Add score (with combo multiplier)
        const multiplier = this.getComboMultiplier();
        this.score += Math.floor(enemy.points * multiplier);

        // Add temporal charge
        this.player.addCharge(CONFIG.chargePerKill);

        // Screen effects - bigger hitstop and slowmo
        this.screenEffects.hitstop(0.05);
        this.screenEffects.slowmo(0.7, 0.1);
        this.screenEffects.shake(0.2, 0.15);

        // Play death sound (boss vs normal) - check for both ChronophagePrime and ElementalChronophage
        const isBoss = enemy instanceof ChronophagePrime || enemy.constructor.name === 'ElementalChronophage';
        audioManager.playEnemyDeath(isBoss);

        // When boss dies, kill all remaining minions
        if (isBoss) {
            this.killAllMinions();
        }

        // V2.6 Chromatic aberration on kills (stronger for bosses)
        if (isBoss) {
            this.screenEffects.chromaticBurst(0.5);
        } else if (this.combo >= 25) {
            this.screenEffects.chromaticBurst(0.15);
        }

        // V2.7 Big spark burst on kill
        this.spawnHitSparks(enemy.position, isBoss ? 30 : 15);

        // V4: INSANE death explosion with VFX Manager
        if (this.vfx) {
            this.vfx.spawnDeathExplosion(enemy.position, isBoss ? 'boss' : 'normal');
            this.vfx.recordKill();
        }

        // V3: Health drop chance (20% for normal, 50% for bosses)
        const dropChance = isBoss ? 0.5 : 0.2;
        if (Math.random() < dropChance) {
            this.spawnHealthDrop(enemy.position);
        }

        // V4 INFINITE: Loot and gold drops
        const enemyType = isBoss ? 'boss' : enemy.constructor.name.toLowerCase();
        this.tryDropLoot(enemy, enemyType, isBoss);

        // V4 INFINITE: Boss drops treasure chest that must be opened
        if (isBoss) {
            this.spawnBossChest(enemy.position);
        }
    }

    spawnBossChest(position) {
        // Spawn treasure chest at boss death location
        this.bossChest = new TreasureChest(this.scene, position, this.wave);
        this.awaitingChestOpen = true;

        // Show message to player
        this.showWaveAnnouncement('BOSS DEFEATED!\nOPEN THE TREASURE CHEST\n(Walk to chest and press C)');
    }

    // Kill all remaining minions when boss dies
    killAllMinions() {
        for (const enemy of this.enemies) {
            // Skip the boss itself (already dead) and already dying enemies
            if (enemy instanceof ChronophagePrime || !enemy.isAlive || enemy.isDying) continue;

            // Instant kill with death effect
            enemy.isAlive = false;
            enemy.isDying = true;

            // Immediately hide health bar
            enemy.hideHealthBar();

            // Death VFX
            if (this.vfx) {
                this.vfx.spawnDeathExplosion(enemy.position, 'normal');
            }

            // Update counters
            this.waveEnemiesKilled++;
            this.totalKills++;

            // Small delay then fully destroy (including health bar removal)
            setTimeout(() => {
                enemy.destroy();
            }, 100);
        }

        // Clear the spawn queue so no more minions spawn
        this.spawnQueue = [];
    }

    // V4 INFINITE: Try to drop loot from killed enemy
    tryDropLoot(enemy, enemyType, isBoss) {
        if (!this.player) return;

        // Gold drop - spawn visual gold coins (doubled)
        const baseGold = isBoss ? 100 : 10 + Math.floor(this.wave * 1.0);
        const goldVariance = Math.floor(baseGold * 0.3 * (Math.random() - 0.5));
        const totalGold = baseGold + goldVariance;

        // Spawn multiple coins for visual effect
        const numCoins = isBoss ? Math.min(10, Math.ceil(totalGold / 10)) : Math.min(5, Math.ceil(totalGold / 3));
        const goldPerCoin = Math.ceil(totalGold / numCoins);

        for (let i = 0; i < numCoins; i++) {
            const coin = new GoldCoin(this.scene, enemy.position, goldPerCoin);
            this.goldCoins.push(coin);
        }

        // Item drop - use loot generator
        const loot = lootGenerator.generateLootDrop(enemyType, this.wave);
        if (loot) {
            this.dropLootItem(loot, enemy.position);
        }
    }

    // V4 INFINITE: Spawn gold coins at position
    spawnGoldCoins(position, amount) {
        const numCoins = Math.min(8, Math.max(1, Math.ceil(amount / 5)));
        const goldPerCoin = Math.ceil(amount / numCoins);

        for (let i = 0; i < numCoins; i++) {
            const coin = new GoldCoin(this.scene, position, goldPerCoin);
            this.goldCoins.push(coin);
        }
    }

    // V4 INFINITE: Create a dropped loot item in the world
    dropLootItem(item, position) {
        // For simplicity, auto-pickup with notification
        // In a full implementation, you'd create a world pickup object
        if (!this.player) return;

        const rarityData = RARITY[item.rarity];

        if (this.player.inventory.isFull()) {
            // Inventory full - show notification but don't pick up
            this.showLootNotification(`Inventory Full! ${item.name}`, '#ff4444');
            return;
        }

        // Add to inventory
        this.player.inventory.addItem(item);

        // Show loot notification
        this.showLootNotification(`${item.name}`, rarityData.color);

        // Special effects for rare+ items
        if (item.rarity !== 'COMMON' && item.rarity !== 'UNCOMMON') {
            this.screenEffects.flashVignette(rarityData.color, 0.2);

            if (item.rarity === 'LEGENDARY' || item.rarity === 'TEMPORAL') {
                this.screenEffects.shake(0.15, 0.1);
                this.screenEffects.chromaticBurst(0.2);
            }
        }
    }

    // V3: Spawn a health drop at position
    spawnHealthDrop(position) {
        const drop = new HealthDrop(this.scene, position);
        this.healthDrops.push(drop);
    }

    // V3: Update all health drops
    updateHealthDrops(deltaTime, elapsedTime) {
        for (let i = this.healthDrops.length - 1; i >= 0; i--) {
            const drop = this.healthDrops[i];

            // Check for pickup first
            if (this.player && drop.checkPickup(this.player.position)) {
                // Heal player
                const maxHealth = getPlayerMaxHealth();
                this.player.health = Math.min(this.player.health + drop.healAmount, maxHealth);

                // Visual/audio feedback
                this.screenEffects.flashVignette('#00ff88', 0.3);

                // Remove drop
                drop.dispose();
                this.healthDrops.splice(i, 1);
                continue;
            }

            // Update drop (returns false if expired)
            if (!drop.update(deltaTime, elapsedTime)) {
                drop.dispose();
                this.healthDrops.splice(i, 1);
            }
        }
    }

    // V4: Update all gold coins
    updateGoldCoins(deltaTime, elapsedTime) {
        for (let i = this.goldCoins.length - 1; i >= 0; i--) {
            const coin = this.goldCoins[i];

            // Check for pickup first
            if (this.player && coin.checkPickup(this.player.position)) {
                // Add gold to player
                this.player.inventory.addGold(coin.value);

                // Visual/audio feedback
                this.screenEffects.flashVignette('#ffd700', 0.1);

                // Remove coin
                coin.dispose();
                this.goldCoins.splice(i, 1);
                continue;
            }

            // Update coin (returns false if expired)
            if (!coin.update(deltaTime, elapsedTime)) {
                coin.dispose();
                this.goldCoins.splice(i, 1);
            }
        }
    }

    updateBossChest(deltaTime, elapsedTime) {
        if (!this.bossChest) return;

        // Update chest animation
        this.bossChest.update(deltaTime, elapsedTime);

        // Check if player can interact
        if (this.player && this.bossChest.canInteract(this.player.position)) {
            // Show interaction prompt
            if (!this.chestPromptShown) {
                this.showLootNotification('Press C to open chest', '#ffd700');
                this.chestPromptShown = true;
            }
        } else {
            this.chestPromptShown = false;
        }

        // Clean up if chest was opened and collected
        if (this.bossChest.isOpen && this.bossChest.collected) {
            this.bossChest = null;
            this.awaitingChestOpen = false;
        }
    }

    tryOpenBossChest() {
        if (!this.bossChest || !this.player) return;
        if (!this.bossChest.canInteract(this.player.position)) return;

        const loot = this.bossChest.open();
        if (!loot) return;

        // VFX for chest opening
        if (this.vfx) {
            this.vfx.spawnHitSparks(this.bossChest.position, 50, 'gold', {
                speed: 15,
                gravity: 3,
                lifetime: 1.5
            });
            this.vfx.screenFlash('#ffd700', 0.5);
        }

        // Add gold
        this.player.inventory.gold += loot.gold;
        audioManager.playGoldPickup();
        this.showLootNotification(`+${loot.gold} Gold!`, '#ffd700');

        // Add items to inventory or show them
        for (const item of loot.items) {
            if (this.player.inventory.isFull()) {
                this.showLootNotification(`Inventory full! ${item.name} lost!`, '#ff4444');
            } else {
                this.player.inventory.addItem(item);
                const rarityData = RARITY[item.rarity];
                this.showLootNotification(`Found: ${item.name}`, rarityData.color);
            }
        }

        // Mark chest for cleanup
        this.awaitingChestOpen = false;

        // Show "Advancing to next wave..." message
        this.showLootNotification('Advancing to next wave...', '#00ffff');

        // Clean up chest and advance after 3 seconds
        setTimeout(() => {
            // Dispose chest
            if (this.bossChest) {
                this.bossChest.dispose();
                this.bossChest = null;
            }

            // Check if this was a boss wave (every 10th wave)
            const isBossWave = this.wave > 0 && this.wave % 10 === 0;
            if (isBossWave) {
                // Open shop after boss waves
                this.openShop();
                this.waveState = 'SHOP';
            } else {
                // Start the next wave for regular waves
                this.waveState = 'PREP';
                this.startNextWave();
            }
        }, 3000);
    }

    onPlayerHit(damage, attacker = null) {
        // Debug mode - player is invincible for testing
        if (this.debugMode) return;

        // V4 INFINITE - Route damage through shield system
        const finalDamage = this.player.absorbDamageWithShield(damage, attacker);

        // If damage was fully blocked, reduced effects
        if (finalDamage === 0) {
            // Perfect block - no combo reset, minimal effects
            this.screenEffects.shake(0.1, 0.05);
            return;
        }

        // If damage was partially blocked
        const wasBlocked = finalDamage < damage;

        // Reset combo (unless blocked)
        if (!wasBlocked) {
            this.combo = 0;
            this.comboTimer = 0;
        }

        // Damage player
        this.player.takeDamage(finalDamage);

        // Screen effects - scaled by damage
        const effectScale = wasBlocked ? 0.5 : 1.0;
        this.screenEffects.flashVignette(wasBlocked ? '#00ffff' : '#ff0000', 0.5 * effectScale);
        this.screenEffects.shake(0.3 * effectScale, 0.15 * effectScale);

        // V2.6 Chromatic aberration burst on damage
        this.screenEffects.chromaticBurst(0.2 * effectScale);

        // V2.6 Check low health mode
        const maxHealth = getPlayerMaxHealth();
        const healthPercent = this.player.health / maxHealth;
        this.screenEffects.setLowHealthMode(healthPercent <= 0.3);

        // Play player hit sound
        audioManager.playPlayerHit();

        // Check for death
        if (this.player.health <= 0) {
            this.gameOver();
        }
    }

    updateCombo() {
        if (this.comboTimer > 0) {
            this.comboTimer -= this.deltaTime;
            if (this.comboTimer <= 0) {
                this.combo = 0;
            }
        }
    }

    getComboMultiplier() {
        if (this.combo >= 100) return 5.0;
        if (this.combo >= 50) return 3.0;
        if (this.combo >= 25) return 2.0;
        if (this.combo >= 10) return 1.5;
        return 1.0;
    }

    updateHUD() {
        // V6: Use cached DOM elements for performance
        const h = this.hudElements;

        // Update game time display
        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        if (h.timeDisplay) {
            h.timeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update combo
        if (h.comboCount) {
            h.comboCount.textContent = this.combo;
        }

        // Style combo based on value
        if (h.comboDisplay) {
            h.comboDisplay.classList.remove('high', 'max');
            if (this.combo >= 50) {
                h.comboDisplay.classList.add('max');
            } else if (this.combo >= 25) {
                h.comboDisplay.classList.add('high');
            }
        }

        // Update score
        if (h.scoreDisplay) {
            h.scoreDisplay.textContent = this.score.toLocaleString();
        }

        // Update ability cooldowns
        this.updateAbilityHUD();

        // V4 INFINITE: Update shield and gold HUD
        this.updateShieldHUD();
        this.updateGoldHUD();
    }

    updateAbilityHUD() {
        if (!this.player) return;

        const charge = this.player.temporalCharge;
        const h = this.hudElements;

        // Q - Time Fracture
        if (h.abilityQ && h.abilityQCooldown) {
            h.abilityQ.classList.remove('ready', 'insufficient');
            if (this.player.timeFractureCooldown > 0) {
                const cdPercent = (this.player.timeFractureCooldown / CONFIG.timeFractureCooldown) * 100;
                h.abilityQCooldown.style.height = `${cdPercent}%`;
            } else {
                h.abilityQCooldown.style.height = '0%';
                if (charge >= CONFIG.timeFractureCost) {
                    h.abilityQ.classList.add('ready');
                } else {
                    h.abilityQ.classList.add('insufficient');
                }
            }
        }

        // E - Temporal Echo
        if (h.abilityE && h.abilityECooldown) {
            h.abilityE.classList.remove('ready', 'active', 'insufficient');
            if (this.player.temporalEchoActive) {
                h.abilityE.classList.add('active');
                h.abilityECooldown.style.height = '0%';
            } else if (this.player.temporalEchoCooldown > 0) {
                const cdPercent = (this.player.temporalEchoCooldown / CONFIG.temporalEchoCooldown) * 100;
                h.abilityECooldown.style.height = `${cdPercent}%`;
            } else {
                h.abilityECooldown.style.height = '0%';
                if (charge >= CONFIG.temporalEchoCost) {
                    h.abilityE.classList.add('ready');
                } else {
                    h.abilityE.classList.add('insufficient');
                }
            }
        }

        // R - Chronostasis
        if (h.abilityR && h.abilityRCooldown) {
            h.abilityR.classList.remove('ready', 'active', 'insufficient');
            if (this.chronostasisActive) {
                h.abilityR.classList.add('active');
                h.abilityRCooldown.style.height = '0%';
            } else if (this.player.chronostasisCooldown > 0) {
                const cdPercent = (this.player.chronostasisCooldown / CONFIG.chronostasisCooldown) * 100;
                h.abilityRCooldown.style.height = `${cdPercent}%`;
            } else {
                h.abilityRCooldown.style.height = '0%';
                if (charge >= CONFIG.chronostasisCost) {
                    h.abilityR.classList.add('ready');
                } else {
                    h.abilityR.classList.add('insufficient');
                }
            }
        }
    }

    gameOver() {
        this.state = GameState.GAMEOVER;

        // Play game over sound and stop combat music
        audioManager.playGameOver();
        audioManager.stopMusic();

        // Release pointer lock
        document.exitPointerLock();

        // Hide HUD
        document.getElementById('hud').classList.remove('visible');
        document.getElementById('crosshair').classList.remove('visible');

        // Clean up all enemy health bars
        for (const enemy of this.enemies) {
            enemy.hideHealthBar();
        }

        // Check for new high score
        const isNewHighScore = this.score > this.highScore;
        if (isNewHighScore) {
            this.highScore = this.score;
            this.saveHighScore();
            this.updateHighScoreDisplay();
        }

        // V2: Check for nightmare unlock (survive 5+ waves on Hard)
        let justUnlockedNightmare = false;
        if (currentDifficulty === 'hard' && this.wave >= 5 && !nightmareUnlocked) {
            nightmareUnlocked = true;
            justUnlockedNightmare = true;
            localStorage.setItem('chronophage_nightmare_unlocked', 'true');
            // Update nightmare button on start screen
            const nightmareBtn = document.querySelector('.difficulty-btn.nightmare');
            if (nightmareBtn) {
                nightmareBtn.classList.remove('locked');
                nightmareBtn.textContent = 'NIGHTMARE';
                nightmareBtn.title = '';
            }
        }

        // Format time
        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        // Update game over screen
        document.getElementById('final-score').textContent = this.score.toLocaleString();
        document.getElementById('final-wave').textContent = this.wave;
        document.getElementById('stat-time').textContent = timeStr;
        document.getElementById('stat-kills').textContent = this.totalKills;
        document.getElementById('stat-max-combo').textContent = this.maxCombo;

        // V2: Update difficulty display
        const difficultyDisplay = document.getElementById('final-difficulty');
        difficultyDisplay.textContent = currentDifficulty.toUpperCase();
        difficultyDisplay.className = `final-difficulty ${currentDifficulty}`;

        // Show/hide new high score notice
        const highScoreNotice = document.getElementById('new-high-score');
        highScoreNotice.style.display = isNewHighScore ? 'block' : 'none';

        // V2: Show/hide nightmare unlock notice
        const nightmareUnlockNotice = document.getElementById('nightmare-unlock');
        nightmareUnlockNotice.style.display = justUnlockedNightmare ? 'block' : 'none';

        // Show game over screen
        const gameOverScreen = document.getElementById('game-over-screen');
        gameOverScreen.classList.add('visible');
    }

    restartGame() {
        // Hide game over screen
        document.getElementById('game-over-screen').classList.remove('visible');

        // Clean up old enemies (including health bars)
        for (const enemy of this.enemies) {
            enemy.destroy(); // This removes mesh AND health bar sprite
        }
        this.enemies = [];

        // Clean up old player
        if (this.player) {
            // V2.11 Clean up player afterimages
            for (const afterimage of this.player.dashAfterimages) {
                this.scene.remove(afterimage);
                afterimage.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            this.player.dashAfterimages = [];

            // V2.11 Clean up player projectiles
            for (const proj of this.player.projectiles) {
                this.scene.remove(proj.mesh);
                proj.mesh.geometry.dispose();
                proj.mesh.material.dispose();
            }
            this.player.projectiles = [];

            if (this.player.mesh) {
                this.scene.remove(this.player.mesh);
            }
        }
        this.player = null;

        // Start fresh game
        this.startGame();
    }

    togglePause() {
        this.isPaused = !this.isPaused;

        const pauseScreen = document.getElementById('pause-screen');
        const crosshair = document.getElementById('crosshair');
        if (this.isPaused) {
            pauseScreen.classList.add('visible');
            crosshair.classList.remove('visible');
            document.exitPointerLock();
        } else {
            pauseScreen.classList.remove('visible');
            crosshair.classList.add('visible');
            this.canvas.requestPointerLock();
        }
    }

    setupPauseMenu() {
        // Volume sliders
        const musicSlider = document.getElementById('music-volume');
        const sfxSlider = document.getElementById('sfx-volume');
        const musicValue = document.getElementById('music-volume-value');
        const sfxValue = document.getElementById('sfx-volume-value');

        // Set initial values
        musicSlider.value = audioManager.getMusicVolume() * 100;
        sfxSlider.value = audioManager.getSfxVolume() * 100;
        musicValue.textContent = Math.round(musicSlider.value) + '%';
        sfxValue.textContent = Math.round(sfxSlider.value) + '%';

        // Music volume slider
        musicSlider.addEventListener('input', (e) => {
            const vol = e.target.value / 100;
            audioManager.setMusicVolume(vol);
            musicValue.textContent = Math.round(e.target.value) + '%';
        });

        // SFX volume slider
        sfxSlider.addEventListener('input', (e) => {
            const vol = e.target.value / 100;
            audioManager.setSfxVolume(vol);
            sfxValue.textContent = Math.round(e.target.value) + '%';
        });

        // Resume button
        document.getElementById('resume-button').addEventListener('click', () => {
            this.togglePause();
        });

        // Quit button
        document.getElementById('quit-button').addEventListener('click', () => {
            this.isPaused = false;
            document.getElementById('pause-screen').classList.remove('visible');
            this.returnToMenu();
        });

        // V4 INFINITE: Inventory close button
        document.getElementById('inventory-close').addEventListener('click', () => {
            this.closeInventory();
        });

        // V4 INFINITE: Inventory sort buttons
        document.querySelectorAll('.sort-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const sortType = btn.getAttribute('data-sort');
                if (this.player && this.player.inventory) {
                    if (sortType === 'rarity') this.player.inventory.sortByRarity();
                    else if (sortType === 'type') this.player.inventory.sortByType();
                    else if (sortType === 'value') this.player.inventory.sortByValue();
                    this.refreshInventoryUI();
                }
            });
        });

        // V4 INFINITE: Equipment slot click to unequip
        document.querySelectorAll('.equip-slot').forEach(slot => {
            slot.addEventListener('click', () => {
                const slotName = slot.getAttribute('data-slot');
                if (this.player && this.player.equipment.slots[slotName]) {
                    this.player.unequipItem(slotName);
                    this.refreshInventoryUI();
                }
            });

            slot.addEventListener('mouseenter', (e) => {
                const slotName = slot.getAttribute('data-slot');
                if (this.player && this.player.equipment.slots[slotName]) {
                    this.showItemTooltip(this.player.equipment.slots[slotName], e);
                }
            });

            slot.addEventListener('mouseleave', () => {
                this.hideItemTooltip();
            });
        });
    }

    returnToMenu() {
        // Clean up current game
        this.state = GameState.MENU;

        // Reset game state
        if (this.player) {
            if (this.player.mesh) this.scene.remove(this.player.mesh);
            this.player = null;
        }

        // Clear enemies
        for (const enemy of this.enemies) {
            if (enemy.mesh) this.scene.remove(enemy.mesh);
        }
        this.enemies = [];

        // V3: Clear health drops
        for (const drop of this.healthDrops) {
            drop.dispose();
        }
        this.healthDrops = [];

        // Show start screen, hide gameplay UI
        document.getElementById('start-screen').style.display = 'flex';
        document.getElementById('hud').classList.remove('visible');
        document.getElementById('crosshair').classList.remove('visible');
        document.exitPointerLock();
    }

    loadHighScore() {
        try {
            const saved = localStorage.getItem('chronophage_highscore');
            return saved ? parseInt(saved, 10) : 0;
        } catch (e) {
            return 0;
        }
    }

    saveHighScore() {
        try {
            localStorage.setItem('chronophage_highscore', this.highScore.toString());
        } catch (e) {
            // localStorage not available
        }
    }

    updateHighScoreDisplay() {
        const display = document.getElementById('high-score-display');
        const value = document.getElementById('high-score-value');
        if (this.highScore > 0) {
            display.style.display = 'block';
            value.textContent = this.highScore.toLocaleString();
        }

        // Populate debug wave selector
        this.setupDebugWaveSelector();
    }

    setupDebugWaveSelector() {
        const grid = document.getElementById('debug-wave-grid');
        if (!grid || grid.children.length > 0) return; // Already populated

        for (let i = 1; i <= 50; i++) {
            const btn = document.createElement('button');
            btn.className = 'debug-wave-btn';
            if (i % 10 === 0) btn.classList.add('boss-wave');
            btn.textContent = i;
            btn.onclick = (e) => {
                e.stopPropagation(); // Don't trigger start screen click
                this.debugStartWave = i - 1; // Will be incremented on startNextWave
                this.startGame();
            };
            grid.appendChild(btn);
        }
    }

    showVictoryScreen() {
        this.state = GameState.MENU;

        // Update victory stats
        document.getElementById('victory-score').textContent = this.score.toLocaleString();

        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        document.getElementById('victory-time').textContent =
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        document.getElementById('victory-kills').textContent = this.totalKills;

        // Show victory screen
        document.getElementById('victory-screen').classList.add('visible');
        document.getElementById('hud').classList.remove('visible');
        document.getElementById('crosshair').classList.remove('visible');
        document.exitPointerLock();

        // Check for high score
        if (this.score > this.highScore) {
            this.highScore = this.score;
            this.saveHighScore();
        }

        // Add click handler to return to menu
        document.getElementById('victory-screen').onclick = () => {
            document.getElementById('victory-screen').classList.remove('visible');
            this.returnToMenu();
        };

        // Play victory sound if available
        if (audioManager.playVictory) {
            audioManager.playVictory();
        }
    }

    updateCamera() {
        // V2 Third-person orbit camera - proper follow behavior
        if (!this.player) return;

        // Target position (player upper body)
        const targetLookAt = this.player.position.clone();
        targetLookAt.y += 1.5;

        // Dynamic distance - pull back during combat for better visibility
        const nearbyEnemies = this.enemies.filter(e =>
            e.isAlive &&
            e.mesh.position.distanceTo(this.player.position) < 15
        ).length;

        const targetDistance = nearbyEnemies > 0
            ? this.cameraDistance * CONFIG.cameraCombatPullback
            : this.cameraDistance;

        // Smooth the combat distance transition
        this.cameraCombatDistance = THREE.MathUtils.lerp(
            this.cameraCombatDistance,
            targetDistance,
            this.deltaTime * 3
        );

        // Calculate camera position using spherical coordinates
        // Camera orbits around player based on yaw (horizontal) and pitch (vertical)
        const horizontalDistance = Math.cos(this.cameraPitch) * this.cameraCombatDistance;
        const verticalDistance = Math.sin(this.cameraPitch) * this.cameraCombatDistance;

        const cameraOffset = new THREE.Vector3(
            Math.sin(this.cameraYaw) * horizontalDistance,
            verticalDistance + CONFIG.cameraHeight,
            Math.cos(this.cameraYaw) * horizontalDistance
        );

        // Target camera position
        const targetCameraPos = this.player.position.clone().add(cameraOffset);

        // Smooth camera movement with proper lerp factor
        const lerpFactor = Math.min(1, CONFIG.cameraSmoothness * 60 * this.deltaTime);
        this.cameraActualPosition.lerp(targetCameraPos, lerpFactor);

        // Apply camera position
        this.camera.position.copy(this.cameraActualPosition);

        // Apply screen shake (with recovery)
        if (this.cameraShakeOffset.lengthSq() > 0.0001) {
            this.camera.position.add(this.cameraShakeOffset);
            // Recover from shake
            this.cameraShakeOffset.multiplyScalar(1 - CONFIG.cameraShakeRecovery * this.deltaTime);
        }

        // Apply screen effects shake on top
        this.screenEffects.applyToCamera(this.camera);

        // Smooth look target
        this.cameraTarget.lerp(targetLookAt, lerpFactor);
        this.camera.lookAt(this.cameraTarget);
    }

    // V2 Camera shake that recovers smoothly
    addCameraShake(intensity, duration = 0.1) {
        const shakeX = (Math.random() - 0.5) * intensity;
        const shakeY = (Math.random() - 0.5) * intensity;
        const shakeZ = (Math.random() - 0.5) * intensity;
        this.cameraShakeOffset.set(shakeX, shakeY, shakeZ);
    }

    // â”€â”€â”€ V4 INFINITE: INVENTORY SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    openInventory() {
        this.previousState = this.state;
        this.state = GameState.INVENTORY;
        document.getElementById('inventory-screen').classList.add('visible');
        document.exitPointerLock();
        this.refreshInventoryUI();
    }

    closeInventory() {
        this.state = this.previousState || GameState.PLAYING;
        document.getElementById('inventory-screen').classList.remove('visible');
        this.hideItemTooltip(); // Hide any lingering tooltip
        document.body.requestPointerLock();
    }

    refreshInventoryUI() {
        if (!this.player) return;

        const inventory = this.player.inventory;
        const equipment = this.player.equipment;

        // Update gold display
        document.getElementById('inventory-gold').textContent = inventory.gold;
        document.getElementById('gold-value').textContent = inventory.gold;

        // Update backpack count
        const slots = inventory.getSlotCount();
        document.getElementById('backpack-used').textContent = slots.used;
        document.getElementById('backpack-max').textContent = slots.max;

        // Update equipment slots
        for (const slotName in equipment.slots) {
            const slotEl = document.getElementById(`slot-${slotName}`);
            if (!slotEl) continue;

            const item = equipment.slots[slotName];
            slotEl.className = 'equip-slot';
            slotEl.setAttribute('data-slot', slotName);

            // Remove old event listeners by cloning the element
            const newSlotEl = slotEl.cloneNode(true);
            slotEl.parentNode.replaceChild(newSlotEl, slotEl);

            if (item) {
                newSlotEl.classList.add('has-item');
                newSlotEl.classList.add(`rarity-${item.rarity.toLowerCase()}`);
                const rarityData = RARITY[item.rarity];
                const slotIcon = newSlotEl.querySelector('.slot-icon');
                slotIcon.innerHTML = `<span style="color: ${rarityData.color}; text-shadow: 0 0 8px ${rarityData.color};">${item.icon}</span>`;

                // Add tooltip hover events for equipped items
                newSlotEl.addEventListener('mouseenter', (e) => this.showItemTooltipBelow(item, newSlotEl));
                newSlotEl.addEventListener('mouseleave', () => this.hideItemTooltip());

                // Right-click to unequip back to inventory
                newSlotEl.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    this.unequipItem(slotName);
                });
            } else {
                // Default icons
                const defaultIcons = {
                    helmet: 'ðŸŽ­', armor: 'ðŸ›¡', boots: 'ðŸ‘¢',
                    sword: 'âš”', gun: 'ðŸ”«', scythe: 'âš°',
                    shield: 'ðŸ”°', trinket1: 'ðŸ’', trinket2: 'ðŸ’'
                };
                newSlotEl.querySelector('.slot-icon').textContent = defaultIcons[slotName] || 'â“';
            }
        }

        // Update stats display
        const stats = equipment.bonusStats;
        document.getElementById('stat-damage').textContent = `+${stats.damage || 0}%`;
        document.getElementById('stat-crit').textContent = `${stats.critChance || 0}%`;
        document.getElementById('stat-atkspd').textContent = `+${stats.attackSpeed || 0}%`;
        document.getElementById('stat-armor').textContent = stats.armor || 0;
        document.getElementById('stat-movespd').textContent = `+${stats.moveSpeed || 0}%`;

        // Populate backpack grid
        const backpackGrid = document.getElementById('backpack-grid');
        backpackGrid.innerHTML = '';

        for (const item of inventory.items) {
            const itemEl = document.createElement('div');
            itemEl.className = `backpack-item rarity-${item.rarity.toLowerCase()}`;
            const rarityData = RARITY[item.rarity];
            itemEl.innerHTML = `<span style="color: ${rarityData.color}; text-shadow: 0 0 8px ${rarityData.color};">${item.icon}</span>`;
            itemEl.setAttribute('data-item-id', item.id);

            // Hover for tooltip - position below the item
            itemEl.addEventListener('mouseenter', (e) => this.showItemTooltipBelow(item, itemEl));
            itemEl.addEventListener('mouseleave', () => this.hideItemTooltip());

            // Click to equip
            itemEl.addEventListener('click', () => {
                this.equipItemFromInventory(item);
            });

            // Right-click to sell
            itemEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                this.sellItem(item);
            });

            backpackGrid.appendChild(itemEl);
        }
    }

    showItemTooltip(item, event) {
        this.populateTooltip(item);
        const tooltip = document.getElementById('item-tooltip');
        tooltip.classList.add('visible');
        this.updateTooltipPosition(event);
    }

    showItemTooltipBelow(item, element) {
        this.populateTooltip(item);
        const tooltip = document.getElementById('item-tooltip');
        tooltip.classList.add('visible');
        this.positionTooltipBelowElement(element);
    }

    populateTooltip(item) {
        const tooltip = document.getElementById('item-tooltip');
        const rarityData = RARITY[item.rarity];

        document.getElementById('tooltip-name').textContent = item.name;
        document.getElementById('tooltip-name').style.color = rarityData.color;
        document.getElementById('tooltip-rarity').textContent = item.rarity;
        document.getElementById('tooltip-rarity').className = `tooltip-rarity ${item.rarity.toLowerCase()}`;
        document.getElementById('tooltip-type').textContent = `${item.type} - ${item.subtype}`;

        // Stats
        const statsEl = document.getElementById('tooltip-stats');
        statsEl.innerHTML = '';
        for (const [stat, value] of Object.entries(item.stats)) {
            const statDiv = document.createElement('div');
            const formatted = formatStatName(stat);
            const isPercent = isPercentStat(stat);
            statDiv.textContent = `+${value}${isPercent ? '%' : ''} ${formatted}`;
            statsEl.appendChild(statDiv);
        }

        // Ability
        const abilityEl = document.getElementById('tooltip-ability');
        if (item.abilities && item.abilities.length > 0) {
            const abilityTexts = item.abilities.map(a => `${a.name}: ${a.description}`).join('\n');
            abilityEl.textContent = abilityTexts;
            abilityEl.style.display = 'block';
        } else {
            abilityEl.style.display = 'none';
        }

        // Flavor text / lore
        const flavorEl = document.getElementById('tooltip-flavor');
        if (item.lore) {
            flavorEl.textContent = `"${item.lore}"`;
            flavorEl.style.display = 'block';
        } else if (item.description) {
            flavorEl.textContent = item.description;
            flavorEl.style.display = 'block';
        } else {
            flavorEl.style.display = 'none';
        }

        // Value
        document.getElementById('tooltip-value').textContent = item.value;
    }

    positionTooltipBelowElement(element) {
        const tooltip = document.getElementById('item-tooltip');
        const elemRect = element.getBoundingClientRect();
        const tooltipWidth = 280;
        const tooltipHeight = tooltip.offsetHeight || 300;
        const padding = 10;

        // Position below the element, centered horizontally
        let x = elemRect.left + (elemRect.width / 2) - (tooltipWidth / 2);
        let y = elemRect.bottom + padding;

        // If tooltip goes off bottom, position above the element
        if (y + tooltipHeight > window.innerHeight - 10) {
            y = elemRect.top - tooltipHeight - padding;
        }

        // Keep within horizontal bounds
        if (x < 10) {
            x = 10;
        }
        if (x + tooltipWidth > window.innerWidth - 10) {
            x = window.innerWidth - tooltipWidth - 10;
        }

        // Keep within vertical bounds
        if (y < 10) {
            y = 10;
        }

        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
    }

    hideItemTooltip() {
        document.getElementById('item-tooltip').classList.remove('visible');
    }

    updateTooltipPosition(event) {
        const tooltip = document.getElementById('item-tooltip');
        const padding = 20;

        // Get actual tooltip dimensions
        const rect = tooltip.getBoundingClientRect();
        const tooltipWidth = rect.width || 280;
        const tooltipHeight = rect.height || 300;

        // Start with position to the left of cursor (safer default)
        let x = event.clientX - tooltipWidth - padding;
        let y = event.clientY - tooltipHeight / 2;

        // If too far left, try right side
        if (x < 10) {
            x = event.clientX + padding;
        }

        // If still going off right edge, clamp it
        if (x + tooltipWidth > window.innerWidth - 10) {
            x = window.innerWidth - tooltipWidth - 10;
        }

        // Vertical bounds check
        if (y < 10) {
            y = 10;
        }
        if (y + tooltipHeight > window.innerHeight - 10) {
            y = window.innerHeight - tooltipHeight - 10;
        }

        tooltip.style.left = x + 'px';
        tooltip.style.top = y + 'px';
    }

    equipItemFromInventory(item) {
        if (!this.player) return;

        // Hide tooltip before refreshing UI (item element will be replaced)
        this.hideItemTooltip();

        // Remove from inventory
        this.player.inventory.removeItem(item);

        // Equip (returns old item if any)
        this.player.equipItem(item);

        this.refreshInventoryUI();
    }

    unequipItem(slotName) {
        if (!this.player) return;

        const item = this.player.equipment.slots[slotName];
        if (!item) return;

        // Check if inventory has space
        if (this.player.inventory.isFull()) {
            this.showLootNotification('Inventory full!', '#ff4444');
            return;
        }

        // Hide tooltip before refreshing UI
        this.hideItemTooltip();

        // Remove from equipment
        this.player.equipment.unequip(slotName);

        // Add to inventory
        this.player.inventory.addItem(item);

        this.refreshInventoryUI();
    }

    sellItem(item) {
        if (!this.player) return;

        // Hide tooltip before refreshing UI
        this.hideItemTooltip();

        // Calculate sell value (50% of shop price)
        const sellValue = this.calculateSellValue(item);

        // Remove from inventory and add gold
        this.player.inventory.removeItem(item);
        this.player.inventory.addGold(sellValue);

        this.showLootNotification(`Sold for ${sellValue} gold`, '#ffd700');
        audioManager.playGoldPickup();

        this.refreshInventoryUI();
    }

    // â”€â”€â”€ V4 INFINITE: SHOP SYSTEM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    openShop() {
        this.previousState = this.state;
        this.state = GameState.SHOP;
        document.getElementById('shop-screen').classList.add('visible');
        document.exitPointerLock();

        // Generate shop items
        this.generateShopItems();
        this.refreshShopUI();

        // Setup shop buttons
        document.getElementById('shop-continue').onclick = () => this.closeShop();
        document.getElementById('shop-reroll').onclick = () => this.rerollShop();
    }

    closeShop() {
        this.state = GameState.PLAYING;
        document.getElementById('shop-screen').classList.remove('visible');
        this.hideItemTooltip(); // Hide any lingering tooltip
        document.body.requestPointerLock();

        // Continue to next wave
        this.startNextWave();
    }

    generateShopItems() {
        this.shopItems = [];
        const numItems = 4;
        const waveBonus = this.wave * 2;

        for (let i = 0; i < numItems; i++) {
            const item = lootGenerator.generateItem(null, null, this.wave);
            if (item) {
                // Shop prices are higher than sell values
                item.shopPrice = Math.floor(item.value * 2.5);
                this.shopItems.push(item);
            }
        }
    }

    rerollShop() {
        if (!this.player || !this.player.inventory.spendGold(50)) {
            return; // Not enough gold
        }

        this.generateShopItems();
        this.refreshShopUI();
    }

    refreshShopUI() {
        if (!this.player) return;

        document.getElementById('shop-gold').textContent = this.player.inventory.gold;

        const shopContainer = document.getElementById('shop-items');
        shopContainer.innerHTML = '';

        for (let i = 0; i < this.shopItems.length; i++) {
            const item = this.shopItems[i];
            if (!item) continue;

            const rarityData = RARITY[item.rarity];
            const canAfford = this.player.inventory.gold >= item.shopPrice;

            const itemEl = document.createElement('div');
            itemEl.className = `shop-item rarity-${item.rarity.toLowerCase()}`;
            if (!canAfford) itemEl.classList.add('cant-afford');
            if (item.sold) itemEl.classList.add('sold');

            // Build stats HTML
            let statsHtml = '';
            if (item.stats) {
                for (const [stat, value] of Object.entries(item.stats)) {
                    const formatted = formatStatName(stat);
                    const isPercent = isPercentStat(stat);
                    statsHtml += `<div class="shop-item-stat">+${value}${isPercent ? '%' : ''} ${formatted}</div>`;
                }
            }

            // Add ability if present
            let abilityHtml = '';
            if (item.ability) {
                abilityHtml = `<div class="shop-item-ability">${item.ability}</div>`;
            }

            itemEl.innerHTML = `
                <div class="shop-item-icon" style="color: ${rarityData.color}; text-shadow: 0 0 10px ${rarityData.color};">${item.icon}</div>
                <div class="shop-item-name" style="color: ${rarityData.color}">${item.name}</div>
                <div class="shop-item-type">${item.type}${item.subtype ? ' - ' + item.subtype : ''}</div>
                <div class="shop-item-rarity" style="color: ${rarityData.color}">${item.rarity}</div>
                <div class="shop-item-stats">${statsHtml}</div>
                ${abilityHtml}
                <div class="shop-item-price">ðŸ’° ${item.shopPrice}</div>
            `;

            itemEl.addEventListener('click', () => this.buyShopItem(i));

            shopContainer.appendChild(itemEl);
        }

        // Update reroll button state
        const rerollBtn = document.getElementById('shop-reroll');
        rerollBtn.disabled = this.player.inventory.gold < 50;

        // Populate shop inventory grid
        this.refreshShopInventory();
    }

    refreshShopInventory() {
        if (!this.player) return;

        const invGrid = document.getElementById('shop-inventory-grid');
        if (!invGrid) return;
        invGrid.innerHTML = '';

        for (const item of this.player.inventory.items) {
            const rarityData = RARITY[item.rarity];
            const sellValue = this.calculateSellValue(item);

            const itemEl = document.createElement('div');
            itemEl.className = `shop-inventory-item rarity-${item.rarity.toLowerCase()}`;
            itemEl.innerHTML = `
                <span style="color: ${rarityData.color}; text-shadow: 0 0 8px ${rarityData.color};">${item.icon}</span>
                <span class="sell-value">${sellValue}ðŸ’°</span>
            `;

            // Hover for tooltip
            itemEl.addEventListener('mouseenter', (e) => this.showItemTooltipBelow(item, itemEl));
            itemEl.addEventListener('mouseleave', () => this.hideItemTooltip());

            // Right-click to sell
            itemEl.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.sellItemInShop(item, sellValue);
            });

            // Also allow left-click to sell in shop (for convenience)
            itemEl.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                this.sellItemInShop(item, sellValue);
            });

            invGrid.appendChild(itemEl);
        }
    }

    calculateSellValue(item) {
        // Sell value is always 50% of shop purchase price
        // Shop price is item.value * 2.5, so sell price = shopPrice * 0.5
        if (item.shopPrice) {
            return Math.max(1, Math.floor(item.shopPrice * 0.5));
        }
        // For items without shopPrice (from loot drops), calculate what shop price would be
        const shopPrice = Math.floor((item.value || 10) * 2.5);
        return Math.max(1, Math.floor(shopPrice * 0.5));
    }

    sellItemInShop(item, sellValue) {
        if (!this.player || !item) return;

        // Hide tooltip before refreshing UI
        this.hideItemTooltip();

        // Remove from inventory
        const index = this.player.inventory.items.findIndex(i => i.id === item.id);
        if (index === -1) return;

        this.player.inventory.items.splice(index, 1);
        this.player.inventory.gold += sellValue;

        // Play sound and show notification
        try {
            audioManager.playGoldPickup();
        } catch (e) {
            console.error('Audio error:', e);
        }
        this.showLootNotification(`Sold ${item.name} for ${sellValue}ðŸ’°`, '#ffd700');

        // Refresh UI
        this.refreshShopUI();
    }

    buyShopItem(index) {
        if (!this.player) return;

        const item = this.shopItems[index];
        if (!item || item.sold) return;

        if (!this.player.inventory.spendGold(item.shopPrice)) {
            return; // Can't afford
        }

        // Hide tooltip before refreshing UI
        this.hideItemTooltip();

        if (this.player.inventory.isFull()) {
            // Auto-equip if inventory full
            this.player.equipItem(item);
            this.showLootNotification(`Equipped ${item.name}!`, RARITY[item.rarity].color);
        } else {
            this.player.inventory.addItem(item);
            this.showLootNotification(`Acquired ${item.name}!`, RARITY[item.rarity].color);
        }

        item.sold = true;
        this.refreshShopUI();
    }

    // â”€â”€â”€ V4 INFINITE: HUD UPDATES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    updateShieldHUD() {
        if (!this.player || !this.player.shieldSystem) return;

        const shield = this.player.shieldSystem;
        const percent = shield.getShieldHealthPercent() * 100;

        const shieldFill = document.getElementById('shield-fill');
        const shieldValue = document.getElementById('shield-value');
        const shieldBar = document.querySelector('.shield-bar');

        if (shieldFill) {
            shieldFill.style.width = `${percent}%`;
        }
        if (shieldValue) {
            shieldValue.textContent = Math.ceil(shield.shieldHealth);
        }
        if (shieldBar) {
            if (shield.isBroken) {
                shieldBar.classList.add('broken');
            } else {
                shieldBar.classList.remove('broken');
            }
        }
    }

    updateGoldHUD() {
        if (!this.player || !this.player.inventory) return;
        document.getElementById('gold-value').textContent = this.player.inventory.gold;
    }

    showLootNotification(message, color = '#ffffff') {
        // Create floating notification
        const notification = document.createElement('div');
        notification.style.cssText = `
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: ${color};
            text-shadow: 0 0 10px ${color}, 0 2px 4px rgba(0,0,0,0.8);
            pointer-events: none;
            animation: loot-float 2s ease-out forwards;
            z-index: 300;
        `;
        notification.textContent = message;

        // Add animation style if not exists
        if (!document.getElementById('loot-animation-style')) {
            const style = document.createElement('style');
            style.id = 'loot-animation-style';
            style.textContent = `
                @keyframes loot-float {
                    0% { opacity: 0; transform: translateX(-50%) translateY(20px); }
                    20% { opacity: 1; transform: translateX(-50%) translateY(0); }
                    80% { opacity: 1; }
                    100% { opacity: 0; transform: translateX(-50%) translateY(-30px); }
                }
            `;
            document.head.appendChild(style);
        }

        document.body.appendChild(notification);
        setTimeout(() => notification.remove(), 2000);
    }

    // Check if shop should appear after wave
    checkForShop() {
        // V4 INFINITE: Shop cycle within 10-wave blocks
        // Shops appear at waves 3, 6, and 10 (after boss) within each block
        // Wave 10, 20, 30, etc. = boss waves, shop appears AFTER boss chest is opened

        const waveInCycle = ((this.wave - 1) % 10) + 1; // 1-10 within cycle
        const isBossWave = this.wave > 0 && this.wave % 10 === 0;

        // Shop at wave 3 and 6 in cycle (not at 9, moved to after boss)
        if (waveInCycle === 3 || waveInCycle === 6) {
            this.openShop();
            return true;
        }

        // Shop after boss wave (wave 10, 20, 30, etc.) - only after chest is opened
        if (isBossWave && !this.awaitingChestOpen) {
            this.openShop();
            return true;
        }

        return false;
    }
}

// â”€â”€â”€ ARENA CLASS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class Arena {
    constructor(scene) {
        this.scene = scene;
        this.floorClock = null;
        this.clockHands = [];
        this.temporalStreams = [];
        this.floatingDebris = [];
        this.particles = [];
        this.pillars = [];
        this.torches = [];
        this.torchLights = [];

        this.createFloor();
        this.createClockPattern();
        this.createPillarsAndTorches();
        this.createTemporalStreams();
        this.createFloatingDebris();
        this.createAmbientParticles();
        this.createSkybox();
    }

    createFloor() {
        // Main arena floor - circular platform
        const floorGeometry = new THREE.CylinderGeometry(
            CONFIG.arenaRadius,
            CONFIG.arenaRadius + 2,
            2,
            64
        );

        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            roughness: 0.7,
            metalness: 0.3
        });

        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -1;
        floor.frustumCulled = false; // Prevent disappearing at certain camera angles
        this.scene.add(floor);
        this.floor = floor; // Store reference

        // Floor edge glow ring
        const edgeGeometry = new THREE.TorusGeometry(CONFIG.arenaRadius + 0.5, 0.3, 8, 64);
        const edgeMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a90b8,
            transparent: true,
            opacity: 0.6,
            depthWrite: false
        });
        const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
        edge.rotation.x = Math.PI / 2;
        edge.position.y = 0.1;
        edge.frustumCulled = false;
        this.scene.add(edge);

        // Inner glow ring
        const innerEdgeGeometry = new THREE.TorusGeometry(CONFIG.arenaRadius - 1, 0.15, 8, 64);
        const innerEdgeMaterial = new THREE.MeshBasicMaterial({
            color: 0xd4af37,
            transparent: true,
            opacity: 0.4,
            depthWrite: false
        });
        const innerEdge = new THREE.Mesh(innerEdgeGeometry, innerEdgeMaterial);
        innerEdge.rotation.x = Math.PI / 2;
        innerEdge.position.y = 0.1;
        innerEdge.frustumCulled = false;
        this.scene.add(innerEdge);
    }

    createClockPattern() {
        // Clock face pattern on the floor
        const clockGroup = new THREE.Group();

        // Center hub
        const hubGeometry = new THREE.CylinderGeometry(3, 3, 0.3, 32);
        const hubMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.3,
            metalness: 0.8,
            roughness: 0.2
        });
        const hub = new THREE.Mesh(hubGeometry, hubMaterial);
        hub.position.y = 0.15;
        clockGroup.add(hub);

        // Roman numerals positions (12 positions around the clock)
        const numerals = ['XII', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI'];
        const numeralRadius = CONFIG.arenaRadius - 5;

        for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI * 2) / 12 - Math.PI / 2;
            const x = Math.cos(angle) * numeralRadius;
            const z = Math.sin(angle) * numeralRadius;

            // Numeral marker (glowing circle)
            const markerGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 16);
            const markerMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a90b8,
                emissive: 0x4a90b8,
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.8,
                depthWrite: false
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.1, z);
            clockGroup.add(marker);

            // Connecting line from center
            const lineGeometry = new THREE.BoxGeometry(0.2, 0.1, numeralRadius - 5);
            const lineMaterial = new THREE.MeshBasicMaterial({
                color: 0x2a4a6a,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set(
                Math.cos(angle) * (numeralRadius / 2 - 1),
                0.05,
                Math.sin(angle) * (numeralRadius / 2 - 1)
            );
            line.rotation.y = -angle + Math.PI / 2;
            clockGroup.add(line);
        }

        // Hour tick marks (60 small marks)
        for (let i = 0; i < 60; i++) {
            const angle = (i * Math.PI * 2) / 60 - Math.PI / 2;
            const isHourMark = i % 5 === 0;
            const markRadius = CONFIG.arenaRadius - 8;
            const markLength = isHourMark ? 2 : 1;

            const markGeometry = new THREE.BoxGeometry(0.15, 0.1, markLength);
            const markMaterial = new THREE.MeshBasicMaterial({
                color: isHourMark ? 0xd4af37 : 0x3a5a7a,
                transparent: true,
                opacity: isHourMark ? 0.8 : 0.4,
                depthWrite: false
            });
            const mark = new THREE.Mesh(markGeometry, markMaterial);
            mark.position.set(
                Math.cos(angle) * markRadius,
                0.05,
                Math.sin(angle) * markRadius
            );
            mark.rotation.y = -angle + Math.PI / 2;
            clockGroup.add(mark);
        }

        // Clock hands (decorative, slowly moving)
        // Hour hand
        const hourHandGeometry = new THREE.BoxGeometry(1, 0.3, 15);
        const hourHandMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.1
        });
        const hourHand = new THREE.Mesh(hourHandGeometry, hourHandMaterial);
        hourHand.position.set(0, 0.2, 7.5);

        const hourHandPivot = new THREE.Group();
        hourHandPivot.add(hourHand);
        hourHandPivot.position.y = 0;
        this.clockHands.push({ pivot: hourHandPivot, speed: 0.01 });
        clockGroup.add(hourHandPivot);

        // Minute hand
        const minuteHandGeometry = new THREE.BoxGeometry(0.6, 0.25, 22);
        const minuteHandMaterial = new THREE.MeshStandardMaterial({
            color: 0x7eb8da,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.3,
            metalness: 0.9,
            roughness: 0.1
        });
        const minuteHand = new THREE.Mesh(minuteHandGeometry, minuteHandMaterial);
        minuteHand.position.set(0, 0.35, 11);

        const minuteHandPivot = new THREE.Group();
        minuteHandPivot.add(minuteHand);
        minuteHandPivot.position.y = 0;
        minuteHandPivot.rotation.y = Math.PI / 3;
        this.clockHands.push({ pivot: minuteHandPivot, speed: 0.12 });
        clockGroup.add(minuteHandPivot);

        // Concentric rings
        for (let r = 10; r < CONFIG.arenaRadius - 2; r += 8) {
            const ringGeometry = new THREE.TorusGeometry(r, 0.1, 8, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x2a4a6a,
                transparent: true,
                opacity: 0.3,
                depthWrite: false
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.05;
            clockGroup.add(ring);
        }

        // Disable frustum culling on all clock pattern elements to prevent disappearing
        clockGroup.traverse((child) => {
            if (child.isMesh) {
                child.frustumCulled = false;
            }
        });

        this.scene.add(clockGroup);
        this.floorClock = clockGroup;
    }

    createPillarsAndTorches() {
        // 12 pillars at clock positions around the arena edge
        const pillarRadius = CONFIG.arenaRadius - 3;

        for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI * 2) / 12 - Math.PI / 2;
            const x = Math.cos(angle) * pillarRadius;
            const z = Math.sin(angle) * pillarRadius;

            // Create pillar group
            const pillarGroup = new THREE.Group();
            pillarGroup.position.set(x, 0, z);
            pillarGroup.rotation.y = -angle;

            // Pillar materials
            const stoneMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a3e,
                roughness: 0.8,
                metalness: 0.2
            });

            const goldMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4af37,
                emissive: 0xd4af37,
                emissiveIntensity: 0.2,
                metalness: 0.9,
                roughness: 0.2
            });

            // Base
            const baseGeom = new THREE.BoxGeometry(2.5, 0.5, 2.5);
            const base = new THREE.Mesh(baseGeom, stoneMaterial);
            base.position.y = 0.25;
            base.castShadow = true;
            base.receiveShadow = true;
            pillarGroup.add(base);

            // Main column
            const columnGeom = new THREE.CylinderGeometry(0.8, 1, 8, 8);
            const column = new THREE.Mesh(columnGeom, stoneMaterial);
            column.position.y = 4.5;
            column.castShadow = true;
            pillarGroup.add(column);

            // Column details - rings
            for (let r = 0; r < 3; r++) {
                const ringGeom = new THREE.TorusGeometry(0.9, 0.1, 8, 16);
                const ring = new THREE.Mesh(ringGeom, goldMaterial);
                ring.position.y = 2 + r * 2.5;
                ring.rotation.x = Math.PI / 2;
                pillarGroup.add(ring);
            }

            // Capital (top decorative piece)
            const capitalGeom = new THREE.BoxGeometry(2, 0.8, 2);
            const capital = new THREE.Mesh(capitalGeom, stoneMaterial);
            capital.position.y = 8.9;
            pillarGroup.add(capital);

            // Clock face on pillar
            const clockFaceGeom = new THREE.CircleGeometry(0.6, 16);
            const clockFaceMat = new THREE.MeshBasicMaterial({
                color: 0xeeeedd,
                side: THREE.DoubleSide
            });
            const clockFace = new THREE.Mesh(clockFaceGeom, clockFaceMat);
            clockFace.position.set(0, 5, 0.85);
            pillarGroup.add(clockFace);

            // Clock face rim
            const clockRimGeom = new THREE.TorusGeometry(0.65, 0.08, 8, 16);
            const clockRim = new THREE.Mesh(clockRimGeom, goldMaterial);
            clockRim.position.set(0, 5, 0.85);
            pillarGroup.add(clockRim);

            // Torch holder
            const holderGeom = new THREE.BoxGeometry(0.3, 0.8, 0.5);
            const holder = new THREE.Mesh(holderGeom, goldMaterial);
            holder.position.set(0, 7, 1.2);
            pillarGroup.add(holder);

            // Torch bowl
            const bowlGeom = new THREE.CylinderGeometry(0.3, 0.2, 0.4, 8);
            const bowl = new THREE.Mesh(bowlGeom, goldMaterial);
            bowl.position.set(0, 7.5, 1.2);
            pillarGroup.add(bowl);

            // Torch flame (animated glow sphere)
            const flameGeom = new THREE.SphereGeometry(0.25, 8, 8);
            const flameMat = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.9
            });
            const flame = new THREE.Mesh(flameGeom, flameMat);
            flame.position.set(0, 7.8, 1.2);
            pillarGroup.add(flame);

            // Torch light
            const torchLight = new THREE.PointLight(0xff6600, 0.8, 12);
            torchLight.position.set(0, 8, 1.2);
            pillarGroup.add(torchLight);

            this.scene.add(pillarGroup);
            this.pillars.push(pillarGroup);
            this.torches.push(flame);
            this.torchLights.push(torchLight);
        }
    }

    createTemporalStreams() {
        // Golden energy streams rising from the void at arena edge
        const streamCount = 16;

        for (let i = 0; i < streamCount; i++) {
            const angle = (i * Math.PI * 2) / streamCount;
            const x = Math.cos(angle) * (CONFIG.arenaRadius + 3);
            const z = Math.sin(angle) * (CONFIG.arenaRadius + 3);

            // Stream particles (vertical line of glowing points)
            const streamGroup = new THREE.Group();
            streamGroup.position.set(x, 0, z);

            const particleCount = 20;
            for (let j = 0; j < particleCount; j++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xd4af37,
                    transparent: true,
                    opacity: 0.6 - (j / particleCount) * 0.4
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.y = j * 2 - 10;
                particle.userData.baseY = particle.position.y;
                particle.userData.offset = Math.random() * Math.PI * 2;
                streamGroup.add(particle);
            }

            this.temporalStreams.push(streamGroup);
            this.scene.add(streamGroup);
        }
    }

    createFloatingDebris() {
        // Floating clock gears and fragments in the background
        const debrisTypes = [
            { geometry: new THREE.TorusGeometry(2, 0.3, 8, 16), color: 0x8b7355 }, // Gear
            { geometry: new THREE.TorusGeometry(1.5, 0.2, 8, 12), color: 0x6b5344 }, // Small gear
            { geometry: new THREE.BoxGeometry(3, 0.5, 0.5), color: 0xd4af37 }, // Clock hand fragment
            { geometry: new THREE.CylinderGeometry(0.8, 0.8, 0.3, 16), color: 0x4a90b8 }, // Clock face fragment
        ];

        for (let i = 0; i < 30; i++) {
            const type = debrisTypes[Math.floor(Math.random() * debrisTypes.length)];
            const material = new THREE.MeshStandardMaterial({
                color: type.color,
                metalness: 0.6,
                roughness: 0.4,
                transparent: true,
                opacity: 0.7
            });

            const debris = new THREE.Mesh(type.geometry.clone(), material);

            // Random position in the void around the arena
            const angle = Math.random() * Math.PI * 2;
            const distance = CONFIG.arenaRadius + 15 + Math.random() * 40;
            const height = -10 + Math.random() * 50;

            debris.position.set(
                Math.cos(angle) * distance,
                height,
                Math.sin(angle) * distance
            );

            debris.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            debris.userData.rotationSpeed = {
                x: (Math.random() - 0.5) * 0.2,
                y: (Math.random() - 0.5) * 0.2,
                z: (Math.random() - 0.5) * 0.2
            };
            debris.userData.floatSpeed = 0.3 + Math.random() * 0.3;
            debris.userData.floatOffset = Math.random() * Math.PI * 2;
            debris.userData.baseY = debris.position.y;

            this.floatingDebris.push(debris);
            this.scene.add(debris);
        }
    }

    createAmbientParticles() {
        // Tiny golden motes floating in the air
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * CONFIG.arenaRadius;
            const height = Math.random() * 20;

            positions[i * 3] = Math.cos(angle) * distance;
            positions[i * 3 + 1] = height;
            positions[i * 3 + 2] = Math.sin(angle) * distance;

            // Gold/white colors
            const isGold = Math.random() > 0.3;
            if (isGold) {
                colors[i * 3] = 0.83;     // R
                colors[i * 3 + 1] = 0.69; // G
                colors[i * 3 + 2] = 0.22; // B
            } else {
                colors[i * 3] = 0.8;
                colors[i * 3 + 1] = 0.85;
                colors[i * 3 + 2] = 0.9;
            }
        }

        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        particleSystem.userData.velocities = [];

        for (let i = 0; i < particleCount; i++) {
            particleSystem.userData.velocities.push({
                x: (Math.random() - 0.5) * 0.5,
                y: (Math.random() - 0.5) * 0.3,
                z: (Math.random() - 0.5) * 0.5,
                frozen: false,
                freezeTimer: 0
            });
        }

        this.particles.push(particleSystem);
        this.scene.add(particleSystem);
    }

    createSkybox() {
        // Create a dark gradient skybox/background
        const skyGeometry = new THREE.SphereGeometry(200, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0a0a1a) },
                bottomColor: { value: new THREE.Color(0x000005) },
                offset: { value: 0 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide
        });

        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        this.scene.add(sky);

        // Add a massive gear in the sky (The Great Gear)
        const greatGearGeometry = new THREE.TorusGeometry(50, 5, 8, 32);
        const greatGearMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a3a,
            metalness: 0.8,
            roughness: 0.3,
            transparent: true,
            opacity: 0.4
        });
        const greatGear = new THREE.Mesh(greatGearGeometry, greatGearMaterial);
        greatGear.position.set(60, 80, -60);
        greatGear.rotation.x = Math.PI / 4;
        greatGear.rotation.z = Math.PI / 6;
        this.floatingDebris.push(greatGear);
        greatGear.userData.rotationSpeed = { x: 0, y: 0.02, z: 0 };
        greatGear.userData.floatSpeed = 0;
        greatGear.userData.baseY = greatGear.position.y;
        this.scene.add(greatGear);

        // Add gear teeth to great gear
        const teethCount = 24;
        for (let i = 0; i < teethCount; i++) {
            const angle = (i * Math.PI * 2) / teethCount;
            const toothGeometry = new THREE.BoxGeometry(8, 8, 5);
            const tooth = new THREE.Mesh(toothGeometry, greatGearMaterial.clone());
            tooth.position.set(
                Math.cos(angle) * 55,
                Math.sin(angle) * 55,
                0
            );
            tooth.rotation.z = angle;
            greatGear.add(tooth);
        }
    }

    update(deltaTime, elapsedTime) {
        // Rotate clock hands
        for (const hand of this.clockHands) {
            hand.pivot.rotation.y -= hand.speed * deltaTime;
        }

        // Animate torch flames and lights
        for (let i = 0; i < this.torches.length; i++) {
            const torch = this.torches[i];
            const light = this.torchLights[i];

            // Flickering flame scale
            const flicker = 0.8 + Math.sin(elapsedTime * 15 + i) * 0.15 +
                           Math.sin(elapsedTime * 23 + i * 2) * 0.1;
            torch.scale.setScalar(flicker);

            // Flickering light intensity
            light.intensity = 0.6 + Math.sin(elapsedTime * 12 + i) * 0.2 +
                             Math.sin(elapsedTime * 19 + i * 1.5) * 0.15;

            // Slight color variation
            const hue = 0.08 + Math.sin(elapsedTime * 8 + i) * 0.02;
            light.color.setHSL(hue, 1, 0.5);
        }

        // Animate temporal streams
        for (const stream of this.temporalStreams) {
            stream.children.forEach((particle, index) => {
                particle.position.y = particle.userData.baseY +
                    Math.sin(elapsedTime * 2 + particle.userData.offset) * 0.5 +
                    (elapsedTime * 3) % 40 - 20;

                // Wrap particles
                if (particle.position.y > 30) {
                    particle.position.y = -10;
                }
            });
        }

        // Animate floating debris
        for (const debris of this.floatingDebris) {
            debris.rotation.x += debris.userData.rotationSpeed.x * deltaTime;
            debris.rotation.y += debris.userData.rotationSpeed.y * deltaTime;
            debris.rotation.z += debris.userData.rotationSpeed.z * deltaTime;

            if (debris.userData.floatSpeed > 0) {
                debris.position.y = debris.userData.baseY +
                    Math.sin(elapsedTime * debris.userData.floatSpeed + debris.userData.floatOffset) * 2;
            }
        }

        // Animate ambient particles with occasional "time stutters"
        for (const particleSystem of this.particles) {
            const positions = particleSystem.geometry.attributes.position.array;
            const velocities = particleSystem.userData.velocities;

            for (let i = 0; i < velocities.length; i++) {
                const vel = velocities[i];

                // Random freeze (time stutter effect)
                if (!vel.frozen && Math.random() < 0.001) {
                    vel.frozen = true;
                    vel.freezeTimer = 0.3 + Math.random() * 0.5;
                }

                if (vel.frozen) {
                    vel.freezeTimer -= deltaTime;
                    if (vel.freezeTimer <= 0) {
                        vel.frozen = false;
                    }
                    continue;
                }

                // Move particles
                positions[i * 3] += vel.x * deltaTime;
                positions[i * 3 + 1] += vel.y * deltaTime;
                positions[i * 3 + 2] += vel.z * deltaTime;

                // Boundary check - wrap around arena
                const x = positions[i * 3];
                const z = positions[i * 3 + 2];
                const dist = Math.sqrt(x * x + z * z);

                if (dist > CONFIG.arenaRadius) {
                    const angle = Math.random() * Math.PI * 2;
                    const newDist = Math.random() * CONFIG.arenaRadius * 0.5;
                    positions[i * 3] = Math.cos(angle) * newDist;
                    positions[i * 3 + 2] = Math.sin(angle) * newDist;
                }

                // Height wrap
                if (positions[i * 3 + 1] > 20) {
                    positions[i * 3 + 1] = 0;
                } else if (positions[i * 3 + 1] < 0) {
                    positions[i * 3 + 1] = 20;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
    }
}

// â”€â”€â”€ INITIALIZATION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let game;

window.addEventListener('load', () => {
    game = new Game();
});

    </script>

    <!-- Global Item Tooltip (positioned at body level for proper z-index) -->
    <div class="item-tooltip" id="item-tooltip">
        <div class="tooltip-header">
            <span class="tooltip-name" id="tooltip-name">Item Name</span>
            <span class="tooltip-rarity" id="tooltip-rarity">COMMON</span>
        </div>
        <div class="tooltip-type" id="tooltip-type">Weapon - Sword</div>
        <div class="tooltip-stats" id="tooltip-stats">
            <!-- Stats populated by JS -->
        </div>
        <div class="tooltip-ability" id="tooltip-ability"></div>
        <div class="tooltip-flavor" id="tooltip-flavor"></div>
        <div class="tooltip-value">
            <span>ðŸ’°</span><span id="tooltip-value">0</span>
        </div>
        <div class="tooltip-actions">
            <span class="action-hint">[Left-Click] Equip</span>
            <span class="action-hint">[Right-Click] Sell</span>
        </div>
    </div>
</body>
</html>
