<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CHRONOPHAGE ‚Äî The Time Devourer</title>
    <!-- V2: Google Fonts for HUD -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&family=Rajdhani:wght@300;400;500;600;700&family=Bebas+Neue&family=Teko:wght@300;400;500;600;700&family=ZCOOL+KuaiLe&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: 'Courier New', monospace;
        }

        #game-container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #game-canvas {
            display: block;
        }

        /* UI Overlay */
        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            color: #fff;
        }

        /* V2.9 Start Screen - Enhanced */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.9) 0%, rgba(5, 5, 20, 0.95) 50%, rgba(0, 0, 0, 0.9) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
            cursor: pointer;
            overflow: hidden;
        }

        /* V2.9 Decorative gears */
        #start-screen::before,
        #start-screen::after {
            content: '';
            position: absolute;
            border: 3px solid rgba(126, 184, 218, 0.1);
            border-radius: 50%;
            animation: spinGear 30s linear infinite;
        }

        #start-screen::before {
            width: 600px;
            height: 600px;
            top: -200px;
            right: -200px;
            border-width: 4px;
            border-style: dashed;
        }

        #start-screen::after {
            width: 500px;
            height: 500px;
            bottom: -150px;
            left: -150px;
            border-width: 3px;
            border-style: dotted;
            animation-direction: reverse;
            animation-duration: 25s;
        }

        @keyframes spinGear {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .title {
            font-family: 'Orbitron', sans-serif;
            font-size: 5rem;
            font-weight: 900;
            letter-spacing: 0.8rem;
            color: #7eb8da;
            text-shadow:
                0 0 20px #4a90b8,
                0 0 40px #2a5a78,
                0 0 60px #1a3a58,
                0 0 80px rgba(74, 144, 184, 0.3);
            margin-bottom: 0.5rem;
            animation: titleGlow 3s ease-in-out infinite alternate;
            position: relative;
            z-index: 1;
        }

        @keyframes titleGlow {
            from {
                text-shadow: 0 0 20px #4a90b8, 0 0 40px #2a5a78, 0 0 60px #1a3a58;
            }
            to {
                text-shadow: 0 0 30px #6ab0d8, 0 0 60px #4a90b8, 0 0 90px #2a5a78;
            }
        }

        .subtitle {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.4rem;
            font-weight: 500;
            letter-spacing: 0.5rem;
            color: #d4af37;
            margin-bottom: 2.5rem;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.6);
            position: relative;
            z-index: 1;
        }

        /* V2.9 Decorative line */
        .subtitle::after {
            content: '';
            display: block;
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, #d4af37, transparent);
            margin: 1rem auto 0;
        }

        .start-prompt {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.5rem;
            font-weight: 600;
            color: #fff;
            letter-spacing: 0.2rem;
            animation: promptPulse 2s ease-in-out infinite;
            position: relative;
            z-index: 1;
        }

        @keyframes promptPulse {
            0%, 100% {
                opacity: 0.7;
                transform: scale(1);
            }
            50% {
                opacity: 1;
                transform: scale(1.02);
            }
        }

        .controls-info {
            font-family: 'Rajdhani', sans-serif;
            margin-top: 2rem;
            text-align: center;
            color: #888;
            font-size: 0.95rem;
            line-height: 2.2;
            font-weight: 500;
            position: relative;
            z-index: 1;
            background: rgba(0, 0, 0, 0.3);
            padding: 1rem 2rem;
            border-radius: 8px;
            border: 1px solid rgba(126, 184, 218, 0.2);
        }

        /* V2.9 High score display */
        .high-score-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            color: #d4af37;
            margin-top: 1.5rem;
            letter-spacing: 0.1rem;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            position: relative;
            z-index: 1;
        }

        /* V2.9 Difficulty Selection - Enhanced */
        .difficulty-select {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 2rem;
            position: relative;
            z-index: 1;
        }

        .difficulty-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #7eb8da;
            margin-bottom: 0.8rem;
            letter-spacing: 0.3rem;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(126, 184, 218, 0.3);
        }

        .difficulty-options {
            display: flex;
            gap: 1rem;
        }

        .difficulty-btn {
            font-family: 'Orbitron', sans-serif;
            padding: 0.8rem 1.4rem;
            background: rgba(0, 0, 0, 0.4);
            border: 2px solid #444;
            color: #888;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            letter-spacing: 0.1rem;
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .difficulty-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .difficulty-btn:hover::before {
            left: 100%;
        }

        .difficulty-btn:hover {
            border-color: #7eb8da;
            color: #7eb8da;
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .difficulty-btn.selected {
            border-color: #d4af37;
            color: #d4af37;
            background: rgba(212, 175, 55, 0.15);
            box-shadow: 0 0 20px rgba(212, 175, 55, 0.4), inset 0 0 10px rgba(212, 175, 55, 0.1);
            transform: translateY(-2px);
        }

        .difficulty-btn.locked {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .difficulty-btn.locked:hover {
            border-color: #444;
            color: #888;
            transform: none;
            box-shadow: none;
        }

        .difficulty-btn.easy { border-color: #4a4; color: #6a6; }
        .difficulty-btn.easy:hover, .difficulty-btn.easy.selected { border-color: #6c6; color: #6c6; background: rgba(100, 200, 100, 0.15); box-shadow: 0 0 20px rgba(100, 200, 100, 0.3); }
        .difficulty-btn.normal { border-color: #7eb8da; color: #7eb8da; }
        .difficulty-btn.normal:hover, .difficulty-btn.normal.selected { border-color: #9ed; color: #9ed; background: rgba(126, 184, 218, 0.15); box-shadow: 0 0 20px rgba(126, 184, 218, 0.3); }
        .difficulty-btn.hard { border-color: #c64; color: #c86; }
        .difficulty-btn.hard:hover, .difficulty-btn.hard.selected { border-color: #f86; color: #f86; background: rgba(255, 136, 102, 0.15); box-shadow: 0 0 20px rgba(255, 136, 102, 0.3); }
        .difficulty-btn.nightmare { border-color: #a33; color: #c44; }
        .difficulty-btn.nightmare:hover:not(.locked), .difficulty-btn.nightmare.selected { border-color: #f44; color: #f44; background: rgba(255, 68, 68, 0.15); box-shadow: 0 0 20px rgba(255, 68, 68, 0.3); }

        .difficulty-desc {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            color: #777;
            margin-top: 0.8rem;
            text-align: center;
            max-width: 450px;
            min-height: 2.5em;
            font-style: italic;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* HUD Elements */
        /* V2 HUD Redesign with Google Fonts */
        #hud {
            display: none;
            font-family: 'Rajdhani', sans-serif;
        }

        #hud.visible {
            display: block;
        }

        .hud-top-left {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        /* V2 Health/Stamina bars with labels */
        .bar-container {
            margin-bottom: 8px;
        }

        .bar-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            color: #888;
            letter-spacing: 0.15rem;
            margin-bottom: 2px;
            text-transform: uppercase;
        }

        .health-bar, .stamina-bar {
            width: 220px;
            height: 18px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 2px;
            position: relative;
            overflow: hidden;
        }

        .health-bar::before, .stamina-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: linear-gradient(180deg, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }

        .health-fill {
            height: 100%;
            background: linear-gradient(90deg, #2a6a88, #4a90b8, #7eb8da);
            transition: width 0.2s ease-out;
            box-shadow: 0 0 10px rgba(126, 184, 218, 0.5) inset;
        }

        .health-fill.regenerating {
            animation: regenPulse 0.8s ease-in-out infinite;
        }

        @keyframes regenPulse {
            0%, 100% { box-shadow: 0 0 10px rgba(126, 184, 218, 0.5) inset; }
            50% { box-shadow: 0 0 20px rgba(100, 255, 150, 0.8) inset, 0 0 10px rgba(100, 255, 150, 0.5); }
        }

        .health-fill.critical {
            background: linear-gradient(90deg, #8a2020, #c44, #ff6666);
            animation: criticalPulse 0.5s ease-in-out infinite;
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .stamina-fill {
            height: 100%;
            background: linear-gradient(90deg, #8a6a0a, #b8860b, #d4af37);
            transition: width 0.15s ease-out;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5) inset;
        }

        .bar-value {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-family: 'Orbitron', sans-serif;
            font-size: 0.65rem;
            font-weight: 600;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            z-index: 1;
        }

        .hud-top-right {
            position: absolute;
            top: 20px;
            right: 20px;
            text-align: right;
        }

        .wave-display {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            font-weight: 400;
            color: #d4af37;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.6), 0 0 30px rgba(212, 175, 55, 0.3);
            letter-spacing: 0.15rem;
        }

        .wave-label {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 1rem;
            font-weight: 400;
            color: #888;
            letter-spacing: 0.2rem;
            text-transform: uppercase;
        }

        .time-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            color: #666;
            margin-top: 5px;
        }

        .hud-bottom-center {
            position: absolute;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .combo-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 3.5rem;
            font-weight: 800;
            color: #fff;
            text-shadow: 0 0 15px rgba(212, 175, 55, 0.6), 2px 2px 4px rgba(0,0,0,0.5);
            transition: transform 0.1s, color 0.3s;
            letter-spacing: 0.1rem;
        }

        .combo-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: #888;
            letter-spacing: 0.2rem;
            text-transform: uppercase;
            margin-top: -5px;
        }

        .combo-display.hit {
            transform: scale(1.25);
            color: #d4af37;
        }

        .combo-display.high {
            color: #ffd700;
            text-shadow: 0 0 25px #ffd700, 0 0 50px rgba(212, 175, 55, 0.8);
        }

        .combo-display.max {
            color: #ff6600;
            text-shadow: 0 0 30px #ff6600, 0 0 60px #ffd700;
            animation: comboPulse 0.5s infinite;
        }

        @keyframes comboPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .charge-bar {
            width: 420px;
            height: 12px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #333;
            border-radius: 2px;
            margin-top: 15px;
            position: relative;
            overflow: hidden;
        }

        .charge-bar::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 40%;
            background: linear-gradient(180deg, rgba(255,255,255,0.1), transparent);
            pointer-events: none;
        }

        .charge-fill {
            height: 100%;
            background: linear-gradient(90deg, #2a5a78, #4a90b8, #7eb8da, #d4af37);
            transition: width 0.2s ease-out;
            box-shadow: 0 0 10px rgba(126, 184, 218, 0.5) inset;
        }

        .charge-fill.full {
            animation: chargeFull 0.8s ease-in-out infinite;
        }

        @keyframes chargeFull {
            0%, 100% { box-shadow: 0 0 10px rgba(212, 175, 55, 0.5) inset; }
            50% { box-shadow: 0 0 20px rgba(212, 175, 55, 1) inset, 0 0 15px rgba(212, 175, 55, 0.8); }
        }

        .charge-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.65rem;
            font-weight: 600;
            color: #666;
            letter-spacing: 0.15rem;
            text-transform: uppercase;
            margin-top: 3px;
        }

        /* V2 Ability cooldown indicators */
        .ability-bar {
            display: flex;
            gap: 12px;
            margin-top: 12px;
            justify-content: center;
        }

        .ability-slot {
            width: 55px;
            height: 55px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            border-radius: 6px;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .ability-slot.ready {
            border-color: #7eb8da;
            box-shadow: 0 0 12px rgba(126, 184, 218, 0.6), inset 0 0 8px rgba(126, 184, 218, 0.2);
        }

        .ability-slot.active {
            border-color: #d4af37;
            box-shadow: 0 0 18px rgba(212, 175, 55, 0.9), inset 0 0 10px rgba(212, 175, 55, 0.3);
            animation: abilityPulse 0.5s infinite;
        }

        .ability-slot.insufficient {
            opacity: 0.4;
        }

        .ability-key {
            font-family: 'Orbitron', sans-serif;
            color: #888;
            font-size: 0.7rem;
            font-weight: 600;
            position: absolute;
            top: 3px;
            left: 5px;
        }

        .ability-cost {
            font-family: 'Rajdhani', sans-serif;
            color: #7eb8da;
            font-size: 0.65rem;
            font-weight: 600;
            position: absolute;
            bottom: 3px;
            right: 5px;
        }

        .ability-cooldown {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(180deg, rgba(126, 184, 218, 0.4), rgba(126, 184, 218, 0.2));
            height: 0%;
            transition: height 0.1s;
            border-radius: 0 0 4px 4px;
        }

        .ability-icon {
            font-size: 1.6rem;
            z-index: 1;
        }

        @keyframes abilityPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.06); }
        }

        .hud-bottom-right {
            position: absolute;
            bottom: 20px;
            right: 20px;
            text-align: right;
        }

        .score-display {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.8rem;
            font-weight: 700;
            color: #d4af37;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            letter-spacing: 0.05rem;
        }

        .score-label {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.7rem;
            font-weight: 600;
            color: #888;
            letter-spacing: 0.15rem;
            text-transform: uppercase;
        }

        /* V2 Weapon Display */
        .weapon-display {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .weapon-slot {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #333;
            border-radius: 4px;
            transition: all 0.2s ease;
            opacity: 0.5;
        }

        .weapon-slot.active {
            opacity: 1;
            border-color: #d4af37;
            background: rgba(212, 175, 55, 0.1);
            box-shadow: 0 0 15px rgba(212, 175, 55, 0.3);
        }

        .weapon-icon {
            font-size: 1.5rem;
            width: 30px;
            text-align: center;
        }

        .weapon-info {
            display: flex;
            flex-direction: column;
        }

        .weapon-name {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.8rem;
            font-weight: 600;
            color: #fff;
        }

        .weapon-key {
            font-family: 'Rajdhani', sans-serif;
            font-size: 0.65rem;
            color: #666;
            letter-spacing: 0.1rem;
        }

        .weapon-ammo {
            font-family: 'Orbitron', sans-serif;
            font-size: 0.7rem;
            color: #7eb8da;
            margin-left: auto;
        }

        /* Crosshair */
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
        }

        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
        }

        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 50%;
            transform: translateX(-50%);
        }

        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 50%;
            transform: translateY(-50%);
        }

        #crosshair.visible {
            display: block;
        }

        /* V2.10 Game Over Screen - Enhanced */
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: background 1s, opacity 1s;
            overflow: hidden;
        }

        #game-over-screen.visible {
            display: flex;
            pointer-events: auto;
            cursor: pointer;
            background: linear-gradient(180deg, rgba(20, 0, 0, 0.9) 0%, rgba(0, 0, 0, 0.95) 50%, rgba(20, 0, 0, 0.9) 100%);
            opacity: 1;
        }

        /* V2.10 Broken clock decoration */
        #game-over-screen::before {
            content: '';
            position: absolute;
            width: 400px;
            height: 400px;
            border: 4px dashed rgba(255, 68, 68, 0.15);
            border-radius: 50%;
            animation: brokenSpin 20s linear infinite;
        }

        @keyframes brokenSpin {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(100deg); }
            26% { transform: rotate(95deg); }
            50% { transform: rotate(180deg); }
            75% { transform: rotate(270deg); }
            76% { transform: rotate(265deg); }
            100% { transform: rotate(360deg); }
        }

        .game-over-title {
            font-family: 'Orbitron', sans-serif;
            font-size: 4.5rem;
            font-weight: 900;
            letter-spacing: 0.5rem;
            color: #ff4444;
            text-shadow:
                0 0 20px #ff0000,
                0 0 40px #aa0000,
                0 0 60px rgba(255, 0, 0, 0.3);
            margin-bottom: 1rem;
            transform: scale(0);
            animation: gameOverAppear 0.5s ease-out forwards;
            animation-delay: 0.5s;
            position: relative;
            z-index: 1;
        }

        /* V2.10 Glitch effect on title */
        .game-over-title::after {
            content: "TIME'S UP";
            position: absolute;
            left: 2px;
            top: 0;
            color: #00ffff;
            opacity: 0;
            animation: glitch 3s infinite;
            animation-delay: 1.5s;
        }

        @keyframes glitch {
            0%, 90%, 100% { opacity: 0; transform: translateX(0); }
            92% { opacity: 0.5; transform: translateX(-5px); }
            94% { opacity: 0; transform: translateX(5px); }
            96% { opacity: 0.3; transform: translateX(-2px); }
        }

        @keyframes gameOverAppear {
            0% { transform: scale(0) rotate(-10deg); }
            50% { transform: scale(1.2) rotate(5deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .final-score {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.2rem;
            font-weight: 700;
            color: #d4af37;
            margin-bottom: 0.5rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 1s;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .final-wave {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: #7eb8da;
            margin-bottom: 0.5rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 1.2s;
        }

        .final-difficulty {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            color: #888;
            margin-bottom: 1.5rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 1.3s;
            text-transform: uppercase;
            letter-spacing: 0.25rem;
        }
        .final-difficulty.easy { color: #6c6; }
        .final-difficulty.normal { color: #9ed; }
        .final-difficulty.hard { color: #f86; }
        .final-difficulty.nightmare { color: #f44; }

        .nightmare-unlock-notice {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 600;
            color: #f44;
            text-shadow: 0 0 15px #f00;
            margin-bottom: 1rem;
            opacity: 0;
            animation: nightmareUnlock 1s ease-out forwards;
            animation-delay: 1.5s;
        }

        @keyframes nightmareUnlock {
            0% { opacity: 0; transform: scale(0.8); }
            50% { opacity: 1; transform: scale(1.1); text-shadow: 0 0 30px #f00; }
            100% { opacity: 1; transform: scale(1); text-shadow: 0 0 15px #f00; }
        }

        .high-score-notice {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            font-weight: 700;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700;
            margin-bottom: 1rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards, highScorePulse 1s ease-in-out infinite;
            animation-delay: 1.4s, 1.4s;
        }

        @keyframes highScorePulse {
            0%, 100% { text-shadow: 0 0 10px #ffd700; }
            50% { text-shadow: 0 0 20px #ffd700, 0 0 30px #d4af37; }
        }

        /* V2.10 Enhanced stats container */
        .stats-container {
            display: flex;
            gap: 40px;
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards;
            animation-delay: 1.6s;
            position: relative;
            z-index: 1;
            background: rgba(0, 0, 0, 0.3);
            padding: 1.5rem 2.5rem;
            border-radius: 8px;
            border: 1px solid rgba(126, 184, 218, 0.2);
        }

        .stat-item {
            text-align: center;
            padding: 0 1rem;
        }

        .stat-item:not(:last-child) {
            border-right: 1px solid rgba(126, 184, 218, 0.2);
        }

        .stat-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 2.4rem;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        }

        .stat-label {
            font-family: 'Rajdhani', sans-serif;
            font-weight: 600;
            font-size: 0.85rem;
            color: #7eb8da;
            text-transform: uppercase;
            letter-spacing: 0.15rem;
        }

        .restart-prompt {
            font-family: 'Rajdhani', sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: #888;
            letter-spacing: 0.15rem;
            opacity: 0;
            animation: fadeIn 0.5s ease-out forwards, restartPulse 2s ease-in-out infinite;
            animation-delay: 2s, 2s;
            position: relative;
            z-index: 1;
        }

        @keyframes restartPulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.02); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* High Score Display on Start Screen */
        .high-score-display {
            margin-top: 2rem;
            text-align: center;
            color: #d4af37;
            font-size: 1rem;
        }

        .high-score-display span {
            color: #ffd700;
            font-size: 1.3rem;
        }

        /* Pause Screen */
        #pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            pointer-events: auto;
        }

        #pause-screen.visible {
            display: flex;
        }

        .pause-title {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 4rem;
            color: #d4af37;
            margin-bottom: 2rem;
            letter-spacing: 0.3rem;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
        }

        .pause-menu {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
            width: 300px;
            margin-bottom: 2rem;
        }

        .volume-control {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .volume-label {
            font-family: 'Rajdhani', sans-serif;
            color: #7eb8da;
            font-size: 1rem;
            font-weight: 600;
            letter-spacing: 0.1rem;
            display: flex;
            justify-content: space-between;
        }

        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 8px;
            background: rgba(126, 184, 218, 0.2);
            border-radius: 4px;
            outline: none;
            cursor: pointer;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #d4af37;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            transition: transform 0.1s;
        }

        .volume-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .volume-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #d4af37;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            box-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
        }

        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .pause-button {
            font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 0.2rem;
            padding: 0.8rem 2rem;
            background: transparent;
            border: 2px solid #7eb8da;
            color: #7eb8da;
            cursor: pointer;
            transition: all 0.2s;
        }

        .pause-button:hover {
            background: rgba(126, 184, 218, 0.2);
            border-color: #d4af37;
            color: #d4af37;
            transform: scale(1.05);
        }

        .pause-info {
            color: #666;
            font-size: 0.9rem;
            margin-top: 1.5rem;
        }

        /* V2.6 Post-Processing Overlays */
        #post-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            background: radial-gradient(ellipse at center,
                transparent 0%,
                transparent 40%,
                rgba(0, 5, 15, 0.3) 70%,
                rgba(0, 5, 15, 0.7) 100%);
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        /* Dynamic health-based red vignette overlay */
        #damage-vignette {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        #damage-vignette.critical {
            animation: criticalPulse 0.8s ease-in-out infinite;
        }

        @keyframes criticalPulse {
            0%, 100% { opacity: var(--damage-opacity, 0); }
            50% { opacity: calc(var(--damage-opacity, 0) * 1.3); }
        }

        #post-bloom {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 4;
            background: radial-gradient(ellipse at center,
                rgba(126, 184, 218, 0.03) 0%,
                transparent 50%);
            mix-blend-mode: screen;
        }

        #post-chromatic {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 6;
            opacity: 0;
            transition: opacity 0.15s ease;
        }

        #post-chromatic.active {
            opacity: 1;
        }

        #post-chromatic::before,
        #post-chromatic::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #post-chromatic::before {
            box-shadow: inset 2px 0 0 rgba(255, 0, 0, 0.15);
        }

        #post-chromatic::after {
            box-shadow: inset -2px 0 0 rgba(0, 255, 255, 0.15);
        }

        #post-scanlines {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 7;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.03) 2px,
                rgba(0, 0, 0, 0.03) 4px
            );
            opacity: 0.5;
        }

        /* Game canvas with bloom filter */
        #game-canvas {
            filter: contrast(1.05) saturate(1.1);
        }

        #game-canvas.combat-active {
            filter: contrast(1.03) saturate(1.05) brightness(1.01);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>

        <!-- V2.6 Post-Processing Overlays -->
        <div id="post-bloom"></div>
        <div id="post-vignette"></div>
        <div id="damage-vignette"></div>
        <div id="post-chromatic"></div>
        <div id="post-scanlines"></div>

        <div id="ui-overlay">
            <!-- Start Screen -->
            <div id="start-screen">
                <div class="title">CHRONOPHAGE</div>
                <div class="subtitle">‚Äî THE TIME DEVOURER ‚Äî</div>

                <!-- V2 Difficulty Selection -->
                <div class="difficulty-select">
                    <div class="difficulty-label">SELECT DIFFICULTY</div>
                    <div class="difficulty-options">
                        <button class="difficulty-btn easy" data-difficulty="easy">EASY</button>
                        <button class="difficulty-btn normal selected" data-difficulty="normal">NORMAL</button>
                        <button class="difficulty-btn hard" data-difficulty="hard">HARD</button>
                        <button class="difficulty-btn nightmare locked" data-difficulty="nightmare" title="Complete the game on Hard to unlock">üîí NIGHTMARE</button>
                    </div>
                    <div class="difficulty-desc" id="difficulty-desc">Standard challenge. Balanced for most players.</div>
                </div>

                <div class="start-prompt">[ CLICK TO BEGIN ]</div>
                <div class="controls-info">
                    WASD: Move &nbsp;&nbsp; MOUSE: Look &nbsp;&nbsp; SHIFT: Sprint<br>
                    SPACE: Dash &nbsp;&nbsp; LMB: Attack &nbsp;&nbsp; RMB: Heavy/Reload<br>
                    1/2/3: Switch Weapons &nbsp;&nbsp; Q/E/R: Temporal Abilities
                </div>
                <div class="high-score-display" id="high-score-display" style="display: none;">
                    HIGH SCORE: <span id="high-score-value">0</span>
                </div>
            </div>

            <!-- Game Over Screen -->
            <div id="game-over-screen">
                <div class="game-over-title">TIME'S UP</div>
                <div class="final-score">SCORE: <span id="final-score">0</span></div>
                <div class="final-wave">WAVE <span id="final-wave">1</span></div>
                <div class="final-difficulty normal" id="final-difficulty">NORMAL</div>
                <div class="nightmare-unlock-notice" id="nightmare-unlock" style="display: none;">‚ò† NIGHTMARE MODE UNLOCKED ‚ò†</div>
                <div class="high-score-notice" id="new-high-score" style="display: none;">NEW HIGH SCORE!</div>
                <div class="stats-container">
                    <div class="stat-item">
                        <div class="stat-value" id="stat-time">00:00</div>
                        <div class="stat-label">Time Survived</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-kills">0</div>
                        <div class="stat-label">Enemies Slain</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-value" id="stat-max-combo">0</div>
                        <div class="stat-label">Max Combo</div>
                    </div>
                </div>
                <div class="restart-prompt">[ CLICK TO PLAY AGAIN ]</div>
            </div>

            <!-- Pause Screen -->
            <div id="pause-screen">
                <div class="pause-title">PAUSED</div>
                <div class="pause-menu">
                    <div class="volume-control">
                        <div class="volume-label">
                            <span>MUSIC</span>
                            <span id="music-volume-value">100%</span>
                        </div>
                        <input type="range" class="volume-slider" id="music-volume" min="0" max="100" value="100">
                    </div>
                    <div class="volume-control">
                        <div class="volume-label">
                            <span>SFX</span>
                            <span id="sfx-volume-value">80%</span>
                        </div>
                        <input type="range" class="volume-slider" id="sfx-volume" min="0" max="100" value="80">
                    </div>
                </div>
                <div class="pause-buttons">
                    <button class="pause-button" id="resume-button">RESUME</button>
                    <button class="pause-button" id="quit-button">QUIT TO MENU</button>
                </div>
                <div class="pause-info">Press ESC to resume</div>
            </div>

            <!-- HUD -->
            <div id="hud">
                <div class="hud-top-left">
                    <div class="bar-container">
                        <div class="bar-label">VITALITY</div>
                        <div class="health-bar">
                            <div class="health-fill" id="health-fill" style="width: 100%"></div>
                            <span class="bar-value" id="health-value">100</span>
                        </div>
                    </div>
                    <div class="bar-container">
                        <div class="bar-label">STAMINA</div>
                        <div class="stamina-bar">
                            <div class="stamina-fill" id="stamina-fill" style="width: 100%"></div>
                            <span class="bar-value" id="stamina-value">100</span>
                        </div>
                    </div>
                </div>

                <div class="hud-top-right">
                    <div class="wave-label">WAVE</div>
                    <div class="wave-display"><span id="wave-number">1</span></div>
                    <div class="time-display" id="time-display">00:00</div>
                </div>

                <div class="hud-bottom-center">
                    <div class="combo-display">√ó<span id="combo-count">0</span></div>
                    <div class="combo-label">COMBO</div>
                    <div class="charge-bar">
                        <div class="charge-fill" id="charge-fill" style="width: 0%"></div>
                    </div>
                    <div class="charge-label">TEMPORAL CHARGE</div>
                    <div class="ability-bar">
                        <div class="ability-slot" id="ability-q">
                            <div class="ability-cooldown" id="ability-q-cooldown"></div>
                            <span class="ability-key">Q</span>
                            <span class="ability-icon">‚ö°</span>
                            <span class="ability-cost">25</span>
                        </div>
                        <div class="ability-slot" id="ability-e">
                            <div class="ability-cooldown" id="ability-e-cooldown"></div>
                            <span class="ability-key">E</span>
                            <span class="ability-icon">üëª</span>
                            <span class="ability-cost">50</span>
                        </div>
                        <div class="ability-slot" id="ability-r">
                            <div class="ability-cooldown" id="ability-r-cooldown"></div>
                            <span class="ability-key">R</span>
                            <span class="ability-icon">‚è±</span>
                            <span class="ability-cost">75</span>
                        </div>
                    </div>
                </div>

                <div class="hud-bottom-right">
                    <div class="score-label">SCORE</div>
                    <div class="score-display"><span id="score-display">0</span></div>
                </div>

                <!-- V2 Weapon Display -->
                <div class="weapon-display">
                    <div class="weapon-slot active" id="weapon-blade" data-weapon="blade">
                        <span class="weapon-icon">‚öî</span>
                        <div class="weapon-info">
                            <span class="weapon-name">TEMPORAL BLADE</span>
                            <span class="weapon-key">1 / SCROLL</span>
                        </div>
                    </div>
                    <div class="weapon-slot" id="weapon-pistol" data-weapon="pistol">
                        <span class="weapon-icon">üî´</span>
                        <div class="weapon-info">
                            <span class="weapon-name">CHRONO PISTOL</span>
                            <span class="weapon-key">2 / SCROLL</span>
                        </div>
                        <span class="weapon-ammo" id="pistol-ammo">30/30</span>
                    </div>
                    <div class="weapon-slot" id="weapon-scythe" data-weapon="scythe">
                        <span class="weapon-icon">‚ö∞</span>
                        <div class="weapon-info">
                            <span class="weapon-name">VOID SCYTHE</span>
                            <span class="weapon-key">3 / SCROLL</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Crosshair -->
            <div id="crosshair"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHRONOPHAGE ‚Äî The Time Devourer
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚îÄ‚îÄ‚îÄ CONFIGURATION V2 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const CONFIG = {
    // Arena
    arenaRadius: 40,
    pillarCount: 12,
    fogNear: 20,
    fogFar: 80,
    fogColor: 0x0a0a1a,

    // Camera V2 - Proper third-person follow
    cameraDistance: 12,
    cameraHeight: 5,
    cameraMinDistance: 5,
    cameraMaxDistance: 20,
    cameraSmoothness: 0.08,
    cameraPitchMin: 0.15,      // ~10 degrees
    cameraPitchMax: 1.4,       // ~80 degrees
    cameraDefaultPitch: 0.4,   // ~23 degrees
    cameraCombatPullback: 1.3, // Multiplier when enemies nearby
    cameraShakeRecovery: 8,    // How fast shake recovers

    // Player Movement
    playerSpeed: 12,
    sprintMultiplier: 1.67,
    dashDistance: 6,
    dashDuration: 0.2,
    dashCooldown: 1.5,
    dashStaminaCost: 25,

    // Player Health by Difficulty
    playerHealth: {
        easy: 150,
        normal: 100,
        hard: 75,
        nightmare: 50
    },

    // Health Regeneration
    healthRegen: {
        easy: 3,
        normal: 1,
        hard: 0,
        nightmare: 0
    },
    regenDelay: 4, // seconds out of combat before regen starts

    // Stamina
    maxStamina: 100,
    staminaRegen: 35,
    staminaRegenDelay: 0.6,
    staminaRegenMultiplier: {
        easy: 1.5,
        normal: 1.0,
        hard: 0.75,
        nightmare: 0.75
    },

    // Temporal Charge
    maxCharge: 100,
    chargePerHit: 5,
    chargePerKill: 15,
    chargeDecay: 3,
    chargeGainMultiplier: {
        easy: 1.5,
        normal: 1.0,
        hard: 1.0,
        nightmare: 0.8
    },

    // Weapons V2
    weapons: {
        blade: {
            name: 'Temporal Blade',
            lightDamage: 25,  // 2 hits to kill on Normal
            heavyDamage: 45,  // 1 hit to kill on Normal (was 60)
            range: 3,
            arc: 120,
            lightStamina: 12,
            heavyStamina: 30,
            chargeGain: 1.0 // Fastest charge builder
        },
        pistol: {
            name: 'Chrono Pistol',
            damage: 25,  // 2 hits to kill on Normal (was 15)
            fireRate: 3, // shots per second
            maxAmmo: 30,
            reloadTime: 1.5,
            range: 50,
            chargeGain: 0.5
        },
        scythe: {
            name: 'Void Scythe',
            damage: 30,  // ~2 hits to kill on Normal (was 80) - slow swing balances higher damage
            attackSpeed: 0.8, // swings per second
            range: 5,
            arc: 180,
            staminaCost: 40,
            slowEffect: 0.3, // 30% slow
            slowDuration: 2,
            healOnTrail: 2,
            chargeGain: 0.7
        }
    },

    // Temporal Abilities
    timeFractureCost: 25,
    timeFractureDamage: 30,
    timeFractureRadius: 5,
    timeFractureCooldown: 8,

    temporalEchoCost: 50,
    temporalEchoDuration: 2,
    temporalEchoCooldown: 15,

    chronostasisCost: 75,
    chronostasisDuration: 3,
    chronostasisPlayerSpeed: 1.0,  // Player moves at full speed while enemies frozen
    chronostasisCooldown: 25,

    // Combo
    comboDecayTime: 4,
    moteTimeExtend: 2,

    // Wave System
    wavePrepTime: 3,
    waveIntervalTime: 5,
    baseWaveEnemies: 4,
    enemiesPerWave: 2,
    maxEnemiesAlive: 12,
    waveCompletionBonus: 500,

    // Difficulty Multipliers
    // Enemy health scaled so basic enemies die in: Easy=1hit, Normal=2hits, Hard=3hits, Nightmare=4hits
    difficulty: {
        easy: {
            enemyDamage: 0.7,
            enemySpeed: 0.8,
            enemyHealth: 0.5,  // 1-hit kills with light attack
            waveCountMod: -2,
            telegraphTime: 1.2 // Longer telegraphs
        },
        normal: {
            enemyDamage: 1.0,
            enemySpeed: 1.0,
            enemyHealth: 1.0,  // 2-hit kills with light attack
            waveCountMod: 0,
            telegraphTime: 1.0
        },
        hard: {
            enemyDamage: 1.25,
            enemySpeed: 1.15,
            enemyHealth: 1.5,  // 3-hit kills with light attack
            waveCountMod: 2,
            telegraphTime: 0.8 // Shorter telegraphs
        },
        nightmare: {
            enemyDamage: 1.5,
            enemySpeed: 1.3,
            enemyHealth: 2.0,  // 4-hit kills with light attack
            waveCountMod: 4,
            telegraphTime: 0.6,
            executeThreshold: 0.2 // One-hit kill below 20% HP
        }
    },

    // Post Processing V2
    bloom: {
        enabled: true,
        threshold: 0.8,
        intensity: 1.5,
        radius: 0.5
    },
    vignette: {
        enabled: true,
        intensity: 0.3,
        lowHealthIntensity: 0.6
    },
    chromaticAberration: {
        enabled: true,
        baseIntensity: 0.002,
        damageIntensity: 0.01
    },

    // Visual V2
    trailSegments: 15,
    particlePoolSize: 800,
    motePoolSize: 100,
    ambientParticles: 500,
    combatParticlesPerHit: 50,
    deathParticles: 100,

    // Audio V2
    masterVolume: 0.8,
    sfxVolume: 0.8,
    musicVolume: 1.0, // Louder music
    spatialAudio: true
};

// ‚îÄ‚îÄ‚îÄ DIFFICULTY STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let currentDifficulty = 'normal';
let nightmareUnlocked = false;

// Helper to get difficulty-adjusted value
function getDifficultyValue(baseValue, multiplierKey) {
    const mult = CONFIG.difficulty[currentDifficulty][multiplierKey];
    return mult !== undefined ? baseValue * mult : baseValue;
}

function getPlayerMaxHealth() {
    return CONFIG.playerHealth[currentDifficulty];
}

function getHealthRegenRate() {
    return CONFIG.healthRegen[currentDifficulty];
}

function getStaminaRegenMultiplier() {
    return CONFIG.staminaRegenMultiplier[currentDifficulty];
}

function getChargeGainMultiplier() {
    return CONFIG.chargeGainMultiplier[currentDifficulty];
}

// ‚îÄ‚îÄ‚îÄ UTILITY CLASSES ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Vec3 {
    static add(a, b) {
        return new THREE.Vector3(a.x + b.x, a.y + b.y, a.z + b.z);
    }

    static sub(a, b) {
        return new THREE.Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
    }

    static scale(v, s) {
        return new THREE.Vector3(v.x * s, v.y * s, v.z * s);
    }

    static length(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    }

    static normalize(v) {
        const len = Vec3.length(v);
        if (len === 0) return new THREE.Vector3(0, 0, 0);
        return Vec3.scale(v, 1 / len);
    }

    static distance(a, b) {
        return Vec3.length(Vec3.sub(a, b));
    }

    static lerp(a, b, t) {
        return new THREE.Vector3(
            a.x + (b.x - a.x) * t,
            a.y + (b.y - a.y) * t,
            a.z + (b.z - a.z) * t
        );
    }
}

// ‚îÄ‚îÄ‚îÄ GAME STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const GameState = {
    MENU: 'menu',
    PLAYING: 'playing',
    PAUSED: 'paused',
    GAMEOVER: 'gameover'
};

// ‚îÄ‚îÄ‚îÄ SCREEN EFFECTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class ScreenEffects {
    constructor() {
        // Screen shake
        this.shakeIntensity = 0;
        this.shakeDuration = 0;
        this.shakeOffset = new THREE.Vector3();

        // Hitstop (time freeze)
        this.hitstopDuration = 0;
        this.timeScale = 1;

        // Slow motion
        this.slowmoDuration = 0;
        this.slowmoScale = 1;

        // Vignette flash
        this.vignetteIntensity = 0;
        this.vignetteColor = '#ff0000';

        // V2.6 Post-processing state
        this.chromaticActive = false;
        this.chromaticDuration = 0;
        this.lowHealthMode = false;
        this.combatActive = false;

        // Health-based damage vignette (CoD style)
        this.currentHealthPercent = 1.0;
        this.targetHealthPercent = 1.0;

        // Create vignette overlay
        this.createVignetteOverlay();

        // V2.6 Cache post-processing elements
        this.postVignette = document.getElementById('post-vignette');
        this.postChromatic = document.getElementById('post-chromatic');
        this.damageVignette = document.getElementById('damage-vignette');
        this.gameCanvas = document.getElementById('game-canvas');
    }

    createVignetteOverlay() {
        const overlay = document.createElement('div');
        overlay.id = 'screen-effects-overlay';
        overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 60%, rgba(255,0,0,0) 100%);
            opacity: 0;
            transition: opacity 0.1s;
        `;
        document.body.appendChild(overlay);
        this.vignetteOverlay = overlay;
    }

    // V2.6 Chromatic aberration burst (on damage/impact)
    chromaticBurst(duration = 0.15) {
        if (!CONFIG.chromaticAberration.enabled) return;
        this.chromaticActive = true;
        this.chromaticDuration = duration;
        if (this.postChromatic) {
            this.postChromatic.classList.add('active');
        }
    }

    // V2.6 Set low health visual mode
    setLowHealthMode(isLow) {
        if (this.lowHealthMode === isLow) return;
        this.lowHealthMode = isLow;
    }

    // CoD-style health-based damage vignette
    updateHealthVignette(healthPercent) {
        this.targetHealthPercent = healthPercent;
    }

    // Update damage vignette visuals (call in update loop)
    updateDamageVignette(deltaTime) {
        // Smoothly interpolate current health toward target
        const lerpSpeed = this.currentHealthPercent > this.targetHealthPercent ? 8 : 2; // Fast when damaged, slow recovery
        this.currentHealthPercent += (this.targetHealthPercent - this.currentHealthPercent) * lerpSpeed * deltaTime;

        if (!this.damageVignette) return;

        // Calculate vignette intensity based on missing health
        // Starts showing at 70% health, gets more intense as health drops
        const missingHealth = 1 - this.currentHealthPercent;
        let intensity = 0;

        if (this.currentHealthPercent < 0.7) {
            // Map 0.7->0 health to 0->1 intensity
            intensity = (0.7 - this.currentHealthPercent) / 0.7;
            intensity = Math.pow(intensity, 0.7); // Curve for more dramatic low health
        }

        // Apply vignette
        if (intensity > 0.01) {
            const redIntensity = Math.min(intensity * 0.9, 0.85);
            const spread = 30 + (1 - intensity) * 30; // Vignette spreads inward as health drops

            this.damageVignette.style.background = `radial-gradient(ellipse at center,
                transparent 0%,
                transparent ${spread}%,
                rgba(120, 0, 0, ${redIntensity * 0.4}) ${spread + 20}%,
                rgba(80, 0, 0, ${redIntensity * 0.7}) ${spread + 35}%,
                rgba(50, 0, 0, ${redIntensity * 0.9}) 100%)`;
            this.damageVignette.style.opacity = '1';
            this.damageVignette.style.setProperty('--damage-opacity', intensity.toString());

            // Add pulsing effect when critical (below 25%)
            if (this.currentHealthPercent < 0.25) {
                this.damageVignette.classList.add('critical');
            } else {
                this.damageVignette.classList.remove('critical');
            }
        } else {
            this.damageVignette.style.opacity = '0';
            this.damageVignette.classList.remove('critical');
        }
    }

    // V2.6 Set combat active mode (enhanced visuals during combat)
    setCombatMode(active) {
        if (this.combatActive === active) return;
        this.combatActive = active;
        if (this.gameCanvas) {
            if (active) {
                this.gameCanvas.classList.add('combat-active');
            } else {
                this.gameCanvas.classList.remove('combat-active');
            }
        }
    }

    // Trigger screen shake
    shake(intensity, duration) {
        this.shakeIntensity = Math.max(this.shakeIntensity, intensity);
        this.shakeDuration = Math.max(this.shakeDuration, duration);
    }

    // Trigger hitstop (brief time freeze)
    hitstop(duration) {
        this.hitstopDuration = duration;
        this.timeScale = 0;
    }

    // Trigger slow motion
    slowmo(scale, duration) {
        this.slowmoScale = scale;
        this.slowmoDuration = duration;
    }

    // Flash vignette (damage indicator)
    flashVignette(color, intensity) {
        this.vignetteColor = color;
        this.vignetteIntensity = intensity;
        this.updateVignetteOverlay();
    }

    updateVignetteOverlay() {
        const overlay = this.vignetteOverlay;
        if (this.vignetteIntensity > 0) {
            // Use semi-transparent color at edges to avoid blocking view
            overlay.style.background = `radial-gradient(ellipse at center, transparent 0%, transparent 60%, ${this.vignetteColor}66 85%, ${this.vignetteColor}99 100%)`;
            overlay.style.opacity = this.vignetteIntensity;
        } else {
            overlay.style.opacity = 0;
        }
    }

    update(deltaTime) {
        // Update screen shake
        if (this.shakeDuration > 0) {
            this.shakeDuration -= deltaTime;
            const intensity = this.shakeIntensity * (this.shakeDuration > 0 ? 1 : 0);
            this.shakeOffset.set(
                (Math.random() - 0.5) * 2 * intensity,
                (Math.random() - 0.5) * 2 * intensity,
                (Math.random() - 0.5) * 2 * intensity
            );
            if (this.shakeDuration <= 0) {
                this.shakeIntensity = 0;
                this.shakeOffset.set(0, 0, 0);
            }
        }

        // Update hitstop
        if (this.hitstopDuration > 0) {
            this.hitstopDuration -= deltaTime;
            if (this.hitstopDuration <= 0) {
                this.timeScale = 1;
            }
        }

        // Update slow motion
        if (this.slowmoDuration > 0) {
            this.slowmoDuration -= deltaTime;
            this.timeScale = this.slowmoScale;
            if (this.slowmoDuration <= 0) {
                this.slowmoScale = 1;
                this.timeScale = 1;
            }
        }

        // Fade vignette
        if (this.vignetteIntensity > 0) {
            this.vignetteIntensity -= deltaTime * 4;
            if (this.vignetteIntensity < 0) this.vignetteIntensity = 0;
            this.updateVignetteOverlay();
        }

        // V2.6 Fade chromatic aberration
        if (this.chromaticActive && this.chromaticDuration > 0) {
            this.chromaticDuration -= deltaTime;
            if (this.chromaticDuration <= 0) {
                this.chromaticActive = false;
                if (this.postChromatic) {
                    this.postChromatic.classList.remove('active');
                }
            }
        }
    }

    getTimeScale() {
        if (this.hitstopDuration > 0) return 0;
        return this.slowmoScale;
    }

    applyToCamera(camera) {
        // Apply shake offset to camera
        camera.position.add(this.shakeOffset);
    }
}

// ‚îÄ‚îÄ‚îÄ INPUT MANAGER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class InputManager {
    constructor() {
        this.keys = {};
        this.mouseMovement = { x: 0, y: 0 };
        this.mouseButtons = { left: false, right: false };
        this.isPointerLocked = false;

        this.setupListeners();
    }

    setupListeners() {
        // Keyboard
        window.addEventListener('keydown', (e) => {
            this.keys[e.code] = true;
        });

        window.addEventListener('keyup', (e) => {
            this.keys[e.code] = false;
        });

        // Mouse movement
        window.addEventListener('mousemove', (e) => {
            if (this.isPointerLocked) {
                this.mouseMovement.x += e.movementX;
                this.mouseMovement.y += e.movementY;
            }
        });

        // Mouse buttons
        window.addEventListener('mousedown', (e) => {
            if (e.button === 0) this.mouseButtons.left = true;
            if (e.button === 2) this.mouseButtons.right = true;
        });

        window.addEventListener('mouseup', (e) => {
            if (e.button === 0) this.mouseButtons.left = false;
            if (e.button === 2) this.mouseButtons.right = false;
        });

        // Pointer lock change
        document.addEventListener('pointerlockchange', () => {
            this.isPointerLocked = document.pointerLockElement !== null;
        });

        // Prevent context menu
        window.addEventListener('contextmenu', (e) => e.preventDefault());
    }

    isKeyDown(code) {
        return this.keys[code] === true;
    }

    consumeMouseMovement() {
        const movement = { x: this.mouseMovement.x, y: this.mouseMovement.y };
        this.mouseMovement.x = 0;
        this.mouseMovement.y = 0;
        return movement;
    }

    reset() {
        this.keys = {};
        this.mouseButtons = { left: false, right: false };
    }
}

// ‚îÄ‚îÄ‚îÄ AUDIO MANAGER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class AudioManager {
    constructor() {
        this.context = null;
        this.masterGain = null;
        this.sfxGain = null;
        this.initialized = false;
        this.volume = 0.3;

        // Volume controls (0-1)
        this.musicVolume = CONFIG.musicVolume;
        this.sfxVolume = CONFIG.sfxVolume;

        // Ambient oscillators
        this.ambientOscillators = [];
        this.ambientGain = null;
    }

    init() {
        if (this.initialized) return;

        try {
            this.context = new (window.AudioContext || window.webkitAudioContext)();

            // Master gain (overall volume)
            this.masterGain = this.context.createGain();
            this.masterGain.gain.value = this.volume;
            this.masterGain.connect(this.context.destination);

            // SFX gain node - connects directly to destination for independent control
            this.sfxGain = this.context.createGain();
            this.sfxGain.gain.value = this.sfxVolume;
            this.sfxGain.connect(this.context.destination);

            // Music/ambient gain - connects directly to destination for independent control
            this.ambientGain = this.context.createGain();
            this.ambientGain.gain.value = 0.4 * this.musicVolume; // Louder base music
            this.ambientGain.connect(this.context.destination);

            this.initialized = true;
            this.startAmbience();
        } catch (e) {
            console.warn('Web Audio API not supported');
        }
    }

    startAmbience() {
        if (!this.initialized) return;

        // Deep drone - the heartbeat of time
        const drone1 = this.context.createOscillator();
        const drone1Gain = this.context.createGain();
        drone1.type = 'sine';
        drone1.frequency.value = 55; // Low A
        drone1Gain.gain.value = 0.3;
        drone1.connect(drone1Gain);
        drone1Gain.connect(this.ambientGain);
        drone1.start();
        this.ambientOscillators.push(drone1);

        // Higher harmonic
        const drone2 = this.context.createOscillator();
        const drone2Gain = this.context.createGain();
        drone2.type = 'sine';
        drone2.frequency.value = 110;
        drone2Gain.gain.value = 0.15;
        drone2.connect(drone2Gain);
        drone2Gain.connect(this.ambientGain);
        drone2.start();
        this.ambientOscillators.push(drone2);

        // Ethereal shimmer with LFO
        const shimmer = this.context.createOscillator();
        const shimmerGain = this.context.createGain();
        const lfo = this.context.createOscillator();
        const lfoGain = this.context.createGain();

        shimmer.type = 'triangle';
        shimmer.frequency.value = 220;
        shimmerGain.gain.value = 0.05;

        lfo.type = 'sine';
        lfo.frequency.value = 0.2;
        lfoGain.gain.value = 50;

        lfo.connect(lfoGain);
        lfoGain.connect(shimmer.frequency);
        shimmer.connect(shimmerGain);
        shimmerGain.connect(this.ambientGain);

        lfo.start();
        shimmer.start();
        this.ambientOscillators.push(shimmer, lfo);
    }

    // Volume control methods
    setMusicVolume(volume) {
        this.musicVolume = Math.max(0, Math.min(1, volume));
        if (this.ambientGain) {
            this.ambientGain.gain.value = 0.4 * this.musicVolume; // Base level * user volume
        }
    }

    setSfxVolume(volume) {
        this.sfxVolume = Math.max(0, Math.min(1, volume));
        if (this.sfxGain) {
            this.sfxGain.gain.value = this.sfxVolume; // Direct control of SFX gain
        }
    }

    getMusicVolume() {
        return this.musicVolume;
    }

    getSfxVolume() {
        return this.sfxVolume;
    }

    // Sword swings - whoosh sounds
    playSwing(isHeavy = false) {
        if (!this.initialized) return;

        const now = this.context.currentTime;
        const duration = isHeavy ? 0.3 : 0.15;

        // White noise filtered for whoosh
        const bufferSize = this.context.sampleRate * duration;
        const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.context.createBufferSource();
        noise.buffer = buffer;

        // Bandpass filter for swoosh character
        const filter = this.context.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(isHeavy ? 800 : 1200, now);
        filter.frequency.exponentialRampToValueAtTime(isHeavy ? 400 : 800, now + duration);
        filter.Q.value = 2;

        const gain = this.context.createGain();
        gain.gain.setValueAtTime(isHeavy ? 0.4 : 0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.sfxGain);

        noise.start(now);
        noise.stop(now + duration);
    }

    // Hit impacts - metallic thud
    playHit(damage = 25) {
        if (!this.initialized) return;

        const now = this.context.currentTime;
        const intensity = Math.min(damage / 60, 1);

        // Impact body - low thump
        const osc1 = this.context.createOscillator();
        const osc1Gain = this.context.createGain();
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(120 + intensity * 40, now);
        osc1.frequency.exponentialRampToValueAtTime(40, now + 0.15);
        osc1Gain.gain.setValueAtTime(0.4 + intensity * 0.3, now);
        osc1Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

        osc1.connect(osc1Gain);
        osc1Gain.connect(this.sfxGain);
        osc1.start(now);
        osc1.stop(now + 0.15);

        // Metallic clang
        const osc2 = this.context.createOscillator();
        const osc2Gain = this.context.createGain();
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(800 + intensity * 400, now);
        osc2.frequency.exponentialRampToValueAtTime(200, now + 0.08);
        osc2Gain.gain.setValueAtTime(0.15 + intensity * 0.1, now);
        osc2Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

        osc2.connect(osc2Gain);
        osc2Gain.connect(this.sfxGain);
        osc2.start(now);
        osc2.stop(now + 0.1);
    }

    // Enemy death - temporal dissolution
    playEnemyDeath(isBoss = false) {
        if (!this.initialized) return;

        const now = this.context.currentTime;
        const duration = isBoss ? 1.5 : 0.6;

        // Descending tone - time unraveling
        const osc = this.context.createOscillator();
        const oscGain = this.context.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(isBoss ? 600 : 400, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + duration);
        oscGain.gain.setValueAtTime(isBoss ? 0.3 : 0.2, now);
        oscGain.gain.exponentialRampToValueAtTime(0.01, now + duration);

        // Filter sweep
        const filter = this.context.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(3000, now);
        filter.frequency.exponentialRampToValueAtTime(100, now + duration);
        filter.Q.value = 5;

        osc.connect(filter);
        filter.connect(oscGain);
        oscGain.connect(this.sfxGain);
        osc.start(now);
        osc.stop(now + duration);

        // Crystalline shatter for boss
        if (isBoss) {
            for (let i = 0; i < 5; i++) {
                const delay = i * 0.1;
                const sparkle = this.context.createOscillator();
                const sparkleGain = this.context.createGain();
                sparkle.type = 'sine';
                sparkle.frequency.setValueAtTime(1200 + i * 200, now + delay);
                sparkle.frequency.exponentialRampToValueAtTime(800 + i * 100, now + delay + 0.3);
                sparkleGain.gain.setValueAtTime(0.15, now + delay);
                sparkleGain.gain.exponentialRampToValueAtTime(0.01, now + delay + 0.3);

                sparkle.connect(sparkleGain);
                sparkleGain.connect(this.sfxGain);
                sparkle.start(now + delay);
                sparkle.stop(now + delay + 0.3);
            }
        }
    }

    // Player damage - painful impact
    playPlayerHit() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Low impact
        const osc1 = this.context.createOscillator();
        const osc1Gain = this.context.createGain();
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(80, now);
        osc1.frequency.exponentialRampToValueAtTime(30, now + 0.2);
        osc1Gain.gain.setValueAtTime(0.5, now);
        osc1Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

        osc1.connect(osc1Gain);
        osc1Gain.connect(this.sfxGain);
        osc1.start(now);
        osc1.stop(now + 0.2);

        // Distorted crunch
        const osc2 = this.context.createOscillator();
        const distortion = this.context.createWaveShaper();
        const osc2Gain = this.context.createGain();

        osc2.type = 'sawtooth';
        osc2.frequency.setValueAtTime(200, now);
        osc2.frequency.exponentialRampToValueAtTime(50, now + 0.15);

        // Create distortion curve
        const curve = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
            const x = (i * 2 / 256) - 1;
            curve[i] = Math.tanh(x * 3);
        }
        distortion.curve = curve;

        osc2Gain.gain.setValueAtTime(0.25, now);
        osc2Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

        osc2.connect(distortion);
        distortion.connect(osc2Gain);
        osc2Gain.connect(this.sfxGain);
        osc2.start(now);
        osc2.stop(now + 0.2);
    }

    // Dash - whoosh with pitch shift
    playDash() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Rising then falling whoosh
        const osc = this.context.createOscillator();
        const oscGain = this.context.createGain();
        const filter = this.context.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.linearRampToValueAtTime(300, now + 0.1);
        osc.frequency.linearRampToValueAtTime(150, now + 0.2);

        filter.type = 'bandpass';
        filter.frequency.value = 1000;
        filter.Q.value = 1;

        oscGain.gain.setValueAtTime(0.2, now);
        oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

        osc.connect(filter);
        filter.connect(oscGain);
        oscGain.connect(this.sfxGain);
        osc.start(now);
        osc.stop(now + 0.25);
    }

    // Time Fracture (Q) - temporal explosion
    playTimeFracture() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Build up
        const buildUp = this.context.createOscillator();
        const buildGain = this.context.createGain();
        buildUp.type = 'sine';
        buildUp.frequency.setValueAtTime(200, now);
        buildUp.frequency.exponentialRampToValueAtTime(800, now + 0.15);
        buildGain.gain.setValueAtTime(0.3, now);
        buildGain.gain.exponentialRampToValueAtTime(0.5, now + 0.15);

        buildUp.connect(buildGain);
        buildGain.connect(this.sfxGain);
        buildUp.start(now);
        buildUp.stop(now + 0.15);

        // Explosion burst
        const bufferSize = this.context.sampleRate * 0.4;
        const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.context.createBufferSource();
        noise.buffer = buffer;

        const filter = this.context.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(3000, now + 0.15);
        filter.frequency.exponentialRampToValueAtTime(200, now + 0.55);

        const noiseGain = this.context.createGain();
        noiseGain.gain.setValueAtTime(0.01, now);
        noiseGain.gain.setValueAtTime(0.5, now + 0.15);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.55);

        noise.connect(filter);
        filter.connect(noiseGain);
        noiseGain.connect(this.sfxGain);
        noise.start(now + 0.15);
        noise.stop(now + 0.55);

        // Deep boom
        const boom = this.context.createOscillator();
        const boomGain = this.context.createGain();
        boom.type = 'sine';
        boom.frequency.setValueAtTime(100, now + 0.15);
        boom.frequency.exponentialRampToValueAtTime(30, now + 0.5);
        boomGain.gain.setValueAtTime(0.6, now + 0.15);
        boomGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

        boom.connect(boomGain);
        boomGain.connect(this.sfxGain);
        boom.start(now + 0.15);
        boom.stop(now + 0.5);
    }

    // Temporal Echo (E) - ghostly reverb
    playTemporalEcho() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Ethereal shimmer
        const osc = this.context.createOscillator();
        const oscGain = this.context.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(440, now);
        osc.frequency.setValueAtTime(660, now + 0.1);
        osc.frequency.setValueAtTime(880, now + 0.2);
        oscGain.gain.setValueAtTime(0.25, now);
        oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

        osc.connect(oscGain);
        oscGain.connect(this.sfxGain);
        osc.start(now);
        osc.stop(now + 0.5);

        // Ghostly whoosh
        const osc2 = this.context.createOscillator();
        const osc2Gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();

        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(300, now);
        osc2.frequency.exponentialRampToValueAtTime(100, now + 0.4);

        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 5;

        osc2Gain.gain.setValueAtTime(0.2, now);
        osc2Gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

        osc2.connect(filter);
        filter.connect(osc2Gain);
        osc2Gain.connect(this.sfxGain);
        osc2.start(now);
        osc2.stop(now + 0.4);
    }

    // Temporal Echo return
    playEchoReturn() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Reverse shimmer (descending)
        const osc = this.context.createOscillator();
        const oscGain = this.context.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(880, now);
        osc.frequency.setValueAtTime(660, now + 0.1);
        osc.frequency.setValueAtTime(440, now + 0.2);
        oscGain.gain.setValueAtTime(0.01, now);
        oscGain.gain.linearRampToValueAtTime(0.3, now + 0.15);
        oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

        osc.connect(oscGain);
        oscGain.connect(this.sfxGain);
        osc.start(now);
        osc.stop(now + 0.4);

        // Snap back effect
        const snap = this.context.createOscillator();
        const snapGain = this.context.createGain();
        snap.type = 'square';
        snap.frequency.setValueAtTime(1000, now + 0.15);
        snap.frequency.exponentialRampToValueAtTime(200, now + 0.25);
        snapGain.gain.setValueAtTime(0.2, now + 0.15);
        snapGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);

        snap.connect(snapGain);
        snapGain.connect(this.sfxGain);
        snap.start(now + 0.15);
        snap.stop(now + 0.25);
    }

    // Chronostasis (R) - time freeze
    playChronostasis() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Deep resonant gong
        const gong = this.context.createOscillator();
        const gongGain = this.context.createGain();
        gong.type = 'sine';
        gong.frequency.setValueAtTime(80, now);
        gongGain.gain.setValueAtTime(0.5, now);
        gongGain.gain.exponentialRampToValueAtTime(0.01, now + 2);

        gong.connect(gongGain);
        gongGain.connect(this.sfxGain);
        gong.start(now);
        gong.stop(now + 2);

        // High crystalline freeze
        const freeze = this.context.createOscillator();
        const freezeGain = this.context.createGain();
        freeze.type = 'sine';
        freeze.frequency.setValueAtTime(2000, now);
        freeze.frequency.exponentialRampToValueAtTime(1500, now + 0.5);
        freezeGain.gain.setValueAtTime(0.25, now);
        freezeGain.gain.exponentialRampToValueAtTime(0.01, now + 1);

        freeze.connect(freezeGain);
        freezeGain.connect(this.sfxGain);
        freeze.start(now);
        freeze.stop(now + 1);

        // Slow-down sweep
        const sweep = this.context.createOscillator();
        const sweepGain = this.context.createGain();
        const filter = this.context.createBiquadFilter();

        sweep.type = 'sawtooth';
        sweep.frequency.setValueAtTime(400, now);
        sweep.frequency.exponentialRampToValueAtTime(50, now + 0.8);

        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(2000, now);
        filter.frequency.exponentialRampToValueAtTime(200, now + 0.8);

        sweepGain.gain.setValueAtTime(0.2, now);
        sweepGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);

        sweep.connect(filter);
        filter.connect(sweepGain);
        sweepGain.connect(this.sfxGain);
        sweep.start(now);
        sweep.stop(now + 0.8);
    }

    // Chronostasis end
    playChronostasisEnd() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Time resuming - ascending sweep
        const sweep = this.context.createOscillator();
        const sweepGain = this.context.createGain();
        sweep.type = 'sawtooth';
        sweep.frequency.setValueAtTime(50, now);
        sweep.frequency.exponentialRampToValueAtTime(400, now + 0.3);
        sweepGain.gain.setValueAtTime(0.2, now);
        sweepGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

        const filter = this.context.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, now);
        filter.frequency.exponentialRampToValueAtTime(2000, now + 0.3);

        sweep.connect(filter);
        filter.connect(sweepGain);
        sweepGain.connect(this.sfxGain);
        sweep.start(now);
        sweep.stop(now + 0.4);
    }

    // Wave announcement
    playWaveStart(waveNumber) {
        if (!this.initialized) return;

        const now = this.context.currentTime;
        const isBossWave = waveNumber % 10 === 0 && waveNumber > 0;

        // Warning horn
        const horn = this.context.createOscillator();
        const hornGain = this.context.createGain();
        horn.type = 'sawtooth';
        horn.frequency.setValueAtTime(isBossWave ? 150 : 200, now);
        hornGain.gain.setValueAtTime(0.3, now);
        hornGain.gain.setValueAtTime(0.3, now + 0.2);
        hornGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

        const filter = this.context.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 600;

        horn.connect(filter);
        filter.connect(hornGain);
        hornGain.connect(this.sfxGain);
        horn.start(now);
        horn.stop(now + 0.4);

        // Second horn blast
        const horn2 = this.context.createOscillator();
        const horn2Gain = this.context.createGain();
        horn2.type = 'sawtooth';
        horn2.frequency.setValueAtTime(isBossWave ? 120 : 250, now + 0.5);
        horn2Gain.gain.setValueAtTime(0.01, now);
        horn2Gain.gain.setValueAtTime(0.35, now + 0.5);
        horn2Gain.gain.setValueAtTime(0.35, now + 0.8);
        horn2Gain.gain.exponentialRampToValueAtTime(0.01, now + 1.2);

        horn2.connect(filter);
        filter.connect(horn2Gain);
        horn2Gain.connect(this.sfxGain);
        horn2.start(now + 0.5);
        horn2.stop(now + 1.2);

        // Boss wave gets extra ominous drone
        if (isBossWave) {
            const doom = this.context.createOscillator();
            const doomGain = this.context.createGain();
            doom.type = 'sine';
            doom.frequency.setValueAtTime(40, now);
            doomGain.gain.setValueAtTime(0.4, now);
            doomGain.gain.exponentialRampToValueAtTime(0.01, now + 2);

            doom.connect(doomGain);
            doomGain.connect(this.sfxGain);
            doom.start(now);
            doom.stop(now + 2);
        }
    }

    // Boss entrance
    playBossEntrance() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Dramatic chord
        const frequencies = [55, 82.5, 110, 165]; // Am chord
        frequencies.forEach((freq, i) => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            osc.type = i === 0 ? 'sawtooth' : 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.01, now);
            gain.gain.linearRampToValueAtTime(0.25, now + 0.5);
            gain.gain.setValueAtTime(0.25, now + 1.5);
            gain.gain.exponentialRampToValueAtTime(0.01, now + 3);

            osc.connect(gain);
            gain.connect(this.sfxGain);
            osc.start(now);
            osc.stop(now + 3);
        });

        // Thunderous impact
        const impact = this.context.createOscillator();
        const impactGain = this.context.createGain();
        impact.type = 'sine';
        impact.frequency.setValueAtTime(60, now + 0.3);
        impact.frequency.exponentialRampToValueAtTime(20, now + 1);
        impactGain.gain.setValueAtTime(0.01, now);
        impactGain.gain.setValueAtTime(0.6, now + 0.3);
        impactGain.gain.exponentialRampToValueAtTime(0.01, now + 1);

        impact.connect(impactGain);
        impactGain.connect(this.sfxGain);
        impact.start(now + 0.3);
        impact.stop(now + 1);
    }

    // Game over
    playGameOver() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Descending death knell
        const knell = this.context.createOscillator();
        const knellGain = this.context.createGain();
        knell.type = 'sine';
        knell.frequency.setValueAtTime(200, now);
        knell.frequency.exponentialRampToValueAtTime(50, now + 1.5);
        knellGain.gain.setValueAtTime(0.4, now);
        knellGain.gain.exponentialRampToValueAtTime(0.01, now + 2);

        knell.connect(knellGain);
        knellGain.connect(this.sfxGain);
        knell.start(now);
        knell.stop(now + 2);

        // Heartbeat fading
        for (let i = 0; i < 3; i++) {
            const beat = this.context.createOscillator();
            const beatGain = this.context.createGain();
            beat.type = 'sine';
            beat.frequency.value = 60;
            beatGain.gain.setValueAtTime(0.01, now + i * 0.8);
            beatGain.gain.linearRampToValueAtTime(0.3 - i * 0.1, now + i * 0.8 + 0.05);
            beatGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.8 + 0.3);

            beat.connect(beatGain);
            beatGain.connect(this.sfxGain);
            beat.start(now + i * 0.8);
            beat.stop(now + i * 0.8 + 0.3);
        }
    }

    // Mote collection
    playMoteCollect() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Bright chime
        const chime = this.context.createOscillator();
        const chimeGain = this.context.createGain();
        chime.type = 'sine';
        chime.frequency.setValueAtTime(800 + Math.random() * 200, now);
        chime.frequency.exponentialRampToValueAtTime(1200 + Math.random() * 200, now + 0.1);
        chimeGain.gain.setValueAtTime(0.15, now);
        chimeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);

        chime.connect(chimeGain);
        chimeGain.connect(this.sfxGain);
        chime.start(now);
        chime.stop(now + 0.2);
    }

    // Wave complete
    playWaveComplete() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Victory fanfare - ascending arpeggio
        const notes = [262, 330, 392, 523]; // C major arpeggio
        notes.forEach((freq, i) => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            osc.type = 'triangle';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.01, now + i * 0.1);
            gain.gain.linearRampToValueAtTime(0.2, now + i * 0.1 + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.4);

            osc.connect(gain);
            gain.connect(this.sfxGain);
            osc.start(now + i * 0.1);
            osc.stop(now + i * 0.1 + 0.4);
        });
    }

    // Enemy spawn sound
    playEnemySpawn() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Materialization whoosh
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();

        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(50, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.2);

        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(100, now);
        filter.frequency.exponentialRampToValueAtTime(800, now + 0.2);
        filter.Q.value = 2;

        gain.gain.setValueAtTime(0.01, now);
        gain.gain.linearRampToValueAtTime(0.2, now + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.sfxGain);
        osc.start(now);
        osc.stop(now + 0.3);
    }

    // Footstep
    playFootstep() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Soft thud
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(80 + Math.random() * 20, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.05);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);

        osc.connect(gain);
        gain.connect(this.sfxGain);
        osc.start(now);
        osc.stop(now + 0.06);
    }

    setVolume(value) {
        this.volume = Math.max(0, Math.min(1, value));
        if (this.masterGain) {
            this.masterGain.gain.value = this.volume;
        }
    }

    stopAmbience() {
        this.ambientOscillators.forEach(osc => {
            try {
                osc.stop();
            } catch (e) {}
        });
        this.ambientOscillators = [];
    }

    // V2.8 - Pistol shot
    playPistolShot() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Sharp crack
        const crack = this.context.createOscillator();
        const crackGain = this.context.createGain();
        crack.type = 'square';
        crack.frequency.setValueAtTime(800, now);
        crack.frequency.exponentialRampToValueAtTime(200, now + 0.05);
        crackGain.gain.setValueAtTime(0.3, now);
        crackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

        crack.connect(crackGain);
        crackGain.connect(this.sfxGain);
        crack.start(now);
        crack.stop(now + 0.08);

        // Temporal energy discharge
        const energy = this.context.createOscillator();
        const energyGain = this.context.createGain();
        energy.type = 'sine';
        energy.frequency.setValueAtTime(1200, now);
        energy.frequency.exponentialRampToValueAtTime(400, now + 0.1);
        energyGain.gain.setValueAtTime(0.15, now);
        energyGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);

        energy.connect(energyGain);
        energyGain.connect(this.sfxGain);
        energy.start(now);
        energy.stop(now + 0.12);
    }

    // V2.8 - Pistol reload
    playPistolReload() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Mechanical click sequence
        for (let i = 0; i < 3; i++) {
            const click = this.context.createOscillator();
            const clickGain = this.context.createGain();
            click.type = 'square';
            click.frequency.setValueAtTime(500 + i * 100, now + i * 0.15);
            click.frequency.exponentialRampToValueAtTime(200, now + i * 0.15 + 0.03);
            clickGain.gain.setValueAtTime(0.2, now + i * 0.15);
            clickGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.05);

            click.connect(clickGain);
            clickGain.connect(this.sfxGain);
            click.start(now + i * 0.15);
            click.stop(now + i * 0.15 + 0.05);
        }

        // Energy charging sound
        const charge = this.context.createOscillator();
        const chargeGain = this.context.createGain();
        charge.type = 'sine';
        charge.frequency.setValueAtTime(200, now + 0.3);
        charge.frequency.exponentialRampToValueAtTime(800, now + 0.8);
        chargeGain.gain.setValueAtTime(0.1, now + 0.3);
        chargeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.9);

        charge.connect(chargeGain);
        chargeGain.connect(this.sfxGain);
        charge.start(now + 0.3);
        charge.stop(now + 0.9);
    }

    // V2.8 - Scythe sweep (bigger, more resonant)
    playScytheSwing() {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Deep whoosh
        const bufferSize = this.context.sampleRate * 0.4;
        const buffer = this.context.createBuffer(1, bufferSize, this.context.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.context.createBufferSource();
        noise.buffer = buffer;

        const filter = this.context.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(600, now);
        filter.frequency.exponentialRampToValueAtTime(200, now + 0.35);
        filter.Q.value = 3;

        const gain = this.context.createGain();
        gain.gain.setValueAtTime(0.35, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.sfxGain);
        noise.start(now);
        noise.stop(now + 0.4);

        // Harmonic hum
        const hum = this.context.createOscillator();
        const humGain = this.context.createGain();
        hum.type = 'sine';
        hum.frequency.setValueAtTime(150, now);
        hum.frequency.exponentialRampToValueAtTime(80, now + 0.3);
        humGain.gain.setValueAtTime(0.2, now);
        humGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);

        hum.connect(humGain);
        humGain.connect(this.sfxGain);
        hum.start(now);
        hum.stop(now + 0.35);
    }

    // V2.8 - Combo milestone sound
    playComboMilestone(tier) {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Higher pitch for higher combos
        const baseFreq = 400 + tier * 100;

        // Triumphant chime
        const notes = [baseFreq, baseFreq * 1.25, baseFreq * 1.5];
        notes.forEach((freq, i) => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.setValueAtTime(0.01, now + i * 0.08);
            gain.gain.linearRampToValueAtTime(0.2, now + i * 0.08 + 0.03);
            gain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.08 + 0.3);

            osc.connect(gain);
            gain.connect(this.sfxGain);
            osc.start(now + i * 0.08);
            osc.stop(now + i * 0.08 + 0.3);
        });
    }

    // V2.8 - Low health heartbeat
    playHeartbeat(intensity = 1) {
        if (!this.initialized) return;

        const now = this.context.currentTime;

        // Double beat
        for (let i = 0; i < 2; i++) {
            const beat = this.context.createOscillator();
            const beatGain = this.context.createGain();
            beat.type = 'sine';
            beat.frequency.value = 50;
            beatGain.gain.setValueAtTime(0.01, now + i * 0.15);
            beatGain.gain.linearRampToValueAtTime(0.3 * intensity, now + i * 0.15 + 0.02);
            beatGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.15 + 0.15);

            beat.connect(beatGain);
            beatGain.connect(this.sfxGain);
            beat.start(now + i * 0.15);
            beat.stop(now + i * 0.15 + 0.15);
        }
    }

    // V2.8 - Set ambient intensity based on combat
    setAmbientIntensity(intensity) {
        if (!this.ambientGain) return;
        const targetValue = 0.1 + intensity * 0.15;
        this.ambientGain.gain.setTargetAtTime(targetValue, this.context.currentTime, 0.5);
    }
}

// Global audio manager instance
const audioManager = new AudioManager();

// ‚îÄ‚îÄ‚îÄ SWORD CLASS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Sword {
    constructor(scene, player) {
        this.scene = scene;
        this.player = player;

        // Sword properties
        this.mesh = null;
        this.bladeGlow = null;
        this.trailMesh = null;
        this.trailPositions = [];

        // Attack state
        this.isAttacking = false;
        this.attackPhase = 'none'; // 'windup', 'active', 'recovery'
        this.attackType = 'none'; // 'light', 'heavy'
        this.attackTimer = 0;
        this.comboCount = 0;
        this.comboTimer = 0;
        this.canCombo = false;
        this.hitFrameSet = false; // V2 - Track if hitFrame was set for current attack

        // Attack timings
        this.lightAttackTimings = {
            windup: 0.1,
            active: 0.15,
            recovery: 0.2
        };
        this.heavyAttackTimings = {
            windup: 0.4,
            active: 0.2,
            recovery: 0.5
        };

        // Animation values
        this.swingAngle = 0;
        this.targetSwingAngle = 0;
        this.swingProgress = 0;

        // Charge level colors
        this.chargeColors = [
            new THREE.Color(0x4a90b8), // Level 0: Blue
            new THREE.Color(0x5aa0c8), // Level 1: Bright blue
            new THREE.Color(0xffffff), // Level 2: White
            new THREE.Color(0xd4af37), // Level 3: Gold
            new THREE.Color(0xffd700)  // Level 4: Brilliant gold
        ];

        this.createMesh();
        this.createTrail();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Blade material - crystallized time (translucent with glow)
        const bladeMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90b8,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.85,
            metalness: 0.3,
            roughness: 0.2
        });
        this.bladeMaterial = bladeMaterial;

        // Handle material
        const handleMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a3a,
            metalness: 0.8,
            roughness: 0.3
        });

        // Gold accent material
        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });

        // Blade - long, elegant shape (1.5 units)
        const bladeGeometry = new THREE.BoxGeometry(0.08, 1.2, 0.02);
        const blade = new THREE.Mesh(bladeGeometry, bladeMaterial);
        blade.position.y = 0.75;
        blade.castShadow = true;
        this.mesh.add(blade);
        this.blade = blade;

        // Blade tip (pointed)
        const tipGeometry = new THREE.ConeGeometry(0.04, 0.25, 4);
        const tip = new THREE.Mesh(tipGeometry, bladeMaterial);
        tip.position.y = 1.45;
        tip.castShadow = true;
        this.mesh.add(tip);

        // Blade edge glow (inner light)
        const edgeGeometry = new THREE.BoxGeometry(0.02, 1.1, 0.005);
        const edgeMaterial = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 0.9
        });
        const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
        edge.position.y = 0.7;
        edge.position.z = 0.012;
        this.mesh.add(edge);
        this.bladeEdge = edge;

        // Crossguard
        const crossguardGeometry = new THREE.BoxGeometry(0.3, 0.08, 0.06);
        const crossguard = new THREE.Mesh(crossguardGeometry, goldMaterial);
        crossguard.position.y = 0.1;
        crossguard.castShadow = true;
        this.mesh.add(crossguard);

        // Clock face in crossguard
        const clockFaceGeometry = new THREE.CylinderGeometry(0.06, 0.06, 0.07, 16);
        const clockFaceMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a90b8,
            transparent: true,
            opacity: 0.8
        });
        const clockFace = new THREE.Mesh(clockFaceGeometry, clockFaceMaterial);
        clockFace.position.set(0, 0.1, 0.035);
        clockFace.rotation.x = Math.PI / 2;
        this.mesh.add(clockFace);
        this.clockFace = clockFace;

        // Clock hands on crossguard
        const handGeometry = new THREE.BoxGeometry(0.01, 0.04, 0.005);
        const hourHand = new THREE.Mesh(handGeometry, new THREE.MeshBasicMaterial({ color: 0xd4af37 }));
        hourHand.position.set(0, 0.1, 0.075);
        this.mesh.add(hourHand);
        this.clockHourHand = hourHand;

        const minuteHandGeometry = new THREE.BoxGeometry(0.008, 0.05, 0.005);
        const minuteHand = new THREE.Mesh(minuteHandGeometry, new THREE.MeshBasicMaterial({ color: 0xd4af37 }));
        minuteHand.position.set(0, 0.1, 0.075);
        this.mesh.add(minuteHand);
        this.clockMinuteHand = minuteHand;

        // Handle
        const handleGeometry = new THREE.CylinderGeometry(0.03, 0.035, 0.25, 8);
        const handle = new THREE.Mesh(handleGeometry, handleMaterial);
        handle.position.y = -0.05;
        handle.castShadow = true;
        this.mesh.add(handle);

        // Pommel
        const pommelGeometry = new THREE.SphereGeometry(0.045, 8, 8);
        const pommel = new THREE.Mesh(pommelGeometry, goldMaterial);
        pommel.position.y = -0.2;
        this.mesh.add(pommel);

        // Blade glow light
        this.bladeGlow = new THREE.PointLight(0x4a90b8, 0.6, 3);
        this.bladeGlow.position.y = 0.8;
        this.mesh.add(this.bladeGlow);

        // Initial position (held at side)
        this.mesh.position.set(0.5, 0.3, 0.5);
        this.mesh.rotation.x = -0.8;
        this.mesh.rotation.z = -0.2;
    }

    createTrail() {
        // Create trail geometry
        const trailLength = CONFIG.trailSegments;
        const trailGeometry = new THREE.BufferGeometry();

        // Each segment is a quad (2 triangles, 6 vertices)
        const positions = new Float32Array(trailLength * 6 * 3);
        const colors = new Float32Array(trailLength * 6 * 4);

        trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 4));

        const trailMaterial = new THREE.MeshBasicMaterial({
            vertexColors: true,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        this.trailMesh = new THREE.Mesh(trailGeometry, trailMaterial);
        this.trailMesh.frustumCulled = false;
        this.scene.add(this.trailMesh);

        // Initialize trail positions
        for (let i = 0; i < trailLength; i++) {
            this.trailPositions.push({
                base: new THREE.Vector3(),
                tip: new THREE.Vector3(),
                alpha: 0
            });
        }
    }

    update(deltaTime, elapsedTime) {
        // Update charge-based color
        this.updateBladeColor();

        // Animate clock hands on crossguard
        this.clockHourHand.rotation.z = elapsedTime * 0.5;
        this.clockMinuteHand.rotation.z = elapsedTime * 2;

        // Update attack animation
        if (this.isAttacking) {
            this.updateAttack(deltaTime);
        } else {
            // Idle sword sway
            this.mesh.rotation.x = -0.8 + Math.sin(elapsedTime * 2) * 0.02;
        }

        // Update combo timer
        if (this.comboTimer > 0) {
            this.comboTimer -= deltaTime;
            if (this.comboTimer <= 0) {
                this.comboCount = 0;
            }
        }

        // Update trail
        this.updateTrail();
    }

    updateBladeColor() {
        const chargeRatio = this.player.temporalCharge / CONFIG.maxCharge;
        let colorIndex = 0;

        if (chargeRatio >= 1.0) colorIndex = 4;
        else if (chargeRatio >= 0.75) colorIndex = 3;
        else if (chargeRatio >= 0.5) colorIndex = 2;
        else if (chargeRatio >= 0.25) colorIndex = 1;

        const targetColor = this.chargeColors[colorIndex];

        // Lerp to target color
        this.bladeMaterial.color.lerp(targetColor, 0.1);
        this.bladeMaterial.emissive.lerp(targetColor, 0.1);
        this.bladeGlow.color.lerp(targetColor, 0.1);

        // Increase intensity with charge
        this.bladeMaterial.emissiveIntensity = 0.5 + chargeRatio * 0.5;
        this.bladeGlow.intensity = 0.6 + chargeRatio * 0.8;
    }

    startLightAttack() {
        if (this.isAttacking && !this.canCombo) return false;
        if (this.player.stamina < CONFIG.lightAttackStamina) return false;
        if (this.player.isSprinting) return false;

        // Use stamina
        this.player.stamina -= CONFIG.lightAttackStamina;
        this.player.staminaRegenTimer = CONFIG.staminaRegenDelay;

        // Track combo
        if (this.canCombo && this.comboCount < 3) {
            this.comboCount++;
        } else {
            this.comboCount = 1;
        }

        this.isAttacking = true;
        this.attackType = 'light';
        this.attackPhase = 'windup';
        this.attackTimer = 0;
        this.canCombo = false;
        this.swingProgress = 0;
        this.hitFrameSet = false; // V2 - Reset hit tracking for new attack

        // Determine swing direction based on combo
        if (this.comboCount === 1) {
            this.targetSwingAngle = Math.PI * 0.6; // Right to left
        } else if (this.comboCount === 2) {
            this.targetSwingAngle = -Math.PI * 0.6; // Left to right
        } else {
            this.targetSwingAngle = Math.PI * 0.8; // Overhead slam
        }

        // Play swing sound - V2.8: weapon-specific
        if (this.player.currentWeapon === 'scythe') {
            audioManager.playScytheSwing();
        } else {
            audioManager.playSwing(false);
        }

        return true;
    }

    startHeavyAttack() {
        if (this.isAttacking) return false;
        if (this.player.stamina < CONFIG.heavyAttackStamina) return false;
        if (this.player.isSprinting) return false;

        // Use stamina
        this.player.stamina -= CONFIG.heavyAttackStamina;
        this.player.staminaRegenTimer = CONFIG.staminaRegenDelay;

        this.isAttacking = true;
        this.attackType = 'heavy';
        this.attackPhase = 'windup';
        this.attackTimer = 0;
        this.comboCount = 0;
        this.canCombo = false;
        this.swingProgress = 0;
        this.hitFrameSet = false; // V2 - Reset hit tracking for new attack
        this.targetSwingAngle = Math.PI; // Full overhead

        // Play heavy swing sound - V2.8: weapon-specific
        if (this.player.currentWeapon === 'scythe') {
            audioManager.playScytheSwing();
        } else {
            audioManager.playSwing(true);
        }

        return true;
    }

    updateAttack(deltaTime) {
        const timings = this.attackType === 'light' ? this.lightAttackTimings : this.heavyAttackTimings;

        this.attackTimer += deltaTime;

        switch (this.attackPhase) {
            case 'windup':
                // Wind up animation
                const windupProgress = this.attackTimer / timings.windup;
                this.animateWindup(windupProgress);

                if (this.attackTimer >= timings.windup) {
                    this.attackPhase = 'active';
                    this.attackTimer = 0;
                }
                break;

            case 'active':
                // Active swing - hitbox is active
                const activeProgress = this.attackTimer / timings.active;
                this.animateSwing(activeProgress);

                if (this.attackTimer >= timings.active) {
                    this.attackPhase = 'recovery';
                    this.attackTimer = 0;
                    // Can combo during recovery for light attacks
                    if (this.attackType === 'light' && this.comboCount < 3) {
                        this.canCombo = true;
                        this.comboTimer = 0.5; // Window to input next attack
                    }
                }
                break;

            case 'recovery':
                // Recovery animation
                const recoveryProgress = this.attackTimer / timings.recovery;
                this.animateRecovery(recoveryProgress);

                if (this.attackTimer >= timings.recovery) {
                    this.endAttack();
                }
                break;
        }
    }

    animateWindup(progress) {
        const eased = this.easeOutQuad(progress);

        if (this.comboCount === 3 || this.attackType === 'heavy') {
            // Overhead swing - raise sword high
            this.mesh.rotation.x = -0.8 - eased * 2.0;
            this.mesh.rotation.z = -0.2 + eased * 0.2;
            this.mesh.position.y = 0.3 + eased * 0.5;
        } else if (this.comboCount === 2) {
            // Left side swing
            this.mesh.rotation.x = -0.8 - eased * 0.3;
            this.mesh.rotation.z = -0.2 - eased * 1.2;
            this.mesh.position.x = 0.5 - eased * 0.8;
        } else {
            // Right side swing (default)
            this.mesh.rotation.x = -0.8 - eased * 0.3;
            this.mesh.rotation.z = -0.2 + eased * 1.2;
            this.mesh.position.x = 0.5 + eased * 0.3;
        }
    }

    animateSwing(progress) {
        const eased = this.easeInQuad(progress);

        if (this.comboCount === 3 || this.attackType === 'heavy') {
            // Overhead slam down
            this.mesh.rotation.x = -2.8 + eased * 3.5;
            this.mesh.position.y = 0.8 - eased * 0.6;
            this.mesh.position.z = 0.5 + eased * 0.5;
        } else if (this.comboCount === 2) {
            // Swing from left to right
            this.mesh.rotation.z = -1.4 + eased * 2.6;
            this.mesh.position.x = -0.3 + eased * 1.0;
        } else {
            // Swing from right to left
            this.mesh.rotation.z = 1.0 - eased * 2.4;
            this.mesh.position.x = 0.8 - eased * 0.8;
        }

        this.swingProgress = progress;
    }

    animateRecovery(progress) {
        const eased = this.easeOutQuad(progress);

        // Return to idle position
        this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, -0.8, eased);
        this.mesh.rotation.z = THREE.MathUtils.lerp(this.mesh.rotation.z, -0.2, eased);
        this.mesh.position.x = THREE.MathUtils.lerp(this.mesh.position.x, 0.5, eased);
        this.mesh.position.y = THREE.MathUtils.lerp(this.mesh.position.y, 0.3, eased);
        this.mesh.position.z = THREE.MathUtils.lerp(this.mesh.position.z, 0.5, eased);
    }

    endAttack() {
        this.isAttacking = false;
        this.attackPhase = 'none';
        this.attackType = 'none';
        this.canCombo = false;

        // Reset combo if timer expired
        if (this.comboTimer <= 0) {
            this.comboCount = 0;
        }
    }

    updateTrail() {
        // Shift trail positions
        for (let i = this.trailPositions.length - 1; i > 0; i--) {
            this.trailPositions[i].base.copy(this.trailPositions[i - 1].base);
            this.trailPositions[i].tip.copy(this.trailPositions[i - 1].tip);
            this.trailPositions[i].alpha = this.trailPositions[i - 1].alpha * 0.85;
        }

        // Get current sword world positions
        const swordWorldMatrix = new THREE.Matrix4();
        this.mesh.updateMatrixWorld();
        swordWorldMatrix.copy(this.mesh.matrixWorld);

        // Transform blade base and tip to world space
        const bladeBase = new THREE.Vector3(0, 0.15, 0);
        const bladeTip = new THREE.Vector3(0, 1.5, 0);

        bladeBase.applyMatrix4(swordWorldMatrix);
        bladeTip.applyMatrix4(swordWorldMatrix);

        this.trailPositions[0].base.copy(bladeBase);
        this.trailPositions[0].tip.copy(bladeTip);

        // Trail is visible during attacks
        if (this.isAttacking && this.attackPhase === 'active') {
            this.trailPositions[0].alpha = 1.0;
        } else {
            this.trailPositions[0].alpha = Math.max(0, this.trailPositions[0].alpha - 0.1);
        }

        // Update trail geometry
        const positions = this.trailMesh.geometry.attributes.position.array;
        const colors = this.trailMesh.geometry.attributes.color.array;

        const chargeRatio = this.player.temporalCharge / CONFIG.maxCharge;
        const trailColor = this.bladeMaterial.color;

        for (let i = 0; i < this.trailPositions.length - 1; i++) {
            const curr = this.trailPositions[i];
            const next = this.trailPositions[i + 1];
            const alpha = curr.alpha * (1 - i / this.trailPositions.length);

            const idx = i * 18; // 6 vertices * 3 components

            // First triangle
            positions[idx] = curr.base.x;
            positions[idx + 1] = curr.base.y;
            positions[idx + 2] = curr.base.z;

            positions[idx + 3] = curr.tip.x;
            positions[idx + 4] = curr.tip.y;
            positions[idx + 5] = curr.tip.z;

            positions[idx + 6] = next.tip.x;
            positions[idx + 7] = next.tip.y;
            positions[idx + 8] = next.tip.z;

            // Second triangle
            positions[idx + 9] = curr.base.x;
            positions[idx + 10] = curr.base.y;
            positions[idx + 11] = curr.base.z;

            positions[idx + 12] = next.tip.x;
            positions[idx + 13] = next.tip.y;
            positions[idx + 14] = next.tip.z;

            positions[idx + 15] = next.base.x;
            positions[idx + 16] = next.base.y;
            positions[idx + 17] = next.base.z;

            // Colors with alpha
            const cIdx = i * 24; // 6 vertices * 4 components
            for (let j = 0; j < 6; j++) {
                colors[cIdx + j * 4] = trailColor.r;
                colors[cIdx + j * 4 + 1] = trailColor.g;
                colors[cIdx + j * 4 + 2] = trailColor.b;
                colors[cIdx + j * 4 + 3] = alpha * (0.6 + chargeRatio * 0.4);
            }
        }

        this.trailMesh.geometry.attributes.position.needsUpdate = true;
        this.trailMesh.geometry.attributes.color.needsUpdate = true;
    }

    // Get attack hitbox for collision detection
    getAttackHitbox() {
        if (!this.isAttacking || this.attackPhase !== 'active') {
            return null;
        }

        // Get sword tip world position
        this.mesh.updateMatrixWorld();
        const tipLocal = new THREE.Vector3(0, 1.2, 0);
        const tipWorld = tipLocal.applyMatrix4(this.mesh.matrixWorld);

        return {
            position: tipWorld,
            radius: CONFIG.weapons.blade.range, // Use blade's configured range (3)
            arc: CONFIG.weapons.blade.arc,      // Use blade's configured arc (120)
            playerRotation: this.player.rotation,
            damage: this.getDamage()
        };
    }

    getDamage() {
        let baseDamage = this.attackType === 'heavy' ? CONFIG.weapons.blade.heavyDamage : CONFIG.weapons.blade.lightDamage;

        // Combo bonus for third light attack
        if (this.attackType === 'light' && this.comboCount === 3) {
            baseDamage = CONFIG.weapons.blade.heavyDamage; // Overhead slam does heavy damage
        }

        // Charge bonus
        const chargeRatio = this.player.temporalCharge / CONFIG.maxCharge;
        let multiplier = 1.0;

        if (chargeRatio >= 1.0) multiplier = 1.5;
        else if (chargeRatio >= 0.75) multiplier = 1.3;
        else if (chargeRatio >= 0.5) multiplier = 1.2;
        else if (chargeRatio >= 0.25) multiplier = 1.1;

        return baseDamage * multiplier;
    }

    // Easing functions
    easeOutQuad(t) {
        return t * (2 - t);
    }

    easeInQuad(t) {
        return t * t;
    }

    easeInOutQuad(t) {
        return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    }
}

// ‚îÄ‚îÄ‚îÄ ENEMY BASE CLASS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Enemy {
    constructor(scene, position) {
        this.scene = scene;
        this.position = position.clone();
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.rotation = 0;

        this.health = 40;
        this.maxHealth = 40;
        this.damage = 15;
        this.speed = 6;
        this.points = 100;

        this.mesh = null;
        this.isAlive = true;
        this.isDying = false;
        this.deathTimer = 0;

        // State
        this.state = 'SPAWN';
        this.stateTimer = 0;

        // Hit flash
        this.isFlashing = false;
        this.flashTimer = 0;

        // Hit tracking (prevent multiple hits from same attack)
        this.lastHitFrame = -1;

        // Track if this attack already hit the player (prevent multi-hit)
        this.hasHitPlayer = false;

        // Health bar sprite (will be created in subclass after mesh exists)
        this.healthBarSprite = null;
        this.healthBarCanvas = null;
        this.healthBarContext = null;
        this.enemyName = 'Enemy'; // Override in subclass
        this.healthBarHeight = 2.0; // Height above enemy mesh
    }

    createHealthBar() {
        // Create canvas for health bar
        this.healthBarCanvas = document.createElement('canvas');
        this.healthBarCanvas.width = 128;
        this.healthBarCanvas.height = 32;
        this.healthBarContext = this.healthBarCanvas.getContext('2d');

        // Create texture and sprite
        const texture = new THREE.CanvasTexture(this.healthBarCanvas);
        texture.minFilter = THREE.LinearFilter;
        const spriteMaterial = new THREE.SpriteMaterial({
            map: texture,
            transparent: true,
            depthTest: false
        });
        this.healthBarSprite = new THREE.Sprite(spriteMaterial);
        this.healthBarSprite.scale.set(1.5, 0.4, 1);
        this.healthBarSprite.renderOrder = 999; // Render on top

        // Add to scene (not to mesh, so it billboards properly)
        this.scene.add(this.healthBarSprite);

        // Initial draw
        this.updateHealthBar();
    }

    updateHealthBar() {
        if (!this.healthBarContext || !this.healthBarSprite) return;

        const ctx = this.healthBarContext;
        const w = this.healthBarCanvas.width;
        const h = this.healthBarCanvas.height;

        // Clear canvas
        ctx.clearRect(0, 0, w, h);

        // Draw enemy name (semi-transparent, small)
        ctx.font = '10px Arial';
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.textAlign = 'center';
        ctx.fillText(this.enemyName.toUpperCase(), w / 2, 10);

        // Health bar background
        const barX = 8;
        const barY = 14;
        const barWidth = w - 16;
        const barHeight = 12;

        // Background (dark, semi-transparent)
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // Health fill
        const healthPercent = Math.max(0, this.health / this.maxHealth);
        const fillWidth = barWidth * healthPercent;

        // Color based on health (green -> yellow -> red)
        let fillColor;
        if (healthPercent > 0.6) {
            fillColor = `rgba(50, 205, 50, 0.8)`; // Green
        } else if (healthPercent > 0.3) {
            fillColor = `rgba(255, 200, 0, 0.8)`; // Yellow
        } else {
            fillColor = `rgba(255, 60, 60, 0.8)`; // Red
        }
        ctx.fillStyle = fillColor;
        ctx.fillRect(barX, barY, fillWidth, barHeight);

        // Border
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);

        // Update texture
        this.healthBarSprite.material.map.needsUpdate = true;

        // Position sprite above enemy
        if (this.mesh) {
            this.healthBarSprite.position.set(
                this.mesh.position.x,
                this.mesh.position.y + this.healthBarHeight,
                this.mesh.position.z
            );
        }
    }

    hideHealthBar() {
        if (this.healthBarSprite) {
            this.healthBarSprite.visible = false;
        }
    }

    takeDamage(amount, hitFrame) {
        // Prevent double hits from same attack
        if (hitFrame === this.lastHitFrame) return false;
        this.lastHitFrame = hitFrame;

        this.health -= amount;
        this.isFlashing = true;
        this.flashTimer = 0.08;

        if (this.health <= 0) {
            this.die();
            return 'killed'; // Enemy killed
        }
        return true; // Enemy damaged but alive
    }

    die() {
        this.isAlive = false;
        this.isDying = true;
        this.deathTimer = 0;
        this.state = 'DEAD';
    }

    update(deltaTime, playerPosition) {
        // Override in subclasses
    }

    updateFlash(deltaTime) {
        if (this.isFlashing) {
            this.flashTimer -= deltaTime;
            if (this.flashTimer <= 0) {
                this.isFlashing = false;
                this.restoreMaterials();
            } else {
                this.applyFlash();
            }
        }
    }

    applyFlash() {
        // Override in subclasses
    }

    restoreMaterials() {
        // Override in subclasses
    }

    destroy() {
        if (this.mesh) {
            this.scene.remove(this.mesh);
        }
        if (this.healthBarSprite) {
            this.scene.remove(this.healthBarSprite);
            this.healthBarSprite = null;
        }
    }
}

// ‚îÄ‚îÄ‚îÄ TICK ENEMY CLASS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Tick extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Tick';
        this.healthBarHeight = 1.5;

        // V2: Apply difficulty modifiers
        const baseDamage = 8; // Low damage - player can take ~12 hits on Normal
        const baseSpeed = 5; // Slower approach
        const baseHealth = 40; // With light attack (25 dmg): Easy=1hit, Normal=2hits, Hard=3hits, Nightmare=4hits
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 100;

        // State timings - V2: telegraph affected by difficulty
        const baseTelegraph = 0.6;
        this.stateTimes = {
            SPAWN: 1.0,
            IDLE: 0.5,
            APPROACH: 0, // Until within range
            TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            ATTACK: 0.3,
            RECOVER: 0.8
        };

        // Attack properties
        this.attackRange = 3;
        this.lungeDistance = 4;
        this.lungeDirection = new THREE.Vector3();

        // Animation
        this.legPhase = 0;
        this.clockHandRotation = 0;

        // Materials (stored for flash effect)
        this.materials = {};

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b7355,
            metalness: 0.7,
            roughness: 0.3
        });
        this.materials.body = bodyMaterial;

        const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90b8,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.3,
            transparent: true,
            opacity: 0.7,
            metalness: 0.2,
            roughness: 0.1
        });
        this.materials.glass = glassMaterial;

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });
        this.materials.gold = goldMaterial;

        // Main body - spherical clock face
        const bodyGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        this.mesh.add(body);
        this.bodyMesh = body;

        // Clock face (front)
        const faceGeometry = new THREE.CylinderGeometry(0.45, 0.45, 0.1, 24);
        const face = new THREE.Mesh(faceGeometry, glassMaterial);
        face.position.set(0, 0, 0.35);
        face.rotation.x = Math.PI / 2;
        face.castShadow = true;
        this.mesh.add(face);

        // Clock ring
        const ringGeometry = new THREE.TorusGeometry(0.45, 0.05, 8, 24);
        const ring = new THREE.Mesh(ringGeometry, goldMaterial);
        ring.position.set(0, 0, 0.4);
        this.mesh.add(ring);

        // Eye in center
        const eyeGeometry = new THREE.SphereGeometry(0.1, 12, 12);
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444,
            emissive: 0xff4444
        });
        this.materials.eye = eyeMaterial;
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.set(0, 0, 0.45);
        this.mesh.add(eye);
        this.eye = eye;

        // Clock hands
        const hourHandGeometry = new THREE.BoxGeometry(0.03, 0.2, 0.02);
        const hourHand = new THREE.Mesh(hourHandGeometry, goldMaterial);
        hourHand.position.set(0, 0.1, 0.42);
        this.mesh.add(hourHand);
        this.hourHand = hourHand;

        const minuteHandGeometry = new THREE.BoxGeometry(0.02, 0.3, 0.02);
        const minuteHand = new THREE.Mesh(minuteHandGeometry, goldMaterial);
        minuteHand.position.set(0, 0.15, 0.42);
        this.mesh.add(minuteHand);
        this.minuteHand = minuteHand;

        // Roman numerals (small marks)
        for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI * 2) / 12;
            const markGeometry = new THREE.BoxGeometry(0.02, 0.06, 0.02);
            const mark = new THREE.Mesh(markGeometry, goldMaterial);
            mark.position.set(
                Math.sin(angle) * 0.35,
                Math.cos(angle) * 0.35,
                0.42
            );
            mark.rotation.z = -angle;
            this.mesh.add(mark);
        }

        // Spider legs (4 legs)
        this.legs = [];
        const legMaterial = new THREE.MeshStandardMaterial({
            color: 0x6b5344,
            metalness: 0.6,
            roughness: 0.4
        });
        this.materials.leg = legMaterial;

        for (let i = 0; i < 4; i++) {
            const legGroup = new THREE.Group();

            // Upper leg
            const upperLegGeometry = new THREE.CylinderGeometry(0.04, 0.03, 0.4, 8);
            const upperLeg = new THREE.Mesh(upperLegGeometry, legMaterial);
            upperLeg.position.y = -0.2;
            legGroup.add(upperLeg);

            // Lower leg
            const lowerLegGroup = new THREE.Group();
            const lowerLegGeometry = new THREE.CylinderGeometry(0.03, 0.02, 0.5, 8);
            const lowerLeg = new THREE.Mesh(lowerLegGeometry, legMaterial);
            lowerLeg.position.y = -0.25;
            lowerLegGroup.add(lowerLeg);

            // Foot (claw)
            const footGeometry = new THREE.ConeGeometry(0.03, 0.1, 4);
            const foot = new THREE.Mesh(footGeometry, goldMaterial);
            foot.position.y = -0.55;
            foot.rotation.x = Math.PI;
            lowerLegGroup.add(foot);

            lowerLegGroup.position.y = -0.4;
            lowerLegGroup.rotation.x = 0.5;
            legGroup.add(lowerLegGroup);

            // Position legs around body
            const angle = (i * Math.PI * 2) / 4 + Math.PI / 4;
            legGroup.position.set(
                Math.cos(angle) * 0.35,
                0,
                Math.sin(angle) * 0.35
            );
            legGroup.rotation.z = Math.cos(angle) * 0.5;
            legGroup.rotation.x = Math.sin(angle) * 0.5;

            this.mesh.add(legGroup);
            this.legs.push({ group: legGroup, lower: lowerLegGroup, baseAngle: angle });
        }

        // Trailing gears/springs
        const gearGeometry = new THREE.TorusGeometry(0.1, 0.02, 6, 12);
        const trailGear1 = new THREE.Mesh(gearGeometry, bodyMaterial);
        trailGear1.position.set(0, -0.3, -0.3);
        trailGear1.rotation.x = Math.random() * Math.PI;
        this.mesh.add(trailGear1);
        this.trailGear = trailGear1;

        const springGeometry = new THREE.TorusGeometry(0.05, 0.015, 4, 12, Math.PI * 3);
        const spring = new THREE.Mesh(springGeometry, goldMaterial);
        spring.position.set(0.2, -0.2, -0.2);
        this.mesh.add(spring);

        // Point light for eye glow
        const eyeLight = new THREE.PointLight(0xff4444, 0.3, 2);
        eyeLight.position.set(0, 0, 0.5);
        this.mesh.add(eyeLight);
        this.eyeLight = eyeLight;

        // Position mesh
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 0.6; // Hover height
        this.scene.add(this.mesh);

        // Start invisible for spawn animation
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        // Handle death animation
        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate clock hands (erratic spinning)
        this.clockHandRotation += deltaTime * 5;
        this.hourHand.rotation.z = Math.sin(this.clockHandRotation * 2) * Math.PI;
        this.minuteHand.rotation.z = Math.sin(this.clockHandRotation * 3 + 1) * Math.PI;

        // Rotate trailing gear
        this.trailGear.rotation.x += deltaTime * 2;
        this.trailGear.rotation.y += deltaTime;

        // Direction to player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        // State machine
        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'IDLE':
                this.updateIdle(deltaTime, toPlayer);
                break;
            case 'APPROACH':
                this.updateApproach(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'TELEGRAPH':
                this.updateTelegraph(deltaTime, toPlayer);
                break;
            case 'ATTACK':
                this.updateAttack(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
        }

        // Update mesh position
        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        // Scale up animation
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        const scale = Math.min(1, progress * 1.5);
        this.mesh.scale.set(scale, scale, scale);

        // Spin clock hands rapidly
        this.hourHand.rotation.z = this.stateTimer * 20;
        this.minuteHand.rotation.z = this.stateTimer * 30;

        // Invulnerable during spawn
        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'IDLE';
            this.stateTimer = 0;
            this.mesh.scale.set(1, 1, 1);
        }
    }

    updateIdle(deltaTime, toPlayer) {
        // Brief pause, "noticing" player
        // Point clock hands at player
        const angleToPlayer = Math.atan2(toPlayer.x, toPlayer.z);
        this.hourHand.rotation.z = angleToPlayer;
        this.minuteHand.rotation.z = angleToPlayer;

        // Face player
        this.rotation = angleToPlayer;
        this.mesh.rotation.y = this.rotation;

        if (this.stateTimer >= this.stateTimes.IDLE) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
        }
    }

    updateApproach(deltaTime, toPlayer, distanceToPlayer) {
        // Move toward player
        this.velocity.x = toPlayer.x * this.speed;
        this.velocity.z = toPlayer.z * this.speed;

        this.position.x += this.velocity.x * deltaTime;
        this.position.z += this.velocity.z * deltaTime;

        // Face movement direction
        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Animate legs (skittering)
        this.legPhase += deltaTime * this.speed * 2;
        for (let i = 0; i < this.legs.length; i++) {
            const leg = this.legs[i];
            const phase = this.legPhase + (i * Math.PI / 2);
            leg.group.rotation.x += Math.sin(phase) * 0.1;
            leg.lower.rotation.x = 0.5 + Math.sin(phase + Math.PI / 4) * 0.3;
        }

        // Bob up and down
        this.mesh.position.y = 0.6 + Math.sin(this.legPhase * 2) * 0.1;

        // Intensify eye glow as getting closer
        this.eyeLight.intensity = 0.3 + (1 - distanceToPlayer / 20) * 0.5;

        // Stop when within attack range
        if (distanceToPlayer <= this.attackRange) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
            this.velocity.set(0, 0, 0);
        }
    }

    updateTelegraph(deltaTime, toPlayer) {
        // Rear back, prepare attack
        const progress = this.stateTimer / this.stateTimes.TELEGRAPH;

        // Rear back animation
        this.mesh.position.y = 0.6 + progress * 0.4;
        this.mesh.rotation.x = -progress * 0.5;

        // Lock clock hands to 12 o'clock
        this.hourHand.rotation.z = THREE.MathUtils.lerp(this.hourHand.rotation.z, 0, progress);
        this.minuteHand.rotation.z = THREE.MathUtils.lerp(this.minuteHand.rotation.z, 0, progress);

        // Eye glows brighter
        this.eyeLight.intensity = 0.5 + progress * 1.0;
        this.eye.material.emissiveIntensity = progress;

        // Store lunge direction
        this.lungeDirection.copy(toPlayer);

        if (this.stateTimer >= this.stateTimes.TELEGRAPH) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
            this.hasHitPlayer = false; // Reset hit flag for new attack
        }
    }

    updateAttack(deltaTime) {
        // Lunge forward
        const progress = this.stateTimer / this.stateTimes.ATTACK;
        const lungeSpeed = this.lungeDistance / this.stateTimes.ATTACK;

        // Fast forward movement
        this.position.x += this.lungeDirection.x * lungeSpeed * deltaTime;
        this.position.z += this.lungeDirection.z * lungeSpeed * deltaTime;

        // Lunge animation - lean forward
        this.mesh.rotation.x = 0.5 - progress * 0.3;
        this.mesh.position.y = 1.0 - progress * 0.6;

        // Leg slash animation
        for (let i = 0; i < this.legs.length; i++) {
            this.legs[i].group.rotation.x = progress * 1.0;
        }

        if (this.stateTimer >= this.stateTimes.ATTACK) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateRecover(deltaTime) {
        // Recovery - vulnerable
        const progress = this.stateTimer / this.stateTimes.RECOVER;

        // Return to normal position
        this.mesh.rotation.x = THREE.MathUtils.lerp(this.mesh.rotation.x, 0, progress);
        this.mesh.position.y = THREE.MathUtils.lerp(this.mesh.position.y, 0.6, progress);

        // Clock hands spin randomly
        this.hourHand.rotation.z = Math.sin(this.stateTimer * 10) * Math.PI;
        this.minuteHand.rotation.z = Math.cos(this.stateTimer * 12) * Math.PI;

        // Return legs to normal
        for (let i = 0; i < this.legs.length; i++) {
            this.legs[i].group.rotation.x *= 0.9;
        }

        // Eye dims
        this.eyeLight.intensity = 0.3;

        if (this.stateTimer >= this.stateTimes.RECOVER) {
            this.state = 'IDLE';
            this.stateTimer = 0;
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 0.8; // Death animation duration

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            // Shatter animation
            // Scale down and spin
            const scale = 1 - progress * 0.5;
            this.mesh.scale.set(scale, scale, scale);
            this.mesh.rotation.y += deltaTime * 10;
            this.mesh.rotation.x += deltaTime * 5;

            // Rise up then fall
            if (progress < 0.3) {
                this.mesh.position.y += deltaTime * 3;
            } else {
                this.mesh.position.y -= deltaTime * 5;
            }

            // Flash and fade
            this.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 1 - progress;
                }
            });

            // Increase eye glow then fade
            this.eyeLight.intensity = (1 - progress) * 3;
        } else {
            // Death complete
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        // Simple scale pulse instead of material changes to avoid rendering issues
        if (this.mesh) {
            this.mesh.scale.setScalar(1.3);
        }
    }

    restoreMaterials() {
        // Restore normal scale
        if (this.mesh) {
            this.mesh.scale.setScalar(1.0);
        }
    }

    // Check if this enemy's attack hits the player
    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if (this.state !== 'ATTACK') return false;
        if (this.hasHitPlayer) return false; // Only hit once per attack

        const dist = Vec3.distance(this.position, playerPosition);
        if (dist < (playerRadius + 0.8)) {
            this.hasHitPlayer = true; // Mark as hit
            return true;
        }
        return false;
    }

    // Reset hit flag when entering new attack
    resetAttackHit() {
        this.hasHitPlayer = false;
    }

    // Check if in vulnerable recovery state
    isVulnerable() {
        return this.state === 'RECOVER';
    }
}

// ‚îÄ‚îÄ‚îÄ TOCK ENEMY CLASS (Fast Flanker) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Tock extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Tock';
        this.healthBarHeight = 2.0;

        // V2: Apply difficulty modifiers
        const baseDamage = 6; // Fast but very weak
        const baseSpeed = 8; // Still fast but not insane
        const baseHealth = 40; // Same as Tick for consistent hit-to-kill scaling
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 200;

        // State timings - V2: telegraph affected by difficulty
        const baseTelegraph = 0.4;
        this.stateTimes = {
            SPAWN: 0.8,
            CIRCLE: 2.5,
            BLINK: 0.1,
            TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            ATTACK: 0.5,
            RETREAT: 0.3
        };

        // Orbit properties
        this.orbitAngle = Math.random() * Math.PI * 2;
        this.orbitRadius = 8;
        this.orbitDirection = Math.random() > 0.5 ? 1 : -1;

        // Attack properties
        this.dashTarget = new THREE.Vector3();
        this.hasHitPlayer = false;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x6b5344,
            metalness: 0.7,
            roughness: 0.3
        });

        const clockMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90b8,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.4,
            transparent: true,
            opacity: 0.8
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });

        // Two clock faces connected (figure-8 shape)
        // First clock face
        const face1Geometry = new THREE.CylinderGeometry(0.4, 0.4, 0.15, 16);
        const face1 = new THREE.Mesh(face1Geometry, clockMaterial);
        face1.position.set(0, 0.4, 0);
        face1.rotation.x = Math.PI / 2;
        this.mesh.add(face1);
        this.face1 = face1;

        // Second clock face
        const face2 = new THREE.Mesh(face1Geometry, clockMaterial);
        face2.position.set(0, -0.4, 0);
        face2.rotation.x = Math.PI / 2;
        this.mesh.add(face2);
        this.face2 = face2;

        // Connecting spine
        const spineGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.8, 8);
        const spine = new THREE.Mesh(spineGeometry, bodyMaterial);
        spine.rotation.x = Math.PI / 2;
        this.mesh.add(spine);

        // Eyes on each face
        const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0xffcc00,
            emissive: 0xffcc00
        });

        const eye1 = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        eye1.position.set(0, 0.4, 0.15);
        this.mesh.add(eye1);
        this.eye1 = eye1;

        const eye2 = new THREE.Mesh(eyeGeometry, eyeMaterial.clone());
        eye2.position.set(0, -0.4, 0.15);
        this.mesh.add(eye2);
        this.eye2 = eye2;

        // Pendulum beneath
        const pendulumRodGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.6, 8);
        const pendulumRod = new THREE.Mesh(pendulumRodGeometry, goldMaterial);
        pendulumRod.position.set(0, -0.9, 0);
        this.mesh.add(pendulumRod);
        this.pendulumRod = pendulumRod;

        const pendulumWeightGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const pendulumWeight = new THREE.Mesh(pendulumWeightGeometry, goldMaterial);
        pendulumWeight.position.set(0, -1.2, 0);
        this.mesh.add(pendulumWeight);
        this.pendulumWeight = pendulumWeight;

        // Clock hands on faces
        const handGeometry = new THREE.BoxGeometry(0.02, 0.25, 0.02);
        this.hands = [];
        for (let i = 0; i < 4; i++) {
            const hand = new THREE.Mesh(handGeometry, goldMaterial);
            hand.position.y = i < 2 ? 0.4 : -0.4;
            hand.position.z = 0.08;
            this.mesh.add(hand);
            this.hands.push(hand);
        }

        // Point light
        const light = new THREE.PointLight(0xffcc00, 0.4, 3);
        light.position.set(0, 0, 0.2);
        this.mesh.add(light);
        this.light = light;

        // Position mesh
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 1.2;
        this.scene.add(this.mesh);

        // Start invisible for spawn
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate pendulum
        this.pendulumRod.rotation.z = Math.sin(this.stateTimer * 4) * 0.3;
        this.pendulumWeight.position.x = Math.sin(this.stateTimer * 4) * 0.15;

        // Animate hands
        for (let i = 0; i < this.hands.length; i++) {
            this.hands[i].rotation.z = this.stateTimer * (i + 2);
        }

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'CIRCLE':
                this.updateCircle(deltaTime, playerPosition);
                break;
            case 'TELEGRAPH':
                this.updateTelegraph(deltaTime, playerPosition);
                break;
            case 'ATTACK':
                this.updateAttack(deltaTime, playerPosition);
                break;
            case 'RETREAT':
                this.updateRetreat(deltaTime, playerPosition);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        this.mesh.scale.setScalar(Math.min(1, progress * 1.5));

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'CIRCLE';
            this.stateTimer = 0;
        }
    }

    updateCircle(deltaTime, playerPosition) {
        // Orbit around player
        this.orbitAngle += this.orbitDirection * this.speed * 0.1 * deltaTime;

        this.position.x = playerPosition.x + Math.cos(this.orbitAngle) * this.orbitRadius;
        this.position.z = playerPosition.z + Math.sin(this.orbitAngle) * this.orbitRadius;

        // Face player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Transition to attack
        if (this.stateTimer >= this.stateTimes.CIRCLE) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
        }
    }

    updateTelegraph(deltaTime, playerPosition) {
        const progress = this.stateTimer / this.stateTimes.TELEGRAPH;

        // Lock hands
        for (let i = 0; i < this.hands.length; i++) {
            this.hands[i].rotation.z = Math.PI;
        }

        // Eyes glow brighter
        this.light.intensity = 0.4 + progress * 1.0;

        // Store dash target
        this.dashTarget.copy(playerPosition);
        this.hasHitPlayer = false;

        if (this.stateTimer >= this.stateTimes.TELEGRAPH) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
            this.hasHitPlayer = false; // Reset hit flag for new attack
        }
    }

    updateAttack(deltaTime, playerPosition) {
        // Dash through player position
        const toTarget = new THREE.Vector3(
            this.dashTarget.x - this.position.x,
            0,
            this.dashTarget.z - this.position.z
        );

        if (toTarget.length() > 0.5) {
            toTarget.normalize();
            this.position.x += toTarget.x * this.speed * 3 * deltaTime;
            this.position.z += toTarget.z * this.speed * 3 * deltaTime;
        }

        if (this.stateTimer >= this.stateTimes.ATTACK) {
            this.state = 'RETREAT';
            this.stateTimer = 0;
        }
    }

    updateRetreat(deltaTime, playerPosition) {
        // Continue moving away
        const fromPlayer = new THREE.Vector3(
            this.position.x - playerPosition.x,
            0,
            this.position.z - playerPosition.z
        ).normalize();

        this.position.x += fromPlayer.x * this.speed * deltaTime;
        this.position.z += fromPlayer.z * this.speed * deltaTime;

        if (this.stateTimer >= this.stateTimes.RETREAT) {
            this.state = 'CIRCLE';
            this.stateTimer = 0;
            this.orbitAngle = Math.atan2(
                this.position.z - playerPosition.z,
                this.position.x - playerPosition.x
            );
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 0.6;

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            this.mesh.scale.setScalar(1 - progress);
            this.mesh.rotation.y += deltaTime * 15;
            this.mesh.position.y = 1.2 + progress * 2;
            this.light.intensity = (1 - progress) * 3;
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.3);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if (this.state !== 'ATTACK' || this.hasHitPlayer) return false;

        const dist = Vec3.distance(this.position, playerPosition);
        if (dist < (playerRadius + 0.6)) {
            this.hasHitPlayer = true;
            return true;
        }
        return false;
    }

    isVulnerable() {
        return this.state === 'RETREAT';
    }
}

// ‚îÄ‚îÄ‚îÄ GRANDFATHER ENEMY CLASS (Heavy Tank) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Grandfather extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Grandfather';
        this.healthBarHeight = 4.5;

        // V2: Apply difficulty modifiers
        const baseDamage = 35;
        const baseSpeed = 3;
        const baseHealth = 150; // Mini-boss - ~6 hits on Normal
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 1000;

        // State timings - V2: telegraph affected by difficulty
        const baseSweepTel = 1.0;
        const baseSlamTel = 1.2;
        this.stateTimes = {
            SPAWN: 2.0,
            APPROACH: 0,
            SWEEP_TELEGRAPH: getDifficultyValue(baseSweepTel, 'telegraphTime'),
            SWEEP_ATTACK: 0.8,
            SLAM_TELEGRAPH: getDifficultyValue(baseSlamTel, 'telegraphTime'),
            SLAM_ATTACK: 0.6,
            RECOVER: 1.5
        };

        // Attack properties
        this.attackType = 'sweep';
        this.hasHitPlayer = false;
        this.armor = 50; // First 50 damage reduced

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const woodMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d2817,
            roughness: 0.9,
            metalness: 0.1
        });

        const brassMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b7355,
            metalness: 0.8,
            roughness: 0.3
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });

        const glassMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a90b8,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.3,
            transparent: true,
            opacity: 0.6
        });

        // Main body (grandfather clock shape)
        const bodyGeometry = new THREE.BoxGeometry(1.5, 4, 0.8);
        const body = new THREE.Mesh(bodyGeometry, woodMaterial);
        body.position.y = 2;
        body.castShadow = true;
        this.mesh.add(body);
        this.body = body;

        // Clock face (top section)
        const faceGeometry = new THREE.CylinderGeometry(0.6, 0.6, 0.2, 24);
        const face = new THREE.Mesh(faceGeometry, glassMaterial);
        face.position.set(0, 3.5, 0.5);
        face.rotation.x = Math.PI / 2;
        this.mesh.add(face);
        this.face = face;

        // Clock face ring
        const ringGeometry = new THREE.TorusGeometry(0.6, 0.06, 8, 24);
        const ring = new THREE.Mesh(ringGeometry, goldMaterial);
        ring.position.set(0, 3.5, 0.55);
        this.mesh.add(ring);

        // Clock hands
        const hourHandGeometry = new THREE.BoxGeometry(0.06, 0.35, 0.03);
        const hourHand = new THREE.Mesh(hourHandGeometry, goldMaterial);
        hourHand.position.set(0, 3.67, 0.6);
        this.mesh.add(hourHand);
        this.hourHand = hourHand;

        const minuteHandGeometry = new THREE.BoxGeometry(0.04, 0.5, 0.03);
        const minuteHand = new THREE.Mesh(minuteHandGeometry, goldMaterial);
        minuteHand.position.set(0, 3.75, 0.6);
        this.mesh.add(minuteHand);
        this.minuteHand = minuteHand;

        // Pendulum cabinet (glass front)
        const cabinetGeometry = new THREE.BoxGeometry(1.2, 1.5, 0.1);
        const cabinet = new THREE.Mesh(cabinetGeometry, glassMaterial);
        cabinet.position.set(0, 1.5, 0.45);
        this.mesh.add(cabinet);

        // Pendulum
        const pendulumGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1.2, 8);
        const pendulum = new THREE.Mesh(pendulumGeometry, brassMaterial);
        pendulum.position.set(0, 1.0, 0.3);
        this.mesh.add(pendulum);
        this.pendulum = pendulum;

        const pendulumDiscGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 16);
        const pendulumDisc = new THREE.Mesh(pendulumDiscGeometry, goldMaterial);
        pendulumDisc.position.set(0, 0.4, 0.3);
        pendulumDisc.rotation.x = Math.PI / 2;
        this.mesh.add(pendulumDisc);
        this.pendulumDisc = pendulumDisc;

        // Legs
        const legGeometry = new THREE.BoxGeometry(0.4, 1, 0.4);
        const leftLeg = new THREE.Mesh(legGeometry, brassMaterial);
        leftLeg.position.set(-0.5, -0.5, 0);
        leftLeg.castShadow = true;
        this.mesh.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, brassMaterial);
        rightLeg.position.set(0.5, -0.5, 0);
        rightLeg.castShadow = true;
        this.mesh.add(rightLeg);

        // Arms (clock hands as weapons)
        const armGeometry = new THREE.BoxGeometry(0.15, 2, 0.08);
        const leftArm = new THREE.Mesh(armGeometry, goldMaterial);
        leftArm.position.set(-1.2, 2.5, 0);
        leftArm.rotation.z = 0.3;
        this.mesh.add(leftArm);
        this.leftArm = leftArm;

        const rightArm = new THREE.Mesh(armGeometry, goldMaterial);
        rightArm.position.set(1.2, 2.5, 0);
        rightArm.rotation.z = -0.3;
        this.mesh.add(rightArm);
        this.rightArm = rightArm;

        // Eye glow
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444,
            transparent: true,
            opacity: 0.8
        });
        const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.set(0, 3.5, 0.65);
        this.mesh.add(eye);
        this.eye = eye;

        // Point lights
        const faceLight = new THREE.PointLight(0xff4444, 0.5, 4);
        faceLight.position.set(0, 3.5, 0.8);
        this.mesh.add(faceLight);
        this.faceLight = faceLight;

        // Position mesh
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 0;
        this.scene.add(this.mesh);

        // Start at small scale
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate pendulum
        this.pendulum.rotation.z = Math.sin(this.stateTimer * 2) * 0.4;
        this.pendulumDisc.position.x = Math.sin(this.stateTimer * 2) * 0.2;

        // Animate clock hands
        this.hourHand.rotation.z = this.stateTimer * 0.1;
        this.minuteHand.rotation.z = this.stateTimer * 1.2;

        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'APPROACH':
                this.updateApproach(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'SWEEP_TELEGRAPH':
                this.updateSweepTelegraph(deltaTime, toPlayer);
                break;
            case 'SWEEP_ATTACK':
                this.updateSweepAttack(deltaTime);
                break;
            case 'SLAM_TELEGRAPH':
                this.updateSlamTelegraph(deltaTime);
                break;
            case 'SLAM_ATTACK':
                this.updateSlamAttack(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        this.mesh.scale.setScalar(Math.min(1, progress));

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
        }
    }

    updateApproach(deltaTime, toPlayer, distanceToPlayer) {
        if (distanceToPlayer > 6) {
            this.position.x += toPlayer.x * this.speed * deltaTime;
            this.position.z += toPlayer.z * this.speed * deltaTime;
        }

        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        if (distanceToPlayer <= 6) {
            // Choose attack type
            this.attackType = Math.random() > 0.5 ? 'sweep' : 'slam';
            this.state = this.attackType === 'sweep' ? 'SWEEP_TELEGRAPH' : 'SLAM_TELEGRAPH';
            this.stateTimer = 0;
            this.hasHitPlayer = false;
        }
    }

    updateSweepTelegraph(deltaTime, toPlayer) {
        const progress = this.stateTimer / this.stateTimes.SWEEP_TELEGRAPH;

        // Raise arm
        this.rightArm.rotation.z = -0.3 - progress * 1.5;
        this.rightArm.position.y = 2.5 + progress * 0.5;

        // Glow
        this.faceLight.intensity = 0.5 + progress * 1.5;

        if (this.stateTimer >= this.stateTimes.SWEEP_TELEGRAPH) {
            this.state = 'SWEEP_ATTACK';
            this.stateTimer = 0;
        }
    }

    updateSweepAttack(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SWEEP_ATTACK;

        // Sweep arm across
        this.rightArm.rotation.z = -1.8 + progress * 3.6;

        if (this.stateTimer >= this.stateTimes.SWEEP_ATTACK) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateSlamTelegraph(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SLAM_TELEGRAPH;

        // Raise both arms
        this.leftArm.rotation.z = 0.3 + progress * 2;
        this.rightArm.rotation.z = -0.3 - progress * 2;
        this.leftArm.position.y = 2.5 + progress;
        this.rightArm.position.y = 2.5 + progress;

        // Face glows red
        this.faceLight.intensity = 0.5 + progress * 2;

        if (this.stateTimer >= this.stateTimes.SLAM_TELEGRAPH) {
            this.state = 'SLAM_ATTACK';
            this.stateTimer = 0;
        }
    }

    updateSlamAttack(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SLAM_ATTACK;

        // Slam arms down
        this.leftArm.rotation.z = 2.3 - progress * 2;
        this.rightArm.rotation.z = -2.3 + progress * 2;
        this.leftArm.position.y = 3.5 - progress * 2;
        this.rightArm.position.y = 3.5 - progress * 2;

        if (this.stateTimer >= this.stateTimes.SLAM_ATTACK) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateRecover(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.RECOVER;

        // Return arms to normal
        this.leftArm.rotation.z = THREE.MathUtils.lerp(this.leftArm.rotation.z, 0.3, progress);
        this.rightArm.rotation.z = THREE.MathUtils.lerp(this.rightArm.rotation.z, -0.3, progress);
        this.leftArm.position.y = THREE.MathUtils.lerp(this.leftArm.position.y, 2.5, progress);
        this.rightArm.position.y = THREE.MathUtils.lerp(this.rightArm.position.y, 2.5, progress);

        this.faceLight.intensity = 0.5;

        if (this.stateTimer >= this.stateTimes.RECOVER) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 1.5;

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            // Stagger and fall
            this.mesh.rotation.x = progress * 0.5;
            this.mesh.position.y = -progress * 2;
            this.faceLight.intensity = (1 - progress) * 5;

            this.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.transparent = true;
                    child.material.opacity = 1 - progress;
                }
            });
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    takeDamage(amount, hitFrame) {
        if (hitFrame === this.lastHitFrame) return false;
        this.lastHitFrame = hitFrame;

        // Armor reduces damage
        if (this.armor > 0) {
            const absorbed = Math.min(this.armor, amount * 0.5);
            this.armor -= absorbed;
            amount -= absorbed;
        }

        this.health -= amount;
        this.isFlashing = true;
        this.flashTimer = 0.08;

        if (this.health <= 0) {
            this.die();
            return 'killed';
        }
        return true;
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.15);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if ((this.state !== 'SWEEP_ATTACK' && this.state !== 'SLAM_ATTACK') || this.hasHitPlayer) {
            return false;
        }

        const dist = Vec3.distance(this.position, playerPosition);
        const range = this.state === 'SLAM_ATTACK' ? 6 : 8;

        if (dist < range) {
            this.hasHitPlayer = true;
            return true;
        }
        return false;
    }

    isVulnerable() {
        return this.state === 'RECOVER';
    }
}

// ‚îÄ‚îÄ‚îÄ PENDULUM ENEMY CLASS (Ranged Support) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Pendulum extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Pendulum';
        this.healthBarHeight = 3.0;

        // V2: Apply difficulty modifiers
        const baseDamage = 20;
        const baseSpeed = 5;
        const baseHealth = 40; // Same as basic enemies
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 300;

        // State timings - V2: telegraph affected by difficulty
        const baseTelegraph = 0.6;
        this.stateTimes = {
            SPAWN: 1.0,
            HOVER: 2.0,
            SHOOT_TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            SHOOT: 0.1,
            REPOSITION: 0.5
        };

        // Projectiles
        this.projectiles = [];

        // Preferred distance
        this.preferredDistance = 15;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x6688aa,
            transparent: true,
            opacity: 0.7,
            metalness: 0.3,
            roughness: 0.5
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.3,
            metalness: 0.9,
            roughness: 0.2
        });

        // Inverted pendulum shape
        const topGeometry = new THREE.ConeGeometry(0.5, 0.8, 6);
        const top = new THREE.Mesh(topGeometry, bodyMaterial);
        top.position.y = 0.4;
        top.rotation.x = Math.PI;
        this.mesh.add(top);
        this.top = top;

        // Clock face head
        const headGeometry = new THREE.CylinderGeometry(0.4, 0.4, 0.15, 16);
        const head = new THREE.Mesh(headGeometry, goldMaterial);
        head.position.y = 0.9;
        head.rotation.x = Math.PI / 2;
        this.mesh.add(head);
        this.head = head;

        // Eye
        const eyeGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0x44ff44
        });
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.y = 0.9;
        eye.position.z = 0.1;
        this.mesh.add(eye);
        this.eye = eye;

        // Pendulum rod and weight below
        const rodGeometry = new THREE.CylinderGeometry(0.03, 0.03, 1, 8);
        const rod = new THREE.Mesh(rodGeometry, goldMaterial);
        rod.position.y = -0.5;
        this.mesh.add(rod);
        this.rod = rod;

        const weightGeometry = new THREE.SphereGeometry(0.15, 8, 8);
        const weight = new THREE.Mesh(weightGeometry, goldMaterial);
        weight.position.y = -1;
        this.mesh.add(weight);
        this.weight = weight;

        // Point light
        const light = new THREE.PointLight(0x44ff44, 0.5, 4);
        light.position.y = 0.9;
        this.mesh.add(light);
        this.light = light;

        this.mesh.position.copy(this.position);
        this.mesh.position.y = 3;
        this.scene.add(this.mesh);

        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate pendulum swing
        const swingAngle = Math.sin(this.stateTimer * 3) * 0.5;
        this.rod.rotation.z = swingAngle;
        this.weight.position.x = Math.sin(swingAngle) * 0.5;
        this.weight.position.y = -1 + Math.cos(swingAngle) * 0.1;

        // Face player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const dist = toPlayer.length();
        toPlayer.normalize();

        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Update projectiles
        this.updateProjectiles(deltaTime);

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'HOVER':
                this.updateHover(deltaTime, toPlayer, dist, playerPosition);
                break;
            case 'SHOOT_TELEGRAPH':
                this.updateShootTelegraph(deltaTime, toPlayer);
                break;
            case 'SHOOT':
                this.updateShoot(deltaTime, playerPosition);
                break;
            case 'REPOSITION':
                this.updateReposition(deltaTime, playerPosition);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        this.mesh.scale.setScalar(Math.min(1, progress * 1.5));

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'HOVER';
            this.stateTimer = 0;
        }
    }

    updateHover(deltaTime, toPlayer, dist, playerPosition) {
        // Maintain preferred distance
        if (dist < this.preferredDistance - 2) {
            this.position.x -= toPlayer.x * this.speed * deltaTime;
            this.position.z -= toPlayer.z * this.speed * deltaTime;
        } else if (dist > this.preferredDistance + 2) {
            this.position.x += toPlayer.x * this.speed * deltaTime;
            this.position.z += toPlayer.z * this.speed * deltaTime;
        }

        // Bob up and down
        this.mesh.position.y = 3 + Math.sin(this.stateTimer * 2) * 0.3;

        if (this.stateTimer >= this.stateTimes.HOVER) {
            this.state = 'SHOOT_TELEGRAPH';
            this.stateTimer = 0;
        }
    }

    updateShootTelegraph(deltaTime, toPlayer) {
        const progress = this.stateTimer / this.stateTimes.SHOOT_TELEGRAPH;

        // Eye glows brighter
        this.light.intensity = 0.5 + progress * 2;

        // Pendulum freezes
        this.rod.rotation.z = 0;
        this.weight.position.x = 0;

        if (this.stateTimer >= this.stateTimes.SHOOT_TELEGRAPH) {
            this.state = 'SHOOT';
            this.stateTimer = 0;
        }
    }

    updateShoot(deltaTime, playerPosition) {
        // Fire projectile
        if (this.stateTimer === 0 || this.stateTimer < deltaTime * 2) {
            this.fireProjectile(playerPosition);
        }

        if (this.stateTimer >= this.stateTimes.SHOOT) {
            this.state = 'HOVER';
            this.stateTimer = 0;
            this.light.intensity = 0.5;
        }
    }

    updateReposition(deltaTime, playerPosition) {
        // Quick move to new position
        if (this.stateTimer >= this.stateTimes.REPOSITION) {
            this.state = 'HOVER';
            this.stateTimer = 0;
        }
    }

    fireProjectile(playerPosition) {
        const direction = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        ).normalize();

        // Create projectile mesh
        const projGeometry = new THREE.SphereGeometry(0.3, 8, 8);
        const projMaterial = new THREE.MeshBasicMaterial({
            color: 0xd4af37,
            transparent: true,
            opacity: 0.8
        });
        const projMesh = new THREE.Mesh(projGeometry, projMaterial);
        projMesh.position.set(this.position.x, 2, this.position.z);

        const projLight = new THREE.PointLight(0xd4af37, 0.5, 3);
        projMesh.add(projLight);

        this.scene.add(projMesh);

        this.projectiles.push({
            mesh: projMesh,
            direction: direction,
            speed: 20,
            lifetime: 3
        });
    }

    updateProjectiles(deltaTime) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.lifetime -= deltaTime;

            proj.mesh.position.x += proj.direction.x * proj.speed * deltaTime;
            proj.mesh.position.z += proj.direction.z * proj.speed * deltaTime;

            if (proj.lifetime <= 0) {
                this.scene.remove(proj.mesh);
                this.projectiles.splice(i, 1);
            }
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 0.8;

        // Hide health bar on death
        this.hideHealthBar();

        // Clean up projectiles
        for (const proj of this.projectiles) {
            this.scene.remove(proj.mesh);
        }
        this.projectiles = [];

        if (progress < 1) {
            this.mesh.scale.setScalar(1 - progress);
            this.mesh.rotation.y += deltaTime * 10;
            this.mesh.position.y = 3 - progress * 3;
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.3);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        // Check projectiles
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            const dist = Vec3.distance(proj.mesh.position, playerPosition);

            if (dist < playerRadius + 0.3) {
                this.scene.remove(proj.mesh);
                this.projectiles.splice(i, 1);
                return true;
            }
        }
        return false;
    }

    isVulnerable() {
        return false; // Ranged enemies are always vulnerable
    }

    destroy() {
        for (const proj of this.projectiles) {
            this.scene.remove(proj.mesh);
        }
        this.projectiles = [];
        super.destroy();
    }
}

// ‚îÄ‚îÄ‚îÄ SECOND HAND CLASS (Elite Assassin) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class SecondHand extends Enemy {
    constructor(scene, position) {
        super(scene, position);

        // Enemy name for health bar
        this.enemyName = 'Second Hand';
        this.healthBarHeight = 2.5;

        // V2: Apply difficulty modifiers
        const baseDamage = 15;
        const baseSpeed = 8;
        const baseHealth = 60; // Elite enemy - slightly tougher than basics
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.comboDamage = [15, 15, 25].map(d => getDifficultyValue(d, 'enemyDamage')); // 3-hit combo
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 500;

        // State timings - V2: telegraph affected by difficulty
        const baseTelegraph = 0.3;
        this.stateTimes = {
            SPAWN: 1.2,
            STALK: 0, // indefinite until close
            FREEZE: 0, // indefinite while looked at
            TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            ATTACK_1: 0.15,
            ATTACK_2: 0.15,
            ATTACK_3: 0.25,
            RECOVER: 0.8
        };

        // Combo state
        this.comboStep = 0;
        this.hasHitPlayer = false;

        // Stalking behavior
        this.stalkDistance = 4; // Attack when this close
        this.isBeingWatched = false;
        this.freezeGlitchTimer = 0;

        // Rewind ability (at 30% HP)
        this.hasUsedRewind = false;
        this.positionHistory = [];
        this.historyInterval = 0.1;
        this.historyTimer = 0;
        this.historyDuration = 3; // seconds of history to keep
        this.isRewinding = false;
        this.rewindTimer = 0;
        this.rewindDuration = 0.5;
        this.rewindTarget = null;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials - dark with clock hand aesthetics
        const handMaterial = new THREE.MeshStandardMaterial({
            color: 0x222233,
            metalness: 0.8,
            roughness: 0.3
        });

        const glowMaterial = new THREE.MeshStandardMaterial({
            color: 0x8844aa,
            emissive: 0x8844aa,
            emissiveIntensity: 0.5,
            metalness: 0.5,
            roughness: 0.4
        });

        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444
        });

        // Body made of overlapping clock hands
        // Central torso - vertical hand
        const torsoGeometry = new THREE.BoxGeometry(0.15, 1.8, 0.08);
        const torso = new THREE.Mesh(torsoGeometry, handMaterial);
        torso.position.y = 1.1;
        this.mesh.add(torso);

        // Overlapping diagonal hands for body texture
        for (let i = 0; i < 4; i++) {
            const diagGeometry = new THREE.BoxGeometry(0.1, 1.2, 0.05);
            const diag = new THREE.Mesh(diagGeometry, handMaterial);
            diag.position.y = 1.0;
            diag.rotation.z = (i - 1.5) * 0.3;
            diag.position.x = (i - 1.5) * 0.08;
            this.mesh.add(diag);
        }

        // Head - pointed like hour hand tip
        const headGeometry = new THREE.ConeGeometry(0.2, 0.5, 4);
        const head = new THREE.Mesh(headGeometry, handMaterial);
        head.position.y = 2.2;
        this.mesh.add(head);
        this.head = head;

        // Single red eye
        const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.y = 2.0;
        eye.position.z = 0.15;
        this.mesh.add(eye);
        this.eye = eye;

        // Arms - long clock hands
        const armGeometry = new THREE.BoxGeometry(0.8, 0.08, 0.04);
        const leftArm = new THREE.Mesh(armGeometry, handMaterial);
        leftArm.position.set(-0.5, 1.5, 0);
        leftArm.rotation.z = 0.3;
        this.mesh.add(leftArm);
        this.leftArm = leftArm;

        const rightArm = new THREE.Mesh(armGeometry, handMaterial);
        rightArm.position.set(0.5, 1.5, 0);
        rightArm.rotation.z = -0.3;
        this.mesh.add(rightArm);
        this.rightArm = rightArm;

        // Clawed fingers (multiple thin hands at arm ends)
        for (let side = -1; side <= 1; side += 2) {
            for (let i = 0; i < 3; i++) {
                const clawGeometry = new THREE.BoxGeometry(0.25, 0.03, 0.02);
                const claw = new THREE.Mesh(clawGeometry, glowMaterial);
                claw.position.set(side * 0.9, 1.5 + (i - 1) * 0.06, 0);
                claw.rotation.z = side * 0.5;
                this.mesh.add(claw);
            }
        }

        // Legs - thin hand shapes
        const legGeometry = new THREE.BoxGeometry(0.08, 1.0, 0.05);
        const leftLeg = new THREE.Mesh(legGeometry, handMaterial);
        leftLeg.position.set(-0.15, 0.5, 0);
        this.mesh.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, handMaterial);
        rightLeg.position.set(0.15, 0.5, 0);
        this.mesh.add(rightLeg);

        // Subtle glow
        const light = new THREE.PointLight(0x8844aa, 0.3, 3);
        light.position.y = 1.5;
        this.mesh.add(light);
        this.light = light;

        this.mesh.position.copy(this.position);
        this.scene.add(this.mesh);

        // Start small (spawn animation)
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition, playerRotation = 0) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        // Handle rewind animation
        if (this.isRewinding) {
            this.updateRewind(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Record position history for rewind
        this.historyTimer += deltaTime;
        if (this.historyTimer >= this.historyInterval) {
            this.historyTimer = 0;
            this.positionHistory.push({
                x: this.position.x,
                z: this.position.z,
                health: this.health
            });
            // Keep only last 3 seconds
            const maxHistory = Math.ceil(this.historyDuration / this.historyInterval);
            while (this.positionHistory.length > maxHistory) {
                this.positionHistory.shift();
            }
        }

        // Check if being watched (player facing this enemy)
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        // Calculate if player is looking at us
        const playerForward = new THREE.Vector3(
            Math.sin(playerRotation),
            0,
            Math.cos(playerRotation)
        );
        const toEnemy = new THREE.Vector3(-toPlayer.x, 0, -toPlayer.z);
        const dot = playerForward.dot(toEnemy);
        this.isBeingWatched = dot > 0.7 && distanceToPlayer < 20; // Within ~45 degree cone

        // Face player (always)
        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'STALK':
                this.updateStalk(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'FREEZE':
                this.updateFreeze(deltaTime, distanceToPlayer);
                break;
            case 'TELEGRAPH':
                this.updateTelegraph(deltaTime);
                break;
            case 'ATTACK_1':
            case 'ATTACK_2':
            case 'ATTACK_3':
                this.updateAttack(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.y = 0;
        this.mesh.position.z = this.position.z;

        // Update health bar position
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;

        // Glitchy spawn - flicker in
        const flicker = Math.sin(this.stateTimer * 30) > 0 ? 1 : 0.3;
        const scale = Math.min(1, progress * 1.5) * flicker;
        this.mesh.scale.setScalar(scale);

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.mesh.scale.setScalar(1);
            this.state = 'STALK';
            this.stateTimer = 0;
        }
    }

    updateStalk(deltaTime, toPlayer, distanceToPlayer) {
        // Check if player is watching
        if (this.isBeingWatched) {
            this.state = 'FREEZE';
            this.stateTimer = 0;
            return;
        }

        // Move silently towards player
        this.position.x += toPlayer.x * this.speed * deltaTime;
        this.position.z += toPlayer.z * this.speed * deltaTime;

        // Subtle gliding animation
        this.mesh.position.y = Math.sin(this.stateTimer * 5) * 0.05;

        // Attack when close enough
        if (distanceToPlayer <= this.stalkDistance) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
            this.comboStep = 0;
            this.hasHitPlayer = false;
        }
    }

    updateFreeze(deltaTime, distanceToPlayer) {
        // Glitch effect while frozen
        this.freezeGlitchTimer += deltaTime;
        if (this.freezeGlitchTimer > 0.1) {
            this.freezeGlitchTimer = 0;
            // Random small position jitter
            this.mesh.position.x = this.position.x + (Math.random() - 0.5) * 0.05;
            this.mesh.position.z = this.position.z + (Math.random() - 0.5) * 0.05;
        }

        // If player looks away, resume stalking
        if (!this.isBeingWatched) {
            this.state = 'STALK';
            this.stateTimer = 0;
        }

        // If player gets too close while we're frozen, attack anyway
        if (distanceToPlayer <= this.stalkDistance * 0.5) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
            this.comboStep = 0;
        }
    }

    updateTelegraph(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.TELEGRAPH;

        // Quick raise of arms
        this.leftArm.rotation.z = 0.3 + progress * 1.2;
        this.rightArm.rotation.z = -0.3 - progress * 1.2;

        // Eye glows brighter
        this.light.intensity = 0.3 + progress * 0.7;

        if (this.stateTimer >= this.stateTimes.TELEGRAPH) {
            this.state = 'ATTACK_1';
            this.stateTimer = 0;
            this.comboStep = 1;
            this.hasHitPlayer = false;
        }
    }

    updateAttack(deltaTime) {
        const attackTime = this.stateTimes[this.state];
        const progress = this.stateTimer / attackTime;

        // Animate based on combo step
        if (this.comboStep === 1 || this.comboStep === 2) {
            // Quick slash (alternate sides)
            const side = this.comboStep === 1 ? 1 : -1;
            this.leftArm.rotation.z = side > 0 ? 1.5 - progress * 2 : 0.3;
            this.rightArm.rotation.z = side < 0 ? -1.5 + progress * 2 : -0.3;
        } else if (this.comboStep === 3) {
            // Double overhead slam
            this.leftArm.rotation.z = 1.5 - progress * 3;
            this.rightArm.rotation.z = -1.5 + progress * 3;
        }

        if (this.stateTimer >= attackTime) {
            this.comboStep++;
            this.stateTimer = 0;
            this.hasHitPlayer = false;

            if (this.comboStep === 2) {
                this.state = 'ATTACK_2';
            } else if (this.comboStep === 3) {
                this.state = 'ATTACK_3';
            } else {
                this.state = 'RECOVER';
                this.comboStep = 0;
            }
        }
    }

    updateRecover(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.RECOVER;

        // Arms return to neutral
        this.leftArm.rotation.z = 0.3;
        this.rightArm.rotation.z = -0.3;
        this.light.intensity = 0.3;

        if (this.stateTimer >= this.stateTimes.RECOVER) {
            this.state = 'STALK';
            this.stateTimer = 0;
        }
    }

    updateRewind(deltaTime) {
        this.rewindTimer += deltaTime;
        const progress = this.rewindTimer / this.rewindDuration;

        if (progress >= 1 && this.rewindTarget) {
            // Complete rewind
            this.position.x = this.rewindTarget.x;
            this.position.z = this.rewindTarget.z;
            this.health = Math.min(this.maxHealth, this.rewindTarget.health + this.maxHealth * 0.3);
            this.mesh.position.x = this.position.x;
            this.mesh.position.z = this.position.z;
            this.mesh.scale.setScalar(1);
            this.isRewinding = false;
            this.state = 'STALK';
            this.stateTimer = 0;
            this.light.color.setHex(0x8844aa);
        } else {
            // Glitchy rewind animation
            const glitch = Math.sin(progress * 50) > 0 ? 1 : 0.5;
            this.mesh.scale.setScalar(glitch);

            // Interpolate position backwards
            if (this.rewindTarget) {
                this.mesh.position.x = this.position.x + (this.rewindTarget.x - this.position.x) * progress;
                this.mesh.position.z = this.position.z + (this.rewindTarget.z - this.position.z) * progress;
            }

            // Purple glow during rewind
            this.light.color.setHex(0xff44ff);
            this.light.intensity = 1 + Math.sin(progress * 20) * 0.5;
        }
    }

    takeDamage(damage, hitFrame) {
        if (this.lastHitFrame === hitFrame) return false;
        this.lastHitFrame = hitFrame;

        this.health -= damage;
        this.flashTimer = 0.1;
        this.applyFlash();

        // Check for rewind trigger (at 30% HP, once only)
        if (!this.hasUsedRewind && this.health <= this.maxHealth * 0.3 && this.health > 0) {
            this.triggerRewind();
            return true; // Still counts as a hit
        }

        if (this.health <= 0) {
            this.die();
            return 'killed';
        }

        return true;
    }

    triggerRewind() {
        this.hasUsedRewind = true;
        this.isRewinding = true;
        this.rewindTimer = 0;

        // Get position from 3 seconds ago (or earliest if less history)
        if (this.positionHistory.length > 0) {
            this.rewindTarget = this.positionHistory[0];
        } else {
            // No history, just heal in place
            this.rewindTarget = {
                x: this.position.x,
                z: this.position.z,
                health: this.health
            };
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 1.0;

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            // Glitchy disintegration
            const glitch = Math.random() > 0.3 ? 1 : 0;
            this.mesh.scale.setScalar((1 - progress) * glitch);
            this.mesh.rotation.y += deltaTime * 15;
            this.mesh.position.y = progress * -0.5;

            // Flicker light
            this.light.intensity = (1 - progress) * (Math.random() > 0.5 ? 1 : 0);
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.2);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        // Only hit during attack states
        if (!this.state.startsWith('ATTACK_')) return false;
        if (this.hasHitPlayer) return false;

        const dist = Vec3.distance(this.position, playerPosition);
        if (dist < 2.0) { // Attack range
            this.hasHitPlayer = true;
            this.damage = this.comboDamage[this.comboStep - 1] || 15;
            return true;
        }

        return false;
    }

    isVulnerable() {
        return this.state === 'RECOVER' || this.isRewinding;
    }
}

// ‚îÄ‚îÄ‚îÄ MINUTE MITE CLASS (Splitter Enemy) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class MinuteMite extends Enemy {
    constructor(scene, position, size = 1.0, game = null) {
        super(scene, position);
        this.game = game;
        this.size = size; // 1.0 = full, 0.5 = half (after split)

        // Enemy name for health bar
        this.enemyName = size >= 1.0 ? 'Minute Mite' : 'Mite Fragment';
        this.healthBarHeight = 1.2 * size;

        // V2: Apply difficulty modifiers - scales with size
        const baseDamage = Math.floor(10 * size);
        const baseSpeed = 6 + (1 - size) * 4; // Smaller = faster
        const baseHealth = Math.floor(30 * size); // Smaller = less HP
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = Math.floor(150 * size);

        // Can only split if full size
        this.canSplit = size >= 1.0;

        // State timings
        const baseTelegraph = 0.4;
        this.stateTimes = {
            SPAWN: 0.6 * size,
            APPROACH: 0,
            TELEGRAPH: getDifficultyValue(baseTelegraph, 'telegraphTime'),
            ATTACK: 0.25,
            RECOVER: 0.5
        };

        // Attack properties
        this.attackRange = 2.5;
        this.hasHitPlayer = false;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials - crystalline time shard look
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x88aacc,
            emissive: 0x4488aa,
            emissiveIntensity: 0.3,
            metalness: 0.6,
            roughness: 0.3,
            transparent: true,
            opacity: 0.85
        });

        const coreMaterial = new THREE.MeshStandardMaterial({
            color: 0xffdd44,
            emissive: 0xffaa00,
            emissiveIntensity: 0.8,
            metalness: 0.2,
            roughness: 0.2
        });

        // Main body - icosahedron (gem-like)
        const bodyGeometry = new THREE.IcosahedronGeometry(0.4 * this.size, 0);
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.castShadow = true;
        this.mesh.add(body);
        this.bodyMesh = body;

        // Inner core (glowing)
        const coreGeometry = new THREE.IcosahedronGeometry(0.2 * this.size, 0);
        const core = new THREE.Mesh(coreGeometry, coreMaterial);
        this.mesh.add(core);
        this.core = core;

        // Orbiting time fragments
        this.fragments = [];
        const fragmentCount = this.canSplit ? 3 : 1;
        const fragmentGeometry = new THREE.TetrahedronGeometry(0.1 * this.size, 0);
        for (let i = 0; i < fragmentCount; i++) {
            const fragment = new THREE.Mesh(fragmentGeometry, coreMaterial.clone());
            fragment.userData.orbitAngle = (i / fragmentCount) * Math.PI * 2;
            fragment.userData.orbitSpeed = 2 + Math.random();
            fragment.userData.orbitRadius = 0.5 * this.size;
            this.mesh.add(fragment);
            this.fragments.push(fragment);
        }

        // Point light
        const light = new THREE.PointLight(0x88ccff, 0.4 * this.size, 3);
        this.mesh.add(light);
        this.light = light;

        // Position mesh
        this.mesh.position.copy(this.position);
        this.mesh.position.y = 0.5 * this.size;
        this.scene.add(this.mesh);

        // Start small for spawn
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate core rotation
        this.core.rotation.x += deltaTime * 2;
        this.core.rotation.y += deltaTime * 3;

        // Animate orbiting fragments
        for (const fragment of this.fragments) {
            fragment.userData.orbitAngle += fragment.userData.orbitSpeed * deltaTime;
            const angle = fragment.userData.orbitAngle;
            const radius = fragment.userData.orbitRadius;
            fragment.position.x = Math.cos(angle) * radius;
            fragment.position.z = Math.sin(angle) * radius;
            fragment.position.y = Math.sin(angle * 2) * 0.1;
            fragment.rotation.x += deltaTime * 5;
            fragment.rotation.y += deltaTime * 3;
        }

        // Direction to player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'APPROACH':
                this.updateApproach(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'TELEGRAPH':
                this.updateTelegraph(deltaTime, toPlayer);
                break;
            case 'ATTACK':
                this.updateAttack(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Update health bar
        this.updateHealthBar();
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        const scale = Math.min(1, progress * 1.5);
        this.mesh.scale.set(scale, scale, scale);

        // Spin during spawn
        this.mesh.rotation.y += deltaTime * 10;

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
            this.mesh.scale.set(1, 1, 1);
        }
    }

    updateApproach(deltaTime, toPlayer, distanceToPlayer) {
        // Move toward player
        this.position.x += toPlayer.x * this.speed * deltaTime;
        this.position.z += toPlayer.z * this.speed * deltaTime;

        // Hover bobbing
        this.mesh.position.y = 0.5 * this.size + Math.sin(this.stateTimer * 4) * 0.1;

        // Face player
        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Attack when close
        if (distanceToPlayer <= this.attackRange) {
            this.state = 'TELEGRAPH';
            this.stateTimer = 0;
            this.hasHitPlayer = false;
        }
    }

    updateTelegraph(deltaTime, toPlayer) {
        const progress = this.stateTimer / this.stateTimes.TELEGRAPH;

        // Pulse and glow brighter
        const pulse = 1 + Math.sin(progress * Math.PI * 4) * 0.2;
        this.mesh.scale.set(pulse, pulse, pulse);
        this.light.intensity = 0.4 * this.size + progress * 0.6;

        // Store attack direction
        this.attackDirection = toPlayer.clone();

        if (this.stateTimer >= this.stateTimes.TELEGRAPH) {
            this.state = 'ATTACK';
            this.stateTimer = 0;
        }
    }

    updateAttack(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.ATTACK;

        // Lunge forward
        const lungeSpeed = 15 * this.size;
        this.position.x += this.attackDirection.x * lungeSpeed * deltaTime;
        this.position.z += this.attackDirection.z * lungeSpeed * deltaTime;

        // Spin during attack
        this.mesh.rotation.y += deltaTime * 20;

        if (this.stateTimer >= this.stateTimes.ATTACK) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateRecover(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.RECOVER;

        // Slow down rotation
        this.mesh.rotation.y += deltaTime * (10 - progress * 8);
        this.light.intensity = THREE.MathUtils.lerp(1.0, 0.4, progress) * this.size;

        if (this.stateTimer >= this.stateTimes.RECOVER) {
            this.state = 'APPROACH';
            this.stateTimer = 0;
        }
    }

    die() {
        // Override die to spawn smaller mites if we can split
        if (this.canSplit && this.game) {
            // Spawn 2 smaller mites
            for (let i = 0; i < 2; i++) {
                const angle = (i / 2) * Math.PI * 2 + Math.random() * 0.5;
                const offset = 1.0;
                const spawnPos = new THREE.Vector3(
                    this.position.x + Math.cos(angle) * offset,
                    0,
                    this.position.z + Math.sin(angle) * offset
                );
                // Create smaller mite (half size)
                const smallMite = new MinuteMite(this.scene, spawnPos, 0.5, this.game);
                this.game.enemies.push(smallMite);
            }
        }

        // Normal death
        this.isAlive = false;
        this.isDying = true;
        this.deathTimer = 0;
        this.state = 'DEAD';
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 0.5;

        // Hide health bar
        this.hideHealthBar();

        if (progress < 1) {
            // Shatter effect
            this.mesh.scale.setScalar((1 - progress) * 1.5);
            this.mesh.rotation.y += deltaTime * 20;
            this.mesh.rotation.x += deltaTime * 15;

            // Fragments fly outward
            for (const fragment of this.fragments) {
                fragment.userData.orbitRadius += deltaTime * 5;
            }

            this.light.intensity = (1 - progress) * 2;
        } else {
            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.bodyMesh) {
            this.bodyMesh.material.emissiveIntensity = 1.0;
        }
    }

    restoreMaterials() {
        if (this.bodyMesh) {
            this.bodyMesh.material.emissiveIntensity = 0.3;
        }
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if (this.state !== 'ATTACK' || this.hasHitPlayer) return false;

        const dist = Math.sqrt(
            Math.pow(this.position.x - playerPosition.x, 2) +
            Math.pow(this.position.z - playerPosition.z, 2)
        );

        if (dist < (playerRadius + 0.5 * this.size)) {
            this.hasHitPlayer = true;
            return true;
        }
        return false;
    }

    resetAttackHit() {
        this.hasHitPlayer = false;
    }

    isVulnerable() {
        return this.state === 'RECOVER';
    }
}

// ‚îÄ‚îÄ‚îÄ CHRONOPHAGE PRIME CLASS (Final Boss) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class ChronophagePrime extends Enemy {
    constructor(scene, position, game) {
        super(scene, position);
        this.game = game; // Reference to game for spawning minions

        // Enemy name for health bar
        this.enemyName = 'Chronophage Prime';
        this.healthBarHeight = 6.0;

        // V2: Apply difficulty modifiers
        const baseDamage = 30;
        const baseSpeed = 4;
        const baseHealth = 400; // Final boss - ~16 hits on Normal
        this.health = getDifficultyValue(baseHealth, 'enemyHealth');
        this.maxHealth = this.health;
        this.damage = getDifficultyValue(baseDamage, 'enemyDamage');
        this.speed = getDifficultyValue(baseSpeed, 'enemySpeed');
        this.points = 10000;

        // Boss phases
        this.phase = 1; // 1, 2, or 3
        this.phaseThresholds = [0.66, 0.33]; // Phase transitions at 66% and 33% HP

        // State timings - V2: telegraph affected by difficulty
        const baseSweepTel = 1.0;
        const basePoundTel = 1.2;
        const baseSummonTel = 1.5;
        this.stateTimes = {
            SPAWN: 3.0,
            IDLE: 1.5,
            APPROACH: 0, // Continuous
            SWEEP_TELEGRAPH: getDifficultyValue(baseSweepTel, 'telegraphTime'),
            SWEEP: 0.8,
            POUND_TELEGRAPH: getDifficultyValue(basePoundTel, 'telegraphTime'),
            POUND: 0.5,
            SUMMON_TELEGRAPH: getDifficultyValue(baseSummonTel, 'telegraphTime'),
            SUMMON: 0.5,
            RECOVER: 1.5,
            TRANSITION: 2.0, // Phase transition
            RAGE: 0 // Final phase continuous
        };

        // Attack tracking
        this.attackPattern = ['SWEEP', 'POUND', 'SWEEP', 'SUMMON'];
        this.currentAttackIndex = 0;
        this.hasHitPlayer = false;

        // Summon tracking
        this.summonedTicks = [];
        this.maxSummons = 4;

        // Time distortion zones (Phase 2+)
        this.distortionZones = [];

        // Rage mode (Phase 3)
        this.rageTimer = 0;
        this.ragePulse = 0;

        this.createMesh();
        this.createHealthBar();
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const bodyMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            metalness: 0.7,
            roughness: 0.3
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.3,
            metalness: 0.9,
            roughness: 0.2
        });

        const clockMaterial = new THREE.MeshStandardMaterial({
            color: 0xeeeedd,
            metalness: 0.2,
            roughness: 0.5
        });

        const glowMaterial = new THREE.MeshBasicMaterial({
            color: 0xff4444,
            transparent: true,
            opacity: 0.8
        });

        // Massive central clock body
        const bodyGeometry = new THREE.CylinderGeometry(2, 2.5, 1.5, 32);
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 2.5;
        body.rotation.x = Math.PI / 2;
        this.mesh.add(body);
        this.body = body;

        // Clock face (front)
        const faceGeometry = new THREE.CircleGeometry(1.8, 32);
        const face = new THREE.Mesh(faceGeometry, clockMaterial);
        face.position.set(0, 2.5, 1.3);
        this.mesh.add(face);
        this.face = face;

        // Clock rim
        const rimGeometry = new THREE.TorusGeometry(1.9, 0.15, 16, 64);
        const rim = new THREE.Mesh(rimGeometry, goldMaterial);
        rim.position.set(0, 2.5, 1.3);
        this.mesh.add(rim);

        // Clock hands (animated)
        const hourHandGeom = new THREE.BoxGeometry(0.15, 0.8, 0.05);
        const hourHand = new THREE.Mesh(hourHandGeom, bodyMaterial);
        hourHand.position.set(0, 2.9, 1.35);
        this.mesh.add(hourHand);
        this.hourHand = hourHand;

        const minuteHandGeom = new THREE.BoxGeometry(0.1, 1.2, 0.05);
        const minuteHand = new THREE.Mesh(minuteHandGeom, bodyMaterial);
        minuteHand.position.set(0, 2.9, 1.4);
        this.mesh.add(minuteHand);
        this.minuteHand = minuteHand;

        // Central eye
        const eyeGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const eye = new THREE.Mesh(eyeGeometry, glowMaterial);
        eye.position.set(0, 2.5, 1.5);
        this.mesh.add(eye);
        this.eye = eye;

        // Massive arms (sweeping appendages)
        const armGeometry = new THREE.BoxGeometry(3, 0.3, 0.2);

        const leftArm = new THREE.Mesh(armGeometry, goldMaterial);
        leftArm.position.set(-2.5, 2.5, 0);
        this.mesh.add(leftArm);
        this.leftArm = leftArm;

        const rightArm = new THREE.Mesh(armGeometry, goldMaterial);
        rightArm.position.set(2.5, 2.5, 0);
        this.mesh.add(rightArm);
        this.rightArm = rightArm;

        // Clawed hands at arm ends
        for (let side = -1; side <= 1; side += 2) {
            for (let i = 0; i < 3; i++) {
                const clawGeom = new THREE.ConeGeometry(0.15, 0.6, 4);
                const claw = new THREE.Mesh(clawGeom, goldMaterial);
                claw.position.set(side * 4.2, 2.5 + (i - 1) * 0.3, 0);
                claw.rotation.z = side * Math.PI / 2;
                this.mesh.add(claw);
            }
        }

        // Lower body / base (floating gears)
        const baseGeometry = new THREE.TorusGeometry(1.5, 0.3, 8, 32);
        const base = new THREE.Mesh(baseGeometry, goldMaterial);
        base.position.y = 0.8;
        base.rotation.x = Math.PI / 2;
        this.mesh.add(base);

        // Floating gear rings
        for (let i = 0; i < 3; i++) {
            const gearGeom = new THREE.TorusGeometry(0.8 + i * 0.4, 0.08, 8, 16);
            const gear = new THREE.Mesh(gearGeom, bodyMaterial);
            gear.position.y = 0.3 - i * 0.2;
            gear.rotation.x = Math.PI / 2;
            gear.userData.rotSpeed = (i % 2 === 0 ? 1 : -1) * (0.5 + i * 0.2);
            this.mesh.add(gear);
        }

        // Boss glow
        const bossLight = new THREE.PointLight(0xff4444, 1, 15);
        bossLight.position.y = 2.5;
        this.mesh.add(bossLight);
        this.bossLight = bossLight;

        // Secondary lights
        const goldLight1 = new THREE.PointLight(0xd4af37, 0.8, 8);
        goldLight1.position.set(-3, 2.5, 0);
        this.mesh.add(goldLight1);

        const goldLight2 = new THREE.PointLight(0xd4af37, 0.8, 8);
        goldLight2.position.set(3, 2.5, 0);
        this.mesh.add(goldLight2);

        this.mesh.position.copy(this.position);
        this.scene.add(this.mesh);

        // Start with scale 0 for spawn animation
        this.mesh.scale.set(0.01, 0.01, 0.01);
    }

    update(deltaTime, playerPosition) {
        if (!this.isAlive && !this.isDying) return;

        if (this.isDying) {
            this.updateDeath(deltaTime);
            return;
        }

        this.stateTimer += deltaTime;
        this.updateFlash(deltaTime);

        // Animate clock hands
        this.hourHand.rotation.z = -this.stateTimer * 0.1;
        this.minuteHand.rotation.z = -this.stateTimer * 0.5;

        // Animate floating gears
        this.mesh.children.forEach(child => {
            if (child.userData.rotSpeed) {
                child.rotation.z += child.userData.rotSpeed * deltaTime;
            }
        });

        // Face player
        const toPlayer = new THREE.Vector3(
            playerPosition.x - this.position.x,
            0,
            playerPosition.z - this.position.z
        );
        const distanceToPlayer = toPlayer.length();
        toPlayer.normalize();

        this.rotation = Math.atan2(toPlayer.x, toPlayer.z);
        this.mesh.rotation.y = this.rotation;

        // Phase checks
        this.checkPhaseTransition();

        // Update distortion zones
        this.updateDistortionZones(deltaTime);

        // State machine
        switch (this.state) {
            case 'SPAWN':
                this.updateSpawn(deltaTime);
                break;
            case 'IDLE':
                this.updateIdle(deltaTime, distanceToPlayer);
                break;
            case 'APPROACH':
                this.updateApproach(deltaTime, toPlayer, distanceToPlayer);
                break;
            case 'SWEEP_TELEGRAPH':
                this.updateSweepTelegraph(deltaTime);
                break;
            case 'SWEEP':
                this.updateSweep(deltaTime);
                break;
            case 'POUND_TELEGRAPH':
                this.updatePoundTelegraph(deltaTime);
                break;
            case 'POUND':
                this.updatePound(deltaTime, playerPosition);
                break;
            case 'SUMMON_TELEGRAPH':
                this.updateSummonTelegraph(deltaTime);
                break;
            case 'SUMMON':
                this.updateSummon(deltaTime);
                break;
            case 'RECOVER':
                this.updateRecover(deltaTime);
                break;
            case 'TRANSITION':
                this.updateTransition(deltaTime);
                break;
        }

        this.mesh.position.x = this.position.x;
        this.mesh.position.z = this.position.z;

        // Hover animation
        this.mesh.position.y = Math.sin(this.stateTimer * 2) * 0.2;

        // Update health bar position
        this.updateHealthBar();
    }

    checkPhaseTransition() {
        const healthPercent = this.health / this.maxHealth;

        if (this.phase === 1 && healthPercent <= this.phaseThresholds[0]) {
            this.startPhaseTransition(2);
        } else if (this.phase === 2 && healthPercent <= this.phaseThresholds[1]) {
            this.startPhaseTransition(3);
        }
    }

    startPhaseTransition(newPhase) {
        this.phase = newPhase;
        this.state = 'TRANSITION';
        this.stateTimer = 0;

        // Visual feedback
        this.bossLight.color.setHex(newPhase === 2 ? 0xff8844 : 0xff0000);
        this.bossLight.intensity = 2;

        // Spawn distortion zones in Phase 2+
        if (newPhase >= 2) {
            this.createDistortionZone();
        }
    }

    updateSpawn(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SPAWN;
        this.mesh.scale.setScalar(Math.min(1, progress));

        // Dramatic spawn effect
        this.bossLight.intensity = 1 + Math.sin(this.stateTimer * 10) * 0.5;

        if (this.stateTimer >= this.stateTimes.SPAWN) {
            this.mesh.scale.setScalar(1);
            this.state = 'IDLE';
            this.stateTimer = 0;
        }
    }

    updateIdle(deltaTime, distanceToPlayer) {
        // Speed up in later phases
        const idleTime = this.stateTimes.IDLE / this.phase;

        if (this.stateTimer >= idleTime) {
            if (distanceToPlayer > 8) {
                this.state = 'APPROACH';
            } else {
                this.startNextAttack();
            }
            this.stateTimer = 0;
        }
    }

    updateApproach(deltaTime, toPlayer, distanceToPlayer) {
        const speed = this.speed * (this.phase === 3 ? 1.5 : 1);
        this.position.x += toPlayer.x * speed * deltaTime;
        this.position.z += toPlayer.z * speed * deltaTime;

        if (distanceToPlayer <= 8) {
            this.startNextAttack();
            this.stateTimer = 0;
        }
    }

    startNextAttack() {
        const attack = this.attackPattern[this.currentAttackIndex];
        this.currentAttackIndex = (this.currentAttackIndex + 1) % this.attackPattern.length;

        // Phase 3 adds more sweep attacks
        if (this.phase === 3 && Math.random() < 0.4) {
            this.state = 'SWEEP_TELEGRAPH';
        } else {
            this.state = attack + '_TELEGRAPH';
        }
        this.stateTimer = 0;
        this.hasHitPlayer = false;
    }

    updateSweepTelegraph(deltaTime) {
        const progress = this.stateTimer / (this.stateTimes.SWEEP_TELEGRAPH / this.phase);

        // Raise arms
        this.leftArm.rotation.z = progress * 0.5;
        this.rightArm.rotation.z = -progress * 0.5;

        // Glow warning
        this.bossLight.intensity = 1 + progress;

        if (this.stateTimer >= this.stateTimes.SWEEP_TELEGRAPH / this.phase) {
            this.state = 'SWEEP';
            this.stateTimer = 0;
        }
    }

    updateSweep(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SWEEP;

        // Sweep arms down
        this.leftArm.rotation.z = 0.5 - progress * 1.5;
        this.rightArm.rotation.z = -0.5 + progress * 1.5;

        if (this.stateTimer >= this.stateTimes.SWEEP) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
            this.leftArm.rotation.z = 0;
            this.rightArm.rotation.z = 0;
        }
    }

    updatePoundTelegraph(deltaTime) {
        const progress = this.stateTimer / (this.stateTimes.POUND_TELEGRAPH / this.phase);

        // Rise up
        this.mesh.position.y = progress * 3;

        // Both arms up
        this.leftArm.rotation.z = progress * 1.5;
        this.rightArm.rotation.z = -progress * 1.5;

        this.bossLight.intensity = 1 + progress * 2;

        if (this.stateTimer >= this.stateTimes.POUND_TELEGRAPH / this.phase) {
            this.state = 'POUND';
            this.stateTimer = 0;
        }
    }

    updatePound(deltaTime, playerPosition) {
        const progress = this.stateTimer / this.stateTimes.POUND;

        // Slam down
        this.mesh.position.y = 3 * (1 - progress * 2);
        if (this.mesh.position.y < 0) this.mesh.position.y = 0;

        // Arms slam
        this.leftArm.rotation.z = 1.5 - progress * 3;
        this.rightArm.rotation.z = -1.5 + progress * 3;

        if (this.stateTimer >= this.stateTimes.POUND) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
            this.leftArm.rotation.z = 0;
            this.rightArm.rotation.z = 0;

            // Create shockwave effect at impact
            this.createShockwave();
        }
    }

    createShockwave() {
        const shockwaveGeom = new THREE.RingGeometry(0.5, 1.5, 32);
        const shockwaveMat = new THREE.MeshBasicMaterial({
            color: 0xd4af37,
            transparent: true,
            opacity: 0.8,
            side: THREE.DoubleSide
        });
        const shockwave = new THREE.Mesh(shockwaveGeom, shockwaveMat);
        shockwave.position.copy(this.position);
        shockwave.position.y = 0.1;
        shockwave.rotation.x = -Math.PI / 2;
        this.scene.add(shockwave);

        // Store for animation
        if (!this.shockwaves) this.shockwaves = [];
        this.shockwaves.push({ mesh: shockwave, timer: 0 });
    }

    updateSummonTelegraph(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.SUMMON_TELEGRAPH;

        // Glow intensifies
        this.bossLight.intensity = 1 + progress * 2;
        this.eye.material.opacity = 0.8 + Math.sin(this.stateTimer * 20) * 0.2;

        if (this.stateTimer >= this.stateTimes.SUMMON_TELEGRAPH) {
            this.state = 'SUMMON';
            this.stateTimer = 0;
        }
    }

    updateSummon(deltaTime) {
        // Spawn Ticks around the boss
        if (this.stateTimer < deltaTime * 2 && this.game) {
            const tickCount = Math.min(this.maxSummons, 2 + this.phase);
            for (let i = 0; i < tickCount; i++) {
                const angle = (i / tickCount) * Math.PI * 2;
                const dist = 5;
                const pos = new THREE.Vector3(
                    this.position.x + Math.cos(angle) * dist,
                    0,
                    this.position.z + Math.sin(angle) * dist
                );
                this.game.spawnEnemy('tick', pos);
            }
        }

        if (this.stateTimer >= this.stateTimes.SUMMON) {
            this.state = 'RECOVER';
            this.stateTimer = 0;
        }
    }

    updateRecover(deltaTime) {
        const recoverTime = this.stateTimes.RECOVER / (this.phase === 3 ? 2 : 1);
        this.bossLight.intensity = 1;

        if (this.stateTimer >= recoverTime) {
            this.state = 'IDLE';
            this.stateTimer = 0;
        }
    }

    updateTransition(deltaTime) {
        const progress = this.stateTimer / this.stateTimes.TRANSITION;

        // Dramatic pulsing
        const pulse = Math.sin(progress * Math.PI * 6);
        this.mesh.scale.setScalar(1 + pulse * 0.1);
        this.bossLight.intensity = 2 + pulse;

        if (this.stateTimer >= this.stateTimes.TRANSITION) {
            this.state = 'IDLE';
            this.stateTimer = 0;
            this.mesh.scale.setScalar(1);
            this.bossLight.intensity = 1;
        }
    }

    createDistortionZone() {
        // Create a time distortion zone
        const zoneGeom = new THREE.CylinderGeometry(4, 4, 0.2, 32);
        const zoneMat = new THREE.MeshBasicMaterial({
            color: 0x8844ff,
            transparent: true,
            opacity: 0.3
        });
        const zone = new THREE.Mesh(zoneGeom, zoneMat);

        // Random position in arena
        const angle = Math.random() * Math.PI * 2;
        const dist = 10 + Math.random() * 15;
        zone.position.set(
            Math.cos(angle) * dist,
            0.1,
            Math.sin(angle) * dist
        );

        this.scene.add(zone);
        this.distortionZones.push({
            mesh: zone,
            timer: 0,
            duration: 8 + Math.random() * 4
        });
    }

    updateDistortionZones(deltaTime) {
        for (let i = this.distortionZones.length - 1; i >= 0; i--) {
            const zone = this.distortionZones[i];
            zone.timer += deltaTime;

            // Pulse effect
            zone.mesh.material.opacity = 0.3 + Math.sin(zone.timer * 3) * 0.1;

            if (zone.timer >= zone.duration) {
                this.scene.remove(zone.mesh);
                this.distortionZones.splice(i, 1);

                // Create new zone in Phase 2+
                if (this.phase >= 2 && this.isAlive) {
                    this.createDistortionZone();
                }
            }
        }

        // Update shockwaves
        if (this.shockwaves) {
            for (let i = this.shockwaves.length - 1; i >= 0; i--) {
                const sw = this.shockwaves[i];
                sw.timer += deltaTime;
                const progress = sw.timer / 0.5;

                sw.mesh.scale.setScalar(1 + progress * 10);
                sw.mesh.material.opacity = 0.8 * (1 - progress);

                if (progress >= 1) {
                    this.scene.remove(sw.mesh);
                    this.shockwaves.splice(i, 1);
                }
            }
        }
    }

    updateDeath(deltaTime) {
        this.deathTimer += deltaTime;
        const progress = this.deathTimer / 3.0; // Long death animation

        // Hide health bar on death
        this.hideHealthBar();

        if (progress < 1) {
            // Dramatic death - explode outward
            const shake = Math.sin(progress * 50) * (1 - progress) * 0.3;
            this.mesh.position.x = this.position.x + shake;
            this.mesh.position.z = this.position.z + shake;

            this.mesh.rotation.y += deltaTime * progress * 10;
            this.mesh.scale.setScalar(1 + progress * 0.5);

            this.bossLight.intensity = 3 * (1 - progress);

            // Shrink at the end
            if (progress > 0.7) {
                this.mesh.scale.setScalar((1 - progress) * 3);
            }
        } else {
            // Clean up
            for (const zone of this.distortionZones) {
                this.scene.remove(zone.mesh);
            }
            this.distortionZones = [];

            if (this.shockwaves) {
                for (const sw of this.shockwaves) {
                    this.scene.remove(sw.mesh);
                }
                this.shockwaves = [];
            }

            this.isDying = false;
            this.destroy();
        }
    }

    applyFlash() {
        if (this.mesh) this.mesh.scale.setScalar(1.1);
    }

    restoreMaterials() {
        if (this.mesh) this.mesh.scale.setScalar(1.0);
    }

    checkAttackHit(playerPosition, playerRadius = 0.5) {
        if (this.hasHitPlayer) return false;

        // Sweep attack - wide arc
        if (this.state === 'SWEEP') {
            const dist = Vec3.distance(this.position, playerPosition);
            if (dist < 6) { // Wide sweep range
                this.hasHitPlayer = true;
                this.damage = 25 * this.phase;
                return true;
            }
        }

        // Pound attack - AoE around boss
        if (this.state === 'POUND' && this.stateTimer > this.stateTimes.POUND * 0.8) {
            const dist = Vec3.distance(this.position, playerPosition);
            if (dist < 8) { // Shockwave range
                this.hasHitPlayer = true;
                this.damage = 35 * this.phase;
                return true;
            }
        }

        // Distortion zone damage (slow tick)
        for (const zone of this.distortionZones) {
            const dist = Vec3.distance(zone.mesh.position, playerPosition);
            if (dist < 4) {
                // Small damage tick (handled per frame, so very low)
                this.damage = 5;
                return true;
            }
        }

        return false;
    }

    isVulnerable() {
        return this.state === 'RECOVER' || this.state === 'TRANSITION';
    }
}

// ‚îÄ‚îÄ‚îÄ PLAYER CLASS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Player {
    constructor(scene) {
        this.scene = scene;

        // Position and rotation
        this.position = new THREE.Vector3(0, 0, 0);
        this.rotation = 0; // Y-axis rotation (facing direction)
        this.targetRotation = 0;

        // Velocity
        this.velocity = new THREE.Vector3(0, 0, 0);
        this.currentSpeed = 0;

        // Stats V2 - Health based on difficulty
        this.maxHealth = getPlayerMaxHealth();
        this.health = this.maxHealth;
        this.stamina = CONFIG.maxStamina;
        this.temporalCharge = 0;
        this.staminaRegenTimer = 0;

        // Health Regeneration V2
        this.outOfCombatTimer = 0; // Time since last damage
        this.isRegenerating = false;
        this.regenPulseTimer = 0;
        this.lastHealth = this.health; // For tracking damage

        // State flags
        this.isSprinting = false;
        this.isDashing = false;
        this.dashTimer = 0;
        this.dashCooldownTimer = 0;
        this.dashDirection = new THREE.Vector3(0, 0, -1);

        // Combat
        this.isAttacking = false;
        this.sword = null;

        // Temporal Abilities
        this.timeFractureCooldown = 0;
        this.temporalEchoCooldown = 0;
        this.chronostasisCooldown = 0;

        // Temporal Echo state
        this.temporalEchoActive = false;
        this.temporalEchoTimer = 0;
        this.temporalEchoPosition = null;
        this.temporalEchoGhost = null;

        // Key press tracking (for single-press abilities)
        this.keyPressed = { q: false, e: false, r: false };

        // Animation
        this.bobOffset = 0;
        this.stepTimer = 0;

        // Mesh group
        this.mesh = null;
        this.bodyParts = {};

        // Ability effects container
        this.abilityEffects = [];

        // V2 Weapon System
        this.weapons = ['blade', 'pistol', 'scythe'];
        this.currentWeapon = 'blade';
        this.weaponIndex = 0;

        // Pistol state
        this.pistolAmmo = CONFIG.weapons.pistol.maxAmmo;
        this.pistolReloading = false;
        this.pistolReloadTimer = 0;
        this.lastFireTime = 0;
        this.projectiles = []; // For pistol bullets

        // Scythe state
        this.scytheTrailTimer = 0;

        // V2.7 Dash afterimages
        this.dashAfterimages = [];
        this.dashAfterimageTimer = 0;

        // Create the player mesh
        this.createMesh();

        // Create sword (after mesh so it can be attached)
        this.sword = new Sword(scene, this);
        this.mesh.add(this.sword.mesh);

        // Create all weapon meshes (hidden by default, blade shown)
        this.createWeaponMeshes();
    }

    // V2 - Create weapon meshes
    createWeaponMeshes() {
        // Weapons are attached to hand position on the mesh
        // Blade is the default Sword mesh already created
        // Create pistol mesh
        const pistolGroup = new THREE.Group();
        const pistolMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a6080,
            metalness: 0.8,
            roughness: 0.2
        });
        const glowMaterial = new THREE.MeshStandardMaterial({
            color: 0x7eb8da,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.5
        });

        // Pistol body
        const body = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.3, 0.5),
            pistolMaterial
        );
        body.position.set(0, 0, 0.15);
        pistolGroup.add(body);

        // Barrel
        const barrel = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8),
            pistolMaterial
        );
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0, 0.05, 0.5);
        pistolGroup.add(barrel);

        // Glow ring
        const glowRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.06, 0.015, 8, 16),
            glowMaterial
        );
        glowRing.rotation.y = Math.PI / 2;
        glowRing.position.set(0, 0.05, 0.6);
        pistolGroup.add(glowRing);

        pistolGroup.visible = false;
        pistolGroup.position.set(0.35, 1.1, 0.2);
        this.mesh.add(pistolGroup);
        this.pistolMesh = pistolGroup;

        // Create scythe mesh
        const scytheGroup = new THREE.Group();
        const handleMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a1a3a,
            roughness: 0.7,
            metalness: 0.3
        });
        const bladeMaterial = new THREE.MeshStandardMaterial({
            color: 0x8866aa,
            emissive: 0x442255,
            emissiveIntensity: 0.3,
            metalness: 0.9,
            roughness: 0.1
        });

        // Handle
        const handle = new THREE.Mesh(
            new THREE.CylinderGeometry(0.04, 0.04, 2.0, 8),
            handleMaterial
        );
        handle.position.set(0, 0, 0);
        scytheGroup.add(handle);

        // Blade curve (made from a curved shape)
        const bladeShape = new THREE.Shape();
        bladeShape.moveTo(0, 0);
        bladeShape.quadraticCurveTo(0.8, 0.2, 1.0, -0.5);
        bladeShape.lineTo(0.95, -0.55);
        bladeShape.quadraticCurveTo(0.7, 0.1, 0.05, -0.05);
        bladeShape.lineTo(0, 0);

        const bladeGeom = new THREE.ExtrudeGeometry(bladeShape, {
            depth: 0.03,
            bevelEnabled: false
        });
        const blade = new THREE.Mesh(bladeGeom, bladeMaterial);
        blade.rotation.z = Math.PI;
        blade.position.set(0, 1.0, 0);
        scytheGroup.add(blade);

        scytheGroup.visible = false;
        scytheGroup.position.set(0.5, 0.8, 0);
        scytheGroup.rotation.z = -Math.PI / 6;
        this.mesh.add(scytheGroup);
        this.scytheMesh = scytheGroup;
    }

    // V2 - Switch weapon
    switchWeapon(weaponName) {
        if (this.currentWeapon === weaponName) return;
        if (!this.weapons.includes(weaponName)) return;

        this.currentWeapon = weaponName;
        this.weaponIndex = this.weapons.indexOf(weaponName);

        // Update weapon visibility
        this.sword.mesh.visible = (weaponName === 'blade');
        this.pistolMesh.visible = (weaponName === 'pistol');
        this.scytheMesh.visible = (weaponName === 'scythe');

        // Update HUD
        this.updateWeaponHUD();
    }

    // V2 - Cycle to next weapon
    cycleWeapon(direction = 1) {
        this.weaponIndex = (this.weaponIndex + direction + this.weapons.length) % this.weapons.length;
        this.switchWeapon(this.weapons[this.weaponIndex]);
    }

    // V2 - Update weapon HUD display
    updateWeaponHUD() {
        const slots = document.querySelectorAll('.weapon-slot');
        slots.forEach(slot => {
            const weapon = slot.dataset.weapon;
            slot.classList.toggle('active', weapon === this.currentWeapon);
        });

        // Update pistol ammo display
        document.getElementById('pistol-ammo').textContent =
            `${this.pistolAmmo}/${CONFIG.weapons.pistol.maxAmmo}`;
    }

    // V2 - Fire pistol
    firePistol() {
        const now = performance.now() / 1000;
        const fireInterval = 1 / CONFIG.weapons.pistol.fireRate;

        if (this.pistolReloading) return false;
        if (now - this.lastFireTime < fireInterval) return false;
        if (this.pistolAmmo <= 0) {
            this.reloadPistol();
            return false;
        }

        this.lastFireTime = now;
        this.pistolAmmo--;

        // Create projectile
        const projectile = this.createPistolProjectile();
        this.projectiles.push(projectile);

        // V2.8 Pistol shot sound
        audioManager.playPistolShot();

        this.updateWeaponHUD();
        return true;
    }

    // V2 - Create pistol projectile
    createPistolProjectile() {
        const projectileMaterial = new THREE.MeshStandardMaterial({
            color: 0x7eb8da,
            emissive: 0x4a90b8,
            emissiveIntensity: 1.0
        });

        const projectile = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 8, 8),
            projectileMaterial
        );

        // Start position at player
        const startPos = this.position.clone();
        startPos.y += 1.2;

        // Direction based on player facing (forward direction)
        const direction = new THREE.Vector3(
            Math.sin(this.rotation),
            0,
            Math.cos(this.rotation)
        ).normalize();

        // Offset start position slightly forward
        startPos.add(direction.clone().multiplyScalar(0.8));

        projectile.position.copy(startPos);

        // Add point light for glow effect
        const light = new THREE.PointLight(0x7eb8da, 0.5, 3);
        projectile.add(light);

        this.scene.add(projectile);

        return {
            mesh: projectile,
            direction: direction,
            speed: 40,
            damage: CONFIG.weapons.pistol.damage,
            lifetime: 2,
            timer: 0
        };
    }

    // V2 - Update pistol projectiles
    updateProjectiles(deltaTime) {
        for (let i = this.projectiles.length - 1; i >= 0; i--) {
            const proj = this.projectiles[i];
            proj.timer += deltaTime;

            // Move projectile
            proj.mesh.position.add(
                proj.direction.clone().multiplyScalar(proj.speed * deltaTime)
            );

            // Remove if lifetime exceeded or out of arena
            if (proj.timer > proj.lifetime ||
                proj.mesh.position.length() > CONFIG.arenaRadius + 10) {
                this.scene.remove(proj.mesh);
                this.projectiles.splice(i, 1);
            }
        }
    }

    // V2 - Reload pistol
    reloadPistol() {
        if (this.pistolReloading) return;
        if (this.pistolAmmo >= CONFIG.weapons.pistol.maxAmmo) return;

        this.pistolReloading = true;
        this.pistolReloadTimer = CONFIG.weapons.pistol.reloadTime;

        // V2.8 Reload sound
        audioManager.playPistolReload();
    }

    // V2 - Update reload
    updateReload(deltaTime) {
        if (!this.pistolReloading) return;

        this.pistolReloadTimer -= deltaTime;
        if (this.pistolReloadTimer <= 0) {
            this.pistolAmmo = CONFIG.weapons.pistol.maxAmmo;
            this.pistolReloading = false;
            this.updateWeaponHUD();
        }
    }

    createMesh() {
        this.mesh = new THREE.Group();

        // Materials
        const robeMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            roughness: 0.8,
            metalness: 0.2
        });

        const robeAccentMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a3a5a,
            roughness: 0.6,
            metalness: 0.3
        });

        const goldMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.2
        });

        const eyeMaterial = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 0.9
        });

        // Body - main robe (tapered cylinder)
        const bodyGeometry = new THREE.CylinderGeometry(0.3, 0.6, 1.4, 8);
        const body = new THREE.Mesh(bodyGeometry, robeMaterial);
        body.position.y = 0.7;
        body.castShadow = true;
        this.mesh.add(body);
        this.bodyParts.body = body;

        // Lower robe (flared bottom)
        const lowerRobeGeometry = new THREE.CylinderGeometry(0.6, 0.8, 0.6, 8);
        const lowerRobe = new THREE.Mesh(lowerRobeGeometry, robeMaterial);
        lowerRobe.position.y = 0.3;
        lowerRobe.castShadow = true;
        this.mesh.add(lowerRobe);

        // Hood
        const hoodGeometry = new THREE.SphereGeometry(0.35, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const hood = new THREE.Mesh(hoodGeometry, robeMaterial);
        hood.position.y = 1.6;
        hood.scale.set(1, 1.2, 1);
        hood.castShadow = true;
        this.mesh.add(hood);

        // Hood rim (gold accent)
        const hoodRimGeometry = new THREE.TorusGeometry(0.35, 0.03, 8, 16, Math.PI);
        const hoodRim = new THREE.Mesh(hoodRimGeometry, goldMaterial);
        hoodRim.position.set(0, 1.5, 0.1);
        hoodRim.rotation.x = Math.PI / 2;
        hoodRim.rotation.z = Math.PI;
        this.mesh.add(hoodRim);

        // Face area (dark void)
        const faceGeometry = new THREE.SphereGeometry(0.25, 8, 8, 0, Math.PI, 0, Math.PI);
        const faceMaterial = new THREE.MeshBasicMaterial({
            color: 0x000000,
            side: THREE.DoubleSide
        });
        const face = new THREE.Mesh(faceGeometry, faceMaterial);
        face.position.set(0, 1.55, 0.15);
        face.rotation.y = Math.PI;
        this.mesh.add(face);

        // Glowing eyes
        const eyeGeometry = new THREE.SphereGeometry(0.04, 8, 8);
        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.08, 1.55, 0.25);
        this.mesh.add(leftEye);
        this.bodyParts.leftEye = leftEye;

        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.08, 1.55, 0.25);
        this.mesh.add(rightEye);
        this.bodyParts.rightEye = rightEye;

        // Eye glow (point light)
        const eyeGlow = new THREE.PointLight(0x7eb8da, 0.3, 2);
        eyeGlow.position.set(0, 1.55, 0.3);
        this.mesh.add(eyeGlow);
        this.bodyParts.eyeGlow = eyeGlow;

        // Shoulder pauldrons (left)
        const pauldronGeometry = new THREE.SphereGeometry(0.18, 8, 8);
        const leftPauldron = new THREE.Mesh(pauldronGeometry, goldMaterial);
        leftPauldron.position.set(-0.45, 1.3, 0);
        leftPauldron.scale.set(1, 0.8, 0.8);
        leftPauldron.castShadow = true;
        this.mesh.add(leftPauldron);

        const rightPauldron = new THREE.Mesh(pauldronGeometry, goldMaterial);
        rightPauldron.position.set(0.45, 1.3, 0);
        rightPauldron.scale.set(1, 0.8, 0.8);
        rightPauldron.castShadow = true;
        this.mesh.add(rightPauldron);

        // Clock motif on pauldrons (small circles)
        const clockDetailGeometry = new THREE.TorusGeometry(0.08, 0.015, 8, 16);
        const leftClockDetail = new THREE.Mesh(clockDetailGeometry, robeAccentMaterial);
        leftClockDetail.position.set(-0.55, 1.3, 0.1);
        leftClockDetail.rotation.y = Math.PI / 4;
        this.mesh.add(leftClockDetail);

        const rightClockDetail = new THREE.Mesh(clockDetailGeometry, robeAccentMaterial);
        rightClockDetail.position.set(0.55, 1.3, 0.1);
        rightClockDetail.rotation.y = -Math.PI / 4;
        this.mesh.add(rightClockDetail);

        // Arms
        const armGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.6, 8);
        const leftArm = new THREE.Mesh(armGeometry, robeAccentMaterial);
        leftArm.position.set(-0.5, 1.0, 0);
        leftArm.rotation.z = 0.3;
        leftArm.castShadow = true;
        this.mesh.add(leftArm);
        this.bodyParts.leftArm = leftArm;

        const rightArm = new THREE.Mesh(armGeometry, robeAccentMaterial);
        rightArm.position.set(0.5, 1.0, 0);
        rightArm.rotation.z = -0.3;
        rightArm.castShadow = true;
        this.mesh.add(rightArm);
        this.bodyParts.rightArm = rightArm;

        // Forearms
        const forearmGeometry = new THREE.CylinderGeometry(0.06, 0.08, 0.5, 8);
        const leftForearm = new THREE.Mesh(forearmGeometry, robeAccentMaterial);
        leftForearm.position.set(-0.6, 0.55, 0.2);
        leftForearm.rotation.x = -0.5;
        leftForearm.rotation.z = 0.2;
        leftForearm.castShadow = true;
        this.mesh.add(leftForearm);
        this.bodyParts.leftForearm = leftForearm;

        const rightForearm = new THREE.Mesh(forearmGeometry, robeAccentMaterial);
        rightForearm.position.set(0.5, 0.55, 0.3);
        rightForearm.rotation.x = -0.8;
        rightForearm.rotation.z = -0.2;
        rightForearm.castShadow = true;
        this.mesh.add(rightForearm);
        this.bodyParts.rightForearm = rightForearm;

        // Gauntlets with clock faces
        const gauntletGeometry = new THREE.BoxGeometry(0.12, 0.15, 0.08);
        const leftGauntlet = new THREE.Mesh(gauntletGeometry, goldMaterial);
        leftGauntlet.position.set(-0.65, 0.35, 0.35);
        this.mesh.add(leftGauntlet);

        const rightGauntlet = new THREE.Mesh(gauntletGeometry, goldMaterial);
        rightGauntlet.position.set(0.45, 0.3, 0.5);
        this.mesh.add(rightGauntlet);

        // Gauntlet clock faces
        const gauntletClockGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.02, 12);
        const gauntletClockMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a90b8,
            transparent: true,
            opacity: 0.8
        });

        const leftGauntletClock = new THREE.Mesh(gauntletClockGeometry, gauntletClockMaterial);
        leftGauntletClock.position.set(-0.65, 0.35, 0.4);
        leftGauntletClock.rotation.x = Math.PI / 2;
        this.mesh.add(leftGauntletClock);

        const rightGauntletClock = new THREE.Mesh(gauntletClockGeometry, gauntletClockMaterial);
        rightGauntletClock.position.set(0.45, 0.3, 0.55);
        rightGauntletClock.rotation.x = Math.PI / 2;
        this.mesh.add(rightGauntletClock);

        // Belt with clock buckle
        const beltGeometry = new THREE.TorusGeometry(0.55, 0.04, 8, 24);
        const belt = new THREE.Mesh(beltGeometry, goldMaterial);
        belt.position.y = 0.6;
        belt.rotation.x = Math.PI / 2;
        this.mesh.add(belt);

        const buckleGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.05, 16);
        const buckle = new THREE.Mesh(buckleGeometry, goldMaterial);
        buckle.position.set(0, 0.6, 0.55);
        buckle.rotation.x = Math.PI / 2;
        this.mesh.add(buckle);

        // Position the mesh
        this.mesh.position.copy(this.position);
        this.scene.add(this.mesh);
    }

    update(deltaTime, input, elapsedTime) {
        // Handle dashing
        if (this.isDashing) {
            this.updateDash(deltaTime);
            // Still update sword during dash
            if (this.sword) {
                this.sword.update(deltaTime, elapsedTime);
            }
            return;
        }

        // Update dash cooldown
        if (this.dashCooldownTimer > 0) {
            this.dashCooldownTimer -= deltaTime;
        }

        // Check if currently in attack recovery (can't move during attack)
        this.isAttacking = this.sword && this.sword.isAttacking;

        // Get movement input
        const moveInput = this.getMovementInput(input);

        // Check for sprint (can't sprint while attacking)
        this.isSprinting = (input.isKeyDown('ShiftLeft') || input.isKeyDown('ShiftRight')) && !this.isAttacking;

        // Check stamina for sprint
        if (this.isSprinting && this.stamina <= 0) {
            this.isSprinting = false;
        }

        // Handle attack inputs (V2 - weapon-specific)
        if (input.mouseButtons.left) {
            if (this.currentWeapon === 'pistol') {
                // Pistol fires on left click
                this.firePistol();
            } else if (this.sword) {
                // Blade and Scythe use melee
                this.sword.startLightAttack();
            }
        }
        if (input.mouseButtons.right) {
            if (this.currentWeapon === 'pistol') {
                // Pistol reload on right click
                this.reloadPistol();
            } else if (this.sword) {
                // Heavy attack for melee
                this.sword.startHeavyAttack();
            }
        }

        // Calculate target speed (reduced during attack)
        let targetSpeed = 0;
        if (moveInput.length() > 0 && !this.isAttacking) {
            targetSpeed = CONFIG.playerSpeed;
            if (this.isSprinting) {
                targetSpeed *= CONFIG.sprintMultiplier;
            }
        } else if (moveInput.length() > 0 && this.isAttacking) {
            // Can still move slowly during attack
            targetSpeed = CONFIG.playerSpeed * 0.3;
        }

        // Smooth speed transition
        const acceleration = targetSpeed > this.currentSpeed ? 50 : 80;
        this.currentSpeed = THREE.MathUtils.lerp(
            this.currentSpeed,
            targetSpeed,
            Math.min(1, acceleration * deltaTime)
        );

        // Apply movement
        if (moveInput.length() > 0.01) {
            const moveDir = moveInput.normalize();
            this.velocity.x = moveDir.x * this.currentSpeed;
            this.velocity.z = moveDir.z * this.currentSpeed;

            // Update target rotation to face movement direction (slower during attack)
            if (!this.isAttacking) {
                this.targetRotation = Math.atan2(moveDir.x, moveDir.z);
            }
        } else {
            this.velocity.x *= 0.8;
            this.velocity.z *= 0.8;
        }

        // Smooth rotation
        let rotationDiff = this.targetRotation - this.rotation;
        while (rotationDiff > Math.PI) rotationDiff -= Math.PI * 2;
        while (rotationDiff < -Math.PI) rotationDiff += Math.PI * 2;
        this.rotation += rotationDiff * Math.min(1, 15 * deltaTime);

        // Apply velocity to position
        this.position.x += this.velocity.x * deltaTime;
        this.position.z += this.velocity.z * deltaTime;

        // Arena boundary check
        const distFromCenter = Math.sqrt(
            this.position.x * this.position.x +
            this.position.z * this.position.z
        );

        if (distFromCenter > CONFIG.arenaRadius - 1) {
            const angle = Math.atan2(this.position.z, this.position.x);
            this.position.x = Math.cos(angle) * (CONFIG.arenaRadius - 1);
            this.position.z = Math.sin(angle) * (CONFIG.arenaRadius - 1);
        }

        // Stamina management (V2 - difficulty adjusted)
        const staminaRegenMult = getStaminaRegenMultiplier();
        if (this.isSprinting && this.currentSpeed > CONFIG.playerSpeed) {
            this.stamina -= 20 * deltaTime;
            this.staminaRegenTimer = CONFIG.staminaRegenDelay;
            if (this.stamina < 0) this.stamina = 0;
        } else {
            if (this.staminaRegenTimer > 0) {
                this.staminaRegenTimer -= deltaTime;
            } else {
                this.stamina += CONFIG.staminaRegen * staminaRegenMult * deltaTime;
                if (this.stamina > CONFIG.maxStamina) {
                    this.stamina = CONFIG.maxStamina;
                }
            }
        }

        // Health Regeneration V2
        this.updateHealthRegen(deltaTime);

        // Handle dash/strafe input (can dash during attack recovery to cancel it)
        if ((input.isKeyDown('Space')) && this.dashCooldownTimer <= 0 && this.stamina >= CONFIG.dashStaminaCost) {
            // Dash cancels attack
            if (this.sword && this.sword.isAttacking && this.sword.attackPhase === 'recovery') {
                this.sword.endAttack();
                // Extra stamina cost for dash cancel
                this.stamina -= 10;
            }
            if (!this.sword || !this.sword.isAttacking || this.sword.attackPhase === 'recovery') {
                // Determine strafe direction based on A/D keys
                let strafeDir = 0;
                if (input.isKeyDown('KeyA') || input.isKeyDown('ArrowLeft')) {
                    strafeDir = -1; // Strafe left
                } else if (input.isKeyDown('KeyD') || input.isKeyDown('ArrowRight')) {
                    strafeDir = 1; // Strafe right
                }
                this.startDash(moveInput, strafeDir);
            }
        }

        // Update sword
        if (this.sword) {
            this.sword.update(deltaTime, elapsedTime);
        }

        // Update ability cooldowns
        this.updateAbilityCooldowns(deltaTime);

        // Update Temporal Echo
        this.updateTemporalEcho(deltaTime);

        // Update ability effects
        this.updateAbilityEffects(deltaTime);

        // Handle ability inputs (Q, E, R)
        this.handleAbilityInput(input);

        // Update mesh position and rotation
        this.updateMesh(deltaTime);

        // V2.7 Update dash afterimages
        this.updateAfterimages(deltaTime);

        // Update HUD
        this.updateHUD();
    }

    updateAbilityCooldowns(deltaTime) {
        if (this.timeFractureCooldown > 0) {
            this.timeFractureCooldown -= deltaTime;
        }
        if (this.temporalEchoCooldown > 0) {
            this.temporalEchoCooldown -= deltaTime;
        }
        if (this.chronostasisCooldown > 0) {
            this.chronostasisCooldown -= deltaTime;
        }
    }

    // V2 Health Regeneration System
    updateHealthRegen(deltaTime) {
        const regenRate = getHealthRegenRate();

        // No regen if rate is 0 (hard/nightmare modes)
        if (regenRate <= 0) {
            this.isRegenerating = false;
            return;
        }

        // Track if we took damage this frame
        if (this.health < this.lastHealth) {
            this.outOfCombatTimer = 0;
            this.isRegenerating = false;
        }
        this.lastHealth = this.health;

        // Update out of combat timer
        this.outOfCombatTimer += deltaTime;

        // Start regenerating after delay
        if (this.outOfCombatTimer >= CONFIG.regenDelay && this.health < this.maxHealth) {
            this.isRegenerating = true;

            // Regenerate health
            this.health += regenRate * deltaTime;
            if (this.health > this.maxHealth) {
                this.health = this.maxHealth;
            }

            // Regen pulse timer for visual effect
            this.regenPulseTimer += deltaTime;
        } else {
            this.isRegenerating = false;
            this.regenPulseTimer = 0;
        }
    }

    handleAbilityInput(input) {
        // Q - Time Fracture (AoE burst)
        const qDown = input.isKeyDown('KeyQ');
        if (qDown && !this.keyPressed.q) {
            this.keyPressed.q = true;
            if (this.canUseTimeFracture()) {
                this.useTimeFracture();
            }
        } else if (!qDown) {
            this.keyPressed.q = false;
        }

        // E - Temporal Echo (teleport back)
        const eDown = input.isKeyDown('KeyE');
        if (eDown && !this.keyPressed.e) {
            this.keyPressed.e = true;
            if (this.canUseTemporalEcho()) {
                this.useTemporalEcho();
            }
        } else if (!eDown) {
            this.keyPressed.e = false;
        }

        // R - Chronostasis (freeze enemies) - handled in Game class, but we check here
        const rDown = input.isKeyDown('KeyR');
        if (rDown && !this.keyPressed.r) {
            this.keyPressed.r = true;
            if (this.canUseChronostasis()) {
                // Signal to game that we want to use Chronostasis
                this.wantsChronostasis = true;
            }
        } else if (!rDown) {
            this.keyPressed.r = false;
        }
    }

    // Time Fracture (Q) - AoE damage burst
    canUseTimeFracture() {
        return this.timeFractureCooldown <= 0 &&
               this.temporalCharge >= CONFIG.timeFractureCost;
    }

    useTimeFracture() {
        this.temporalCharge -= CONFIG.timeFractureCost;
        this.timeFractureCooldown = CONFIG.timeFractureCooldown;

        // Play Time Fracture sound
        audioManager.playTimeFracture();

        // Create visual effect - expanding ring
        this.createTimeFractureEffect();

        // Return hit info for Game to process damage
        return {
            type: 'timeFracture',
            position: this.position.clone(),
            radius: CONFIG.timeFractureRadius,
            damage: CONFIG.timeFractureDamage
        };
    }

    // Flag to track if Time Fracture damage was processed (prevents hitstop loop)
    markTimeFractureProcessed() {
        for (const effect of this.abilityEffects) {
            if (effect.type === 'timeFracture' && !effect.damageProcessed) {
                effect.damageProcessed = true;
            }
        }
    }

    createTimeFractureEffect() {
        // Create expanding ring effect
        const ringGeometry = new THREE.RingGeometry(0.5, 1, 32);
        const ringMaterial = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 1,
            side: THREE.DoubleSide
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.position.copy(this.position);
        ring.position.y = 0.1;
        ring.rotation.x = -Math.PI / 2;
        this.scene.add(ring);

        // Inner burst
        const burstGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        const burstMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.8
        });
        const burst = new THREE.Mesh(burstGeometry, burstMaterial);
        burst.position.copy(this.position);
        burst.position.y = 1;
        this.scene.add(burst);

        // Add particles
        const particleCount = 30;
        const particles = [];
        for (let i = 0; i < particleCount; i++) {
            const pGeom = new THREE.SphereGeometry(0.1, 8, 8);
            const pMat = new THREE.MeshBasicMaterial({
                color: Math.random() > 0.5 ? 0x7eb8da : 0xd4af37,
                transparent: true,
                opacity: 1
            });
            const p = new THREE.Mesh(pGeom, pMat);
            const angle = (i / particleCount) * Math.PI * 2;
            p.position.copy(this.position);
            p.position.y = 0.5 + Math.random();
            p.userData = {
                velocity: new THREE.Vector3(
                    Math.cos(angle) * (3 + Math.random() * 2),
                    1 + Math.random() * 2,
                    Math.sin(angle) * (3 + Math.random() * 2)
                )
            };
            this.scene.add(p);
            particles.push(p);
        }

        this.abilityEffects.push({
            type: 'timeFracture',
            timer: 0,
            duration: 0.5,
            ring: ring,
            burst: burst,
            particles: particles
        });
    }

    // Temporal Echo (E) - Leave ghost, teleport back
    canUseTemporalEcho() {
        return this.temporalEchoCooldown <= 0 &&
               this.temporalCharge >= CONFIG.temporalEchoCost &&
               !this.temporalEchoActive;
    }

    useTemporalEcho() {
        this.temporalCharge -= CONFIG.temporalEchoCost;
        this.temporalEchoCooldown = CONFIG.temporalEchoCooldown;
        this.temporalEchoActive = true;
        this.temporalEchoTimer = CONFIG.temporalEchoDuration;
        this.temporalEchoPosition = this.position.clone();

        // Play Temporal Echo sound
        audioManager.playTemporalEcho();

        // Create ghost mesh at current position
        this.createTemporalEchoGhost();
    }

    createTemporalEchoGhost() {
        // Create a ghostly copy of the player
        this.temporalEchoGhost = new THREE.Group();

        // Simple ghost representation - translucent silhouette
        const ghostMaterial = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 0.5
        });

        // Body
        const bodyGeom = new THREE.CylinderGeometry(0.3, 0.6, 1.4, 8);
        const body = new THREE.Mesh(bodyGeom, ghostMaterial);
        body.position.y = 0.7;
        this.temporalEchoGhost.add(body);

        // Hood
        const hoodGeom = new THREE.SphereGeometry(0.35, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2);
        const hood = new THREE.Mesh(hoodGeom, ghostMaterial);
        hood.position.y = 1.6;
        hood.scale.set(1, 1.2, 1);
        this.temporalEchoGhost.add(hood);

        // Pulsing light
        const light = new THREE.PointLight(0x7eb8da, 1, 5);
        light.position.y = 1;
        this.temporalEchoGhost.add(light);
        this.temporalEchoGhost.userData.light = light;

        this.temporalEchoGhost.position.copy(this.temporalEchoPosition);
        this.temporalEchoGhost.rotation.y = this.rotation;
        this.scene.add(this.temporalEchoGhost);
    }

    updateTemporalEcho(deltaTime) {
        if (!this.temporalEchoActive) return;

        this.temporalEchoTimer -= deltaTime;

        // Animate ghost
        if (this.temporalEchoGhost) {
            const pulse = Math.sin(this.temporalEchoTimer * 10) * 0.3 + 0.5;
            this.temporalEchoGhost.traverse(child => {
                if (child.material) {
                    child.material.opacity = pulse;
                }
            });
            if (this.temporalEchoGhost.userData.light) {
                this.temporalEchoGhost.userData.light.intensity = pulse * 2;
            }
        }

        // Timer expired - teleport back
        if (this.temporalEchoTimer <= 0) {
            this.triggerTemporalEchoReturn();
        }
    }

    triggerTemporalEchoReturn() {
        if (!this.temporalEchoActive) return;

        // Play echo return sound
        audioManager.playEchoReturn();

        // Create flash effect at current position
        this.createTeleportFlash(this.position.clone());

        // Teleport to saved position
        this.position.copy(this.temporalEchoPosition);

        // Create arrival flash
        this.createTeleportFlash(this.position.clone());

        // Clean up ghost
        if (this.temporalEchoGhost) {
            this.scene.remove(this.temporalEchoGhost);
            this.temporalEchoGhost = null;
        }

        this.temporalEchoActive = false;
        this.temporalEchoPosition = null;
    }

    createTeleportFlash(position) {
        const flashGeom = new THREE.SphereGeometry(1, 16, 16);
        const flashMat = new THREE.MeshBasicMaterial({
            color: 0x7eb8da,
            transparent: true,
            opacity: 1
        });
        const flash = new THREE.Mesh(flashGeom, flashMat);
        flash.position.copy(position);
        flash.position.y = 1;
        this.scene.add(flash);

        this.abilityEffects.push({
            type: 'teleportFlash',
            timer: 0,
            duration: 0.3,
            mesh: flash
        });
    }

    // Chronostasis (R) - Freeze enemies (handled mostly in Game class)
    canUseChronostasis() {
        return this.chronostasisCooldown <= 0 &&
               this.temporalCharge >= CONFIG.chronostasisCost;
    }

    useChronostasis() {
        this.temporalCharge -= CONFIG.chronostasisCost;
        this.chronostasisCooldown = CONFIG.chronostasisCooldown;

        // Play Chronostasis sound
        audioManager.playChronostasis();

        // Create visual effect
        this.createChronostasisEffect();

        return {
            type: 'chronostasis',
            duration: CONFIG.chronostasisDuration
        };
    }

    createChronostasisEffect() {
        // Create a time-freeze ripple effect
        const rippleCount = 3;
        const ripples = [];

        for (let i = 0; i < rippleCount; i++) {
            const ringGeom = new THREE.RingGeometry(0.5, 1.5, 64);
            const ringMat = new THREE.MeshBasicMaterial({
                color: 0xd4af37,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeom, ringMat);
            ring.position.copy(this.position);
            ring.position.y = 0.5;
            ring.rotation.x = -Math.PI / 2;
            ring.scale.setScalar(0.1);
            ring.userData.delay = i * 0.1;
            ring.userData.started = false;
            this.scene.add(ring);
            ripples.push(ring);
        }

        this.abilityEffects.push({
            type: 'chronostasis',
            timer: 0,
            duration: 1.0,
            ripples: ripples
        });
    }

    updateAbilityEffects(deltaTime) {
        for (let i = this.abilityEffects.length - 1; i >= 0; i--) {
            const effect = this.abilityEffects[i];
            effect.timer += deltaTime;
            const progress = effect.timer / effect.duration;

            if (effect.type === 'timeFracture') {
                // Expand ring
                const scale = 1 + progress * CONFIG.timeFractureRadius * 2;
                effect.ring.scale.set(scale, scale, 1);
                effect.ring.material.opacity = 1 - progress;

                // Shrink and fade burst
                effect.burst.scale.setScalar(1 + progress * 2);
                effect.burst.material.opacity = 0.8 * (1 - progress);

                // Update particles
                for (const p of effect.particles) {
                    p.position.x += p.userData.velocity.x * deltaTime;
                    p.position.y += p.userData.velocity.y * deltaTime;
                    p.position.z += p.userData.velocity.z * deltaTime;
                    p.userData.velocity.y -= 10 * deltaTime; // gravity
                    p.material.opacity = 1 - progress;
                }

                if (progress >= 1) {
                    this.scene.remove(effect.ring);
                    this.scene.remove(effect.burst);
                    for (const p of effect.particles) {
                        this.scene.remove(p);
                    }
                    this.abilityEffects.splice(i, 1);
                }
            } else if (effect.type === 'teleportFlash') {
                effect.mesh.scale.setScalar(1 + progress * 3);
                effect.mesh.material.opacity = 1 - progress;

                if (progress >= 1) {
                    this.scene.remove(effect.mesh);
                    this.abilityEffects.splice(i, 1);
                }
            } else if (effect.type === 'chronostasis') {
                for (const ripple of effect.ripples) {
                    const rippleProgress = (effect.timer - ripple.userData.delay) / (effect.duration - ripple.userData.delay);
                    if (rippleProgress > 0 && rippleProgress < 1) {
                        ripple.userData.started = true;
                        const scale = 1 + rippleProgress * 50;
                        ripple.scale.setScalar(scale);
                        ripple.material.opacity = 0.8 * (1 - rippleProgress);
                    }
                }

                if (progress >= 1) {
                    for (const ripple of effect.ripples) {
                        this.scene.remove(ripple);
                    }
                    this.abilityEffects.splice(i, 1);
                }
            }
        }
    }

    getMovementInput(input) {
        const moveInput = new THREE.Vector3(0, 0, 0);

        // V2 - Get camera-relative directions using camera's yaw angle
        // The camera orbits around the player, so we use its yaw for direction
        const cameraAngle = game.cameraYaw;

        // Calculate forward and right vectors based on camera angle
        // Forward is the direction the camera is facing (into the screen from camera's POV)
        const forwardX = -Math.sin(cameraAngle);
        const forwardZ = -Math.cos(cameraAngle);

        // Right is perpendicular to forward
        const rightX = Math.cos(cameraAngle);
        const rightZ = -Math.sin(cameraAngle);

        // Accumulate input
        if (input.isKeyDown('KeyW') || input.isKeyDown('ArrowUp')) {
            moveInput.x += forwardX;
            moveInput.z += forwardZ;
        }
        if (input.isKeyDown('KeyS') || input.isKeyDown('ArrowDown')) {
            moveInput.x -= forwardX;
            moveInput.z -= forwardZ;
        }
        if (input.isKeyDown('KeyA') || input.isKeyDown('ArrowLeft')) {
            moveInput.x -= rightX;
            moveInput.z -= rightZ;
        }
        if (input.isKeyDown('KeyD') || input.isKeyDown('ArrowRight')) {
            moveInput.x += rightX;
            moveInput.z += rightZ;
        }

        return moveInput;
    }

    startDash(moveInput, strafeDirection = 0) {
        this.isDashing = true;
        this.dashTimer = CONFIG.dashDuration;
        this.dashCooldownTimer = CONFIG.dashCooldown;
        this.stamina -= CONFIG.dashStaminaCost;
        this.staminaRegenTimer = CONFIG.staminaRegenDelay;

        // Space = side strafe based on A/D input (or right by default)
        // strafeDirection: -1 = left (A), 1 = right (D), 0 = auto (right)
        const cameraAngle = game.cameraYaw || 0;
        const rightX = Math.cos(cameraAngle);
        const rightZ = -Math.sin(cameraAngle);

        if (strafeDirection !== 0) {
            // Strafe in the specified direction
            this.dashDirection = new THREE.Vector3(
                rightX * strafeDirection,
                0,
                rightZ * strafeDirection
            ).normalize();
        } else if (moveInput.length() > 0.01) {
            // If moving forward/back without A/D, strafe right by default
            this.dashDirection = new THREE.Vector3(rightX, 0, rightZ).normalize();
        } else {
            // No input = strafe right
            this.dashDirection = new THREE.Vector3(rightX, 0, rightZ).normalize();
        }

        // Play dash sound
        audioManager.playDash();
    }

    updateDash(deltaTime) {
        this.dashTimer -= deltaTime;

        // V2.7 Spawn afterimage every 0.04 seconds during dash
        this.dashAfterimageTimer -= deltaTime;
        if (this.dashAfterimageTimer <= 0) {
            this.spawnDashAfterimage();
            this.dashAfterimageTimer = 0.04;
        }

        // Move in dash direction
        const dashSpeed = CONFIG.dashDistance / CONFIG.dashDuration;
        this.position.x += this.dashDirection.x * dashSpeed * deltaTime;
        this.position.z += this.dashDirection.z * dashSpeed * deltaTime;

        // Arena boundary check during dash
        const distFromCenter = Math.sqrt(
            this.position.x * this.position.x +
            this.position.z * this.position.z
        );

        if (distFromCenter > CONFIG.arenaRadius - 1) {
            const angle = Math.atan2(this.position.z, this.position.x);
            this.position.x = Math.cos(angle) * (CONFIG.arenaRadius - 1);
            this.position.z = Math.sin(angle) * (CONFIG.arenaRadius - 1);
        }

        // Update mesh with dash effect
        this.mesh.position.copy(this.position);

        // Make player semi-transparent during dash
        this.mesh.traverse((child) => {
            if (child.isMesh && child.material) {
                child.material.transparent = true;
                child.material.opacity = 0.5;
            }
        });

        // End dash
        if (this.dashTimer <= 0) {
            this.isDashing = false;
            this.dashAfterimageTimer = 0;
            // Restore opacity
            this.mesh.traverse((child) => {
                if (child.isMesh && child.material) {
                    child.material.opacity = 1;
                }
            });
        }
    }

    // V2.7 Spawn a dash afterimage
    spawnDashAfterimage() {
        const afterimageMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a90b8,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });

        const afterimage = new THREE.Group();

        // Simple silhouette
        const bodyGeom = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
        const body = new THREE.Mesh(bodyGeom, afterimageMaterial);
        body.position.y = 0.8;
        afterimage.add(body);

        const headGeom = new THREE.SphereGeometry(0.25, 8, 8);
        const head = new THREE.Mesh(headGeom, afterimageMaterial);
        head.position.y = 1.8;
        afterimage.add(head);

        afterimage.position.copy(this.position);
        afterimage.rotation.y = this.rotation;
        afterimage.userData.timer = 0.2; // Fade out time

        this.dashAfterimages.push(afterimage);
        this.scene.add(afterimage);
    }

    // V2.7 Update afterimages
    updateAfterimages(deltaTime) {
        for (let i = this.dashAfterimages.length - 1; i >= 0; i--) {
            const afterimage = this.dashAfterimages[i];
            afterimage.userData.timer -= deltaTime;

            // Fade out
            const opacity = Math.max(0, afterimage.userData.timer / 0.2) * 0.4;
            afterimage.traverse(child => {
                if (child.isMesh && child.material) {
                    child.material.opacity = opacity;
                }
            });

            // Remove if faded
            if (afterimage.userData.timer <= 0) {
                this.scene.remove(afterimage);
                afterimage.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
                this.dashAfterimages.splice(i, 1);
            }
        }
    }

    updateMesh(deltaTime) {
        // Position
        this.mesh.position.copy(this.position);

        // Rotation
        this.mesh.rotation.y = this.rotation;

        // Bobbing animation when moving
        if (this.currentSpeed > 1) {
            const prevStepPhase = Math.floor(this.stepTimer / Math.PI);
            this.stepTimer += deltaTime * this.currentSpeed * 0.5;
            const newStepPhase = Math.floor(this.stepTimer / Math.PI);

            // Play footstep sound on each step
            if (newStepPhase > prevStepPhase) {
                audioManager.playFootstep();
            }

            this.bobOffset = Math.sin(this.stepTimer * 2) * 0.15; // Increased from 0.05
            this.mesh.position.y = this.bobOffset;

            // Body sway when moving
            this.bodyParts.body.rotation.z = Math.sin(this.stepTimer) * 0.06; // Increased from 0.02
        } else {
            this.bobOffset *= 0.9;
            this.mesh.position.y = this.bobOffset;
        }

        // Eye glow intensity based on charge
        const chargeRatio = this.temporalCharge / CONFIG.maxCharge;
        this.bodyParts.eyeGlow.intensity = 0.3 + chargeRatio * 0.7;

        // Eye color based on charge
        const eyeColor = new THREE.Color();
        if (chargeRatio < 0.5) {
            eyeColor.setHex(0x7eb8da);
        } else if (chargeRatio < 0.75) {
            eyeColor.lerpColors(new THREE.Color(0x7eb8da), new THREE.Color(0xffffff), (chargeRatio - 0.5) * 4);
        } else {
            eyeColor.lerpColors(new THREE.Color(0xffffff), new THREE.Color(0xd4af37), (chargeRatio - 0.75) * 4);
        }
        this.bodyParts.leftEye.material.color = eyeColor;
        this.bodyParts.rightEye.material.color = eyeColor;
        this.bodyParts.eyeGlow.color = eyeColor;
    }

    updateHUD() {
        // V2 - Use player's maxHealth for correct percentage
        const healthPercent = (this.health / this.maxHealth) * 100;
        const healthBar = document.getElementById('health-fill');
        healthBar.style.width = `${healthPercent}%`;

        // V2 HUD - Update health value display
        document.getElementById('health-value').textContent = Math.ceil(this.health);

        // V2 - Health bar states (regenerating, critical)
        healthBar.classList.remove('regenerating', 'critical');
        if (healthPercent <= 25) {
            healthBar.classList.add('critical');
        } else if (this.isRegenerating) {
            healthBar.classList.add('regenerating');
        }

        // Stamina
        const staminaPercent = (this.stamina / CONFIG.maxStamina) * 100;
        document.getElementById('stamina-fill').style.width = `${staminaPercent}%`;
        document.getElementById('stamina-value').textContent = Math.ceil(this.stamina);

        // Temporal Charge
        const chargePercent = (this.temporalCharge / CONFIG.maxCharge) * 100;
        const chargeFill = document.getElementById('charge-fill');
        chargeFill.style.width = `${chargePercent}%`;

        // V2 - Charge bar full state
        if (this.temporalCharge >= CONFIG.maxCharge) {
            chargeFill.classList.add('full');
        } else {
            chargeFill.classList.remove('full');
        }
    }

    takeDamage(amount) {
        // Damage already has difficulty multiplier applied from enemy
        this.health -= amount;
        if (this.health < 0) this.health = 0;

        // V2 - Reset health regen timer
        this.outOfCombatTimer = 0;
        this.isRegenerating = false;

        // V2 Nightmare mode - Execute threshold
        if (currentDifficulty === 'nightmare' &&
            this.health > 0 &&
            this.health < this.maxHealth * CONFIG.difficulty.nightmare.executeThreshold) {
            // One-shot if below 20% HP
            this.health = 0;
        }
    }

    heal(amount) {
        this.health += amount;
        if (this.health > this.maxHealth) this.health = this.maxHealth;
    }

    addCharge(amount) {
        // V2 - Apply difficulty charge multiplier
        const adjustedCharge = amount * getChargeGainMultiplier();
        this.temporalCharge += adjustedCharge;
        if (this.temporalCharge > CONFIG.maxCharge) {
            this.temporalCharge = CONFIG.maxCharge;
        }
    }
}

// ‚îÄ‚îÄ‚îÄ MAIN GAME CLASS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Game {
    constructor() {
        this.state = GameState.MENU;
        this.canvas = document.getElementById('game-canvas');
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.clock = new THREE.Clock();
        this.deltaTime = 0;
        this.elapsedTime = 0;
        this.gameTime = 0;

        // Arena reference
        this.arena = null;

        // Player
        this.player = null;
        this.input = null;

        // Camera control V2 - Proper third-person orbit camera
        this.cameraYaw = 0;
        this.cameraPitch = CONFIG.cameraDefaultPitch;
        this.cameraDistance = CONFIG.cameraDistance;
        this.cameraTarget = new THREE.Vector3();
        this.cameraActualPosition = new THREE.Vector3();
        this.cameraShakeOffset = new THREE.Vector3();
        this.cameraCombatDistance = CONFIG.cameraDistance; // Pulls back during combat

        // Enemies
        this.enemies = [];
        this.hitFrame = 0; // For tracking which attack frame hits

        // Combat stats
        this.combo = 0;
        this.comboTimer = 0;
        this.score = 0;

        // Statistics for game over screen
        this.totalKills = 0;
        this.maxCombo = 0;

        // High score (loaded from localStorage)
        this.highScore = this.loadHighScore();

        // Pause state
        this.isPaused = false;

        // Chronostasis state (freeze enemies)
        this.chronostasisActive = false;
        this.chronostasisTimer = 0;

        // Time Fracture damage queue
        this.pendingTimeFracture = null;

        // Wave system
        this.wave = 0;
        this.waveState = 'PREP';  // PREP, ACTIVE, COMPLETE, INTERMISSION
        this.waveTimer = 0;
        this.waveEnemiesSpawned = 0;
        this.waveEnemiesKilled = 0;
        this.waveEnemiesTotal = 0;
        this.spawnQueue = [];
        this.spawnTimer = 0;
        this.waveAnnouncement = null;

        // Screen effects
        this.screenEffects = new ScreenEffects();

        // V2.7 Hit sparks particle system
        this.hitSparks = [];

        // V2.8 Audio state
        this.heartbeatTimer = 0;

        // Initialize
        this.init();
    }

    init() {
        this.setupRenderer();
        this.setupScene();
        this.setupCamera();
        this.setupLighting();
        this.createArena();
        this.setupInput();
        this.setupEventListeners();
        this.setupPauseMenu();
        this.animate();
    }

    setupInput() {
        this.input = new InputManager();
    }

    setupRenderer() {
        this.renderer = new THREE.WebGLRenderer({
            canvas: this.canvas,
            antialias: true
        });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
        this.renderer.toneMappingExposure = 0.8;
    }

    setupScene() {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x050510);
        this.scene.fog = new THREE.Fog(CONFIG.fogColor, CONFIG.fogNear, CONFIG.fogFar);
    }

    setupCamera() {
        this.camera = new THREE.PerspectiveCamera(
            60,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        // Initial camera position for menu view
        this.camera.position.set(0, 25, 45);
        this.camera.lookAt(0, 0, 0);
    }

    setupLighting() {
        // Ambient light - deep blue for eerie atmosphere
        const ambientLight = new THREE.AmbientLight(0x1a2a4a, 0.4);
        this.scene.add(ambientLight);

        // Main directional light - moonlight feel
        const mainLight = new THREE.DirectionalLight(0x6688cc, 0.6);
        mainLight.position.set(10, 30, 10);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 100;
        mainLight.shadow.camera.left = -50;
        mainLight.shadow.camera.right = 50;
        mainLight.shadow.camera.top = 50;
        mainLight.shadow.camera.bottom = -50;
        this.scene.add(mainLight);

        // Point lights for golden temporal energy accents
        const goldLight1 = new THREE.PointLight(0xd4af37, 0.8, 30);
        goldLight1.position.set(20, 5, 0);
        this.scene.add(goldLight1);

        const goldLight2 = new THREE.PointLight(0xd4af37, 0.8, 30);
        goldLight2.position.set(-20, 5, 0);
        this.scene.add(goldLight2);

        const goldLight3 = new THREE.PointLight(0xd4af37, 0.6, 25);
        goldLight3.position.set(0, 5, 20);
        this.scene.add(goldLight3);

        const goldLight4 = new THREE.PointLight(0xd4af37, 0.6, 25);
        goldLight4.position.set(0, 5, -20);
        this.scene.add(goldLight4);

        // Center blue light from below
        const centerLight = new THREE.PointLight(0x4a90b8, 1.0, 40);
        centerLight.position.set(0, -2, 0);
        this.scene.add(centerLight);
    }

    createArena() {
        this.arena = new Arena(this.scene);
    }

    setupEventListeners() {
        // Window resize
        window.addEventListener('resize', () => this.onResize());

        // V2 Difficulty selection
        const difficultyBtns = document.querySelectorAll('.difficulty-btn');
        const difficultyDesc = document.getElementById('difficulty-desc');
        const difficultyDescriptions = {
            easy: 'Relaxed experience. More health, slower enemies, higher regen.',
            normal: 'Standard challenge. Balanced for most players.',
            hard: 'Punishing combat. Faster enemies, less forgiveness.',
            nightmare: 'True suffering. One mistake can be fatal. Execute threshold active.'
        };

        difficultyBtns.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent start-screen click
                const diff = btn.dataset.difficulty;

                // Check if nightmare is locked
                if (diff === 'nightmare' && !nightmareUnlocked) {
                    return;
                }

                // Update selection
                difficultyBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                currentDifficulty = diff;
                difficultyDesc.textContent = difficultyDescriptions[diff];
            });

            // Hover descriptions
            btn.addEventListener('mouseenter', () => {
                const diff = btn.dataset.difficulty;
                if (diff === 'nightmare' && !nightmareUnlocked) {
                    difficultyDesc.textContent = 'üîí Complete the game on Hard to unlock.';
                } else {
                    difficultyDesc.textContent = difficultyDescriptions[diff];
                }
            });

            btn.addEventListener('mouseleave', () => {
                difficultyDesc.textContent = difficultyDescriptions[currentDifficulty];
            });
        });

        // Check for nightmare unlock (stored in localStorage)
        if (localStorage.getItem('chronophage_nightmare_unlocked') === 'true') {
            nightmareUnlocked = true;
            const nightmareBtn = document.querySelector('.difficulty-btn.nightmare');
            if (nightmareBtn) {
                nightmareBtn.classList.remove('locked');
                nightmareBtn.textContent = 'NIGHTMARE';
                nightmareBtn.title = '';
            }
        }

        // Start game on click (anywhere on start screen except buttons)
        document.getElementById('start-screen').addEventListener('click', (e) => {
            if (e.target.classList.contains('difficulty-btn')) return;
            this.startGame();
        });

        // Restart game from game over screen
        document.getElementById('game-over-screen').addEventListener('click', () => {
            if (this.state === GameState.GAMEOVER) {
                this.restartGame();
            }
        });

        // Pause on ESC
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Escape' && this.state === GameState.PLAYING) {
                this.togglePause();
            }

            // V2 Weapon switching (1, 2, 3)
            if (this.state === GameState.PLAYING && !this.isPaused && this.player) {
                if (e.code === 'Digit1') {
                    this.player.switchWeapon('blade');
                } else if (e.code === 'Digit2') {
                    this.player.switchWeapon('pistol');
                } else if (e.code === 'Digit3') {
                    this.player.switchWeapon('scythe');
                }
            }
        });

        // Scroll wheel for weapon switching (shift+scroll) or camera zoom (scroll)
        window.addEventListener('wheel', (e) => {
            if (this.state === GameState.PLAYING && !this.isPaused) {
                if (e.shiftKey && this.player) {
                    // V2 - Shift + scroll = weapon cycle
                    this.player.cycleWeapon(e.deltaY > 0 ? 1 : -1);
                } else {
                    // Camera zoom
                    const zoomSpeed = 0.5;
                    this.cameraDistance += e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
                    this.cameraDistance = Math.max(CONFIG.cameraMinDistance,
                        Math.min(CONFIG.cameraMaxDistance, this.cameraDistance));
                }
            }
        }, { passive: true });

        // Display high score on start screen
        this.updateHighScoreDisplay();
    }

    onResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(window.innerWidth, window.innerHeight);
    }

    startGame() {
        this.state = GameState.PLAYING;
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('hud').classList.add('visible');
        document.getElementById('crosshair').classList.add('visible');
        this.gameTime = 0;

        // Initialize audio on first user interaction
        audioManager.init();

        // Reset stats
        this.score = 0;
        this.combo = 0;
        this.comboTimer = 0;
        this.enemies = [];
        this.hitFrame = 0;
        this.totalKills = 0;
        this.maxCombo = 0;
        this.isPaused = false;

        // Reset wave system
        this.wave = 0;
        this.waveState = 'PREP';
        this.waveTimer = CONFIG.wavePrepTime;
        this.waveEnemiesSpawned = 0;
        this.waveEnemiesKilled = 0;
        this.waveEnemiesTotal = 0;
        this.spawnQueue = [];
        this.spawnTimer = 0;

        // Create player
        this.player = new Player(this.scene);

        // Set initial camera position behind player (V2)
        this.cameraYaw = 0;
        this.cameraPitch = CONFIG.cameraDefaultPitch;
        this.cameraDistance = CONFIG.cameraDistance;
        this.cameraCombatDistance = CONFIG.cameraDistance;
        this.cameraTarget.copy(this.player.position);
        this.cameraActualPosition.set(
            this.player.position.x,
            this.player.position.y + CONFIG.cameraHeight,
            this.player.position.z + CONFIG.cameraDistance
        );

        // Show wave announcement
        this.showWaveAnnouncement('GET READY');

        // V2.6 Reset post-processing effects
        this.screenEffects.setLowHealthMode(false);
        this.screenEffects.setCombatMode(false);

        // V2.7 Clear any leftover hit sparks
        for (const spark of this.hitSparks) {
            this.scene.remove(spark);
            spark.geometry.dispose();
            spark.material.dispose();
        }
        this.hitSparks = [];

        // V2.11 Reset audio state
        this.heartbeatTimer = 0;

        // Request pointer lock
        this.canvas.requestPointerLock();
    }

    // Wave System
    getWaveComposition(waveNumber) {
        // Define enemy composition based on wave number
        const composition = [];

        // Base enemy count scales with wave - V2: modified by difficulty
        const diffMod = CONFIG.difficulty[currentDifficulty].waveCountMod || 0;
        const baseCount = CONFIG.baseWaveEnemies + (waveNumber - 1) * CONFIG.enemiesPerWave + diffMod;
        const totalEnemies = Math.max(2, Math.min(baseCount, CONFIG.maxEnemiesAlive));

        // Wave 1-2: Mostly Ticks
        if (waveNumber <= 2) {
            for (let i = 0; i < totalEnemies; i++) {
                composition.push('tick');
            }
        }
        // Wave 3-4: Introduce Tocks and Mites
        else if (waveNumber <= 4) {
            const tocks = Math.floor(waveNumber / 2);
            const mites = Math.max(1, Math.floor(waveNumber / 3));
            for (let i = 0; i < totalEnemies; i++) {
                if (i < mites) composition.push('mite');
                else if (i < mites + tocks) composition.push('tock');
                else composition.push('tick');
            }
        }
        // Wave 5-6: Introduce Pendulum
        else if (waveNumber <= 6) {
            const tocks = Math.floor(waveNumber / 2);
            const pendulums = Math.floor(waveNumber / 3);
            const mites = Math.floor(waveNumber / 4);
            for (let i = 0; i < totalEnemies; i++) {
                if (i < pendulums) composition.push('pendulum');
                else if (i < pendulums + mites) composition.push('mite');
                else if (i < pendulums + mites + tocks) composition.push('tock');
                else composition.push('tick');
            }
        }
        // Wave 7-9: Introduce Grandfather
        else if (waveNumber <= 9) {
            const grandfathers = Math.floor((waveNumber - 6) / 2) + 1;
            const tocks = Math.floor(waveNumber / 3);
            const pendulums = Math.floor(waveNumber / 4);
            const mites = Math.floor(waveNumber / 5);
            for (let i = 0; i < totalEnemies; i++) {
                if (i < grandfathers) composition.push('grandfather');
                else if (i < grandfathers + pendulums) composition.push('pendulum');
                else if (i < grandfathers + pendulums + mites) composition.push('mite');
                else if (i < grandfathers + pendulums + mites + tocks) composition.push('tock');
                else composition.push('tick');
            }
        }
        // Wave 10+: Full variety including Second Hand
        else {
            const secondhands = Math.min(Math.floor((waveNumber - 9) / 2) + 1, 3);
            const grandfathers = Math.min(Math.floor(waveNumber / 5), 2);
            const pendulums = Math.floor(waveNumber / 4);
            const tocks = Math.floor(waveNumber / 3);
            const mites = Math.floor(waveNumber / 6);

            for (let i = 0; i < totalEnemies; i++) {
                if (i < secondhands) composition.push('secondhand');
                else if (i < secondhands + grandfathers) composition.push('grandfather');
                else if (i < secondhands + grandfathers + pendulums) composition.push('pendulum');
                else if (i < secondhands + grandfathers + pendulums + mites) composition.push('mite');
                else if (i < secondhands + grandfathers + pendulums + mites + tocks) composition.push('tock');
                else composition.push('tick');
            }
        }

        // Shuffle for variety
        for (let i = composition.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [composition[i], composition[j]] = [composition[j], composition[i]];
        }

        return composition;
    }

    startNextWave() {
        this.wave++;
        this.waveState = 'ACTIVE';
        this.waveEnemiesSpawned = 0;
        this.waveEnemiesKilled = 0;
        this.currentBoss = null;

        // Check if this is a boss wave (every 10 waves starting at wave 10)
        const isBossWave = this.wave > 0 && this.wave % 10 === 0;

        // Play wave start sound
        audioManager.playWaveStart(this.wave);

        if (isBossWave) {
            // Boss wave - spawn the Chronophage Prime
            this.spawnQueue = ['boss'];
            // Also add some minions for the boss
            const minionCount = Math.min(4, 2 + Math.floor(this.wave / 10));
            for (let i = 0; i < minionCount; i++) {
                this.spawnQueue.push('tick');
            }
            this.waveEnemiesTotal = this.spawnQueue.length;
            this.spawnTimer = 0;

            // Dramatic boss announcement
            this.showWaveAnnouncement(`BOSS WAVE ${this.wave}\nCHRONOPHAGE PRIME APPROACHES`);

            // Play boss entrance sound
            audioManager.playBossEntrance();
        } else {
            // Get normal wave composition
            this.spawnQueue = this.getWaveComposition(this.wave);
            this.waveEnemiesTotal = this.spawnQueue.length;
            this.spawnTimer = 0;

            // Show wave announcement
            this.showWaveAnnouncement(`WAVE ${this.wave}`);
        }

        // Update HUD
        document.getElementById('wave-number').textContent = this.wave;
    }

    updateWaveSystem(deltaTime) {
        switch (this.waveState) {
            case 'PREP':
                this.waveTimer -= deltaTime;
                if (this.waveTimer <= 0) {
                    this.startNextWave();
                }
                break;

            case 'ACTIVE':
                // Spawn enemies from queue
                if (this.spawnQueue.length > 0 && this.enemies.length < CONFIG.maxEnemiesAlive) {
                    this.spawnTimer -= deltaTime;
                    if (this.spawnTimer <= 0) {
                        const type = this.spawnQueue.shift();
                        const angle = Math.random() * Math.PI * 2;
                        const distance = 25 + Math.random() * 10;
                        const position = new THREE.Vector3(
                            Math.cos(angle) * distance,
                            0,
                            Math.sin(angle) * distance
                        );
                        this.spawnEnemy(type, position);
                        this.waveEnemiesSpawned++;

                        // Stagger spawns - faster in later waves
                        this.spawnTimer = Math.max(0.3, 1.5 - this.wave * 0.1);
                    }
                }

                // Check if wave is complete
                if (this.waveEnemiesKilled >= this.waveEnemiesTotal) {
                    this.completeWave();
                }
                break;

            case 'COMPLETE':
                // Brief pause after wave completion
                this.waveTimer -= deltaTime;
                if (this.waveTimer <= 0) {
                    this.waveState = 'INTERMISSION';
                    this.waveTimer = CONFIG.waveIntervalTime;
                    this.showWaveAnnouncement('NEXT WAVE INCOMING');
                }
                break;

            case 'INTERMISSION':
                this.waveTimer -= deltaTime;
                if (this.waveTimer <= 0) {
                    this.startNextWave();
                }
                break;
        }
    }

    completeWave() {
        this.waveState = 'COMPLETE';
        this.waveTimer = 2; // 2 second pause

        // Award wave completion bonus (scales with wave number)
        const waveBonus = CONFIG.waveCompletionBonus * this.wave;
        this.score += waveBonus;

        // Give player some charge for wave completion
        if (this.player) {
            this.player.addCharge(20);
        }

        // Play wave complete sound
        audioManager.playWaveComplete();

        this.showWaveAnnouncement(`WAVE ${this.wave} COMPLETE!\n+${waveBonus} POINTS`);
    }

    showWaveAnnouncement(text) {
        // Create or update wave announcement element
        let announcement = document.getElementById('wave-announcement');
        if (!announcement) {
            announcement = document.createElement('div');
            announcement.id = 'wave-announcement';
            announcement.style.cssText = `
                position: fixed;
                top: 30%;
                left: 50%;
                transform: translate(-50%, -50%) scale(1);
                font-family: 'ZCOOL KuaiLe', 'Bebas Neue', sans-serif;
                font-size: 5rem;
                font-weight: 400;
                letter-spacing: 0.3rem;
                color: #d4af37;
                text-shadow:
                    0 0 20px rgba(212, 175, 55, 0.9),
                    0 0 40px rgba(212, 175, 55, 0.6),
                    0 0 60px rgba(212, 175, 55, 0.4),
                    0 4px 0 rgba(0, 0, 0, 0.3);
                text-align: center;
                pointer-events: none;
                z-index: 100;
                opacity: 0;
                transition: opacity 0.3s, transform 0.3s;
                white-space: pre-line;
            `;
            document.body.appendChild(announcement);
        }

        announcement.textContent = text;
        announcement.style.opacity = '1';

        // Clear any existing timeout
        if (this.waveAnnouncement) {
            clearTimeout(this.waveAnnouncement);
        }

        // Fade out after 2 seconds
        this.waveAnnouncement = setTimeout(() => {
            announcement.style.opacity = '0';
        }, 2000);
    }

    spawnEnemy(type, position) {
        let enemy;
        switch (type) {
            case 'tick':
                enemy = new Tick(this.scene, position);
                break;
            case 'tock':
                enemy = new Tock(this.scene, position);
                break;
            case 'grandfather':
                enemy = new Grandfather(this.scene, position);
                break;
            case 'pendulum':
                enemy = new Pendulum(this.scene, position);
                break;
            case 'secondhand':
                enemy = new SecondHand(this.scene, position);
                break;
            case 'mite':
                enemy = new MinuteMite(this.scene, position, 1.0, this);
                break;
            case 'boss':
                enemy = new ChronophagePrime(this.scene, position, this);
                this.currentBoss = enemy; // Track the boss
                break;
            default:
                enemy = new Tick(this.scene, position);
        }
        this.enemies.push(enemy);

        // Play spawn sound
        audioManager.playEnemySpawn();

        return enemy;
    }

    animate() {
        requestAnimationFrame(() => this.animate());

        this.deltaTime = this.clock.getDelta();
        this.elapsedTime = this.clock.getElapsedTime();

        if (this.state === GameState.PLAYING && !this.isPaused) {
            this.gameTime += this.deltaTime;
            this.update();
        }

        // Update arena animations (always, even in menu)
        if (this.arena) {
            this.arena.update(this.deltaTime, this.elapsedTime);
        }

        // Slow camera rotation in menu
        if (this.state === GameState.MENU) {
            const angle = this.elapsedTime * 0.1;
            this.camera.position.x = Math.sin(angle) * 50;
            this.camera.position.z = Math.cos(angle) * 50;
            this.camera.position.y = 25 + Math.sin(this.elapsedTime * 0.2) * 3;
            this.camera.lookAt(0, 0, 0);
        }

        this.renderer.render(this.scene, this.camera);
    }

    update() {
        // Update screen effects (independently of time scale)
        this.screenEffects.update(this.deltaTime);

        // Apply time scale from screen effects
        const timeScale = this.screenEffects.getTimeScale();
        const scaledDelta = this.deltaTime * timeScale;

        // Handle camera rotation from mouse input (V2 - smoother orbit)
        if (this.input.isPointerLocked) {
            const mouseMovement = this.input.consumeMouseMovement();
            const sensitivity = 0.003;

            // Horizontal orbit (yaw) - no limits, wraps around
            this.cameraYaw += mouseMovement.x * sensitivity;

            // Vertical orbit (pitch) - clamped to prevent flipping
            this.cameraPitch -= mouseMovement.y * sensitivity;
            this.cameraPitch = Math.max(CONFIG.cameraPitchMin, Math.min(CONFIG.cameraPitchMax, this.cameraPitch));
        }

        // Update Chronostasis timer
        this.updateChronostasis(this.deltaTime);

        // Update player (with scaled time, or reduced if in Chronostasis)
        if (this.player) {
            const playerDelta = this.chronostasisActive ?
                scaledDelta * CONFIG.chronostasisPlayerSpeed : scaledDelta;
            this.player.update(playerDelta, this.input, this.elapsedTime);
            this.updateCamera();

            // Check for Chronostasis request
            if (this.player.wantsChronostasis) {
                this.player.wantsChronostasis = false;
                this.activateChronostasis();
            }

            // Check for Time Fracture (process after player input handling)
            this.processTimeFracture();
        }

        // Update enemies (with scaled time, or frozen if Chronostasis)
        this.updateEnemies(scaledDelta);

        // Check combat (player attacks hitting enemies, enemy attacks hitting player)
        this.updateCombat();

        // Update wave system
        this.updateWaveSystem(this.deltaTime);

        // Update combo timer
        this.updateCombo();

        // Update HUD
        this.updateHUD();

        // V2.6 Update post-processing states
        if (this.player) {
            const maxHealth = getPlayerMaxHealth();
            const healthPercent = this.player.health / maxHealth;
            this.screenEffects.setLowHealthMode(healthPercent <= 0.3);

            // CoD-style damage vignette - updates smoothly based on health
            this.screenEffects.updateHealthVignette(healthPercent);
            this.screenEffects.updateDamageVignette(this.deltaTime);

            // Combat mode active when enemies nearby
            const hasNearbyEnemies = this.enemies.some(e =>
                e.isAlive && e.mesh && Vec3.length(Vec3.sub(e.mesh.position, this.player.mesh.position)) < 20
            );
            this.screenEffects.setCombatMode(hasNearbyEnemies);

            // V2.8 Dynamic audio - adjust ambient intensity based on combat
            audioManager.setAmbientIntensity(hasNearbyEnemies ? 1 : 0);

            // V2.8 Low health heartbeat
            if (healthPercent <= 0.3 && healthPercent > 0) {
                this.heartbeatTimer -= this.deltaTime;
                if (this.heartbeatTimer <= 0) {
                    audioManager.playHeartbeat(1 - healthPercent * 2);
                    this.heartbeatTimer = 1.2; // Heartbeat interval
                }
            } else {
                this.heartbeatTimer = 0;
            }
        }

        // V2.7 Update hit spark particles
        this.updateHitSparks(this.deltaTime);
    }

    updateChronostasis(deltaTime) {
        if (!this.chronostasisActive) return;

        this.chronostasisTimer -= deltaTime;
        if (this.chronostasisTimer <= 0) {
            this.chronostasisActive = false;
            this.chronostasisTimer = 0;

            // Play chronostasis end sound
            audioManager.playChronostasisEnd();
        }
    }

    activateChronostasis() {
        if (!this.player.canUseChronostasis()) return;

        const result = this.player.useChronostasis();
        this.chronostasisActive = true;
        this.chronostasisTimer = result.duration;

        // Big screen effect
        this.screenEffects.hitstop(0.1);
        this.screenEffects.flashVignette('#d4af37', 0.4);
        this.screenEffects.shake(0.15, 0.1);

        // V2.6 Chromatic aberration on ability use
        this.screenEffects.chromaticBurst(0.3);
    }

    processTimeFracture() {
        // Check if player just used Time Fracture (we detect by checking if effect was just created)
        if (!this.player) return;

        // Time Fracture was triggered in player, we need to deal damage
        // We check the ability effects to see if one was just added AND not yet processed
        const fractureEffects = this.player.abilityEffects.filter(e =>
            e.type === 'timeFracture' && !e.damageProcessed
        );

        for (const effect of fractureEffects) {
            // Mark as processed FIRST to prevent loop
            effect.damageProcessed = true;

            // Deal damage to all enemies in radius
            for (const enemy of this.enemies) {
                if (!enemy.isAlive || enemy.state === 'SPAWN') continue;

                const dist = Vec3.distance(this.player.position, enemy.position);
                if (dist <= CONFIG.timeFractureRadius) {
                    const result = enemy.takeDamage(CONFIG.timeFractureDamage, this.hitFrame++);
                    if (result === 'killed') {
                        this.onEnemyKilled(enemy);
                    } else if (result === true) {
                        this.onEnemyHit(enemy);
                    }
                }
            }

            // Screen effects - brief hitstop for impact
            this.screenEffects.hitstop(0.05);
            this.screenEffects.shake(0.25, 0.12);

            // V2.6 Chromatic aberration on Time Fracture
            this.screenEffects.chromaticBurst(0.25);
        }
    }

    updateEnemies(scaledDelta) {
        if (!this.player) return;

        // If Chronostasis is active, enemies are frozen
        const enemyDelta = this.chronostasisActive ? 0 : scaledDelta;

        for (let i = this.enemies.length - 1; i >= 0; i--) {
            const enemy = this.enemies[i];

            // Update enemy with scaled delta time (or 0 if frozen)
            // Pass player rotation for enemies that need to know if they're being watched (SecondHand)
            enemy.update(enemyDelta, this.player.position, this.player.rotation);

            // Remove destroyed enemies
            if (!enemy.isAlive && !enemy.isDying) {
                this.enemies.splice(i, 1);
            }
        }
    }

    updateCombat() {
        if (!this.player) return;

        // V2 - Handle different weapon types
        const currentWeapon = this.player.currentWeapon;

        // Update projectiles for pistol
        this.player.updateProjectiles(this.deltaTime);
        this.player.updateReload(this.deltaTime);

        // Check pistol projectiles hitting enemies
        for (let i = this.player.projectiles.length - 1; i >= 0; i--) {
            const proj = this.player.projectiles[i];
            for (const enemy of this.enemies) {
                if (!enemy.isAlive || enemy.state === 'SPAWN') continue;

                const dist = proj.mesh.position.distanceTo(enemy.mesh.position);
                if (dist < 1.5) {
                    // Hit!
                    let damage = proj.damage;
                    if (enemy.isVulnerable && enemy.isVulnerable()) {
                        damage *= 1.5;
                    }

                    const result = enemy.takeDamage(damage, this.hitFrame++);
                    if (result === 'killed') {
                        this.onEnemyKilled(enemy);
                    } else if (result === true) {
                        this.onEnemyHit(enemy);
                    }

                    // Remove projectile
                    this.scene.remove(proj.mesh);
                    this.player.projectiles.splice(i, 1);
                    break;
                }
            }
        }

        // Melee weapons (blade and scythe)
        if (this.player.sword && (currentWeapon === 'blade' || currentWeapon === 'scythe')) {
            const hitbox = this.player.sword.getAttackHitbox();
            if (hitbox) {
                // Increment hit frame ONLY when attack first becomes active (for preventing double hits)
                // This ensures each attack swing has a unique hitFrame
                if (this.player.sword.attackPhase === 'active' && !this.player.sword.hitFrameSet) {
                    this.hitFrame++;
                    this.player.sword.hitFrameSet = true;
                } else if (this.player.sword.attackPhase !== 'active') {
                    this.player.sword.hitFrameSet = false;
                }

                // V2 - Get weapon-specific arc and range
                const weaponConfig = CONFIG.weapons[currentWeapon];
                const attackArc = currentWeapon === 'scythe' ?
                    weaponConfig.arc : (hitbox.arc || weaponConfig.arc);
                const weaponRange = currentWeapon === 'scythe' ?
                    CONFIG.weapons.scythe.range : hitbox.radius;

                // Find the CLOSEST enemy within range and arc (blade hits one, scythe can hit multiple)
                let closestEnemy = null;
                let closestDist = Infinity;
                const enemiesInArc = [];

                for (const enemy of this.enemies) {
                    if (!enemy.isAlive || enemy.state === 'SPAWN') continue;

                    // Distance check - use weapon range
                    const dist = Vec3.distance(this.player.position, enemy.position);
                    if (dist > weaponRange) continue;

                    // Angle check (is enemy within attack arc?)
                    const toEnemy = new THREE.Vector3(
                        enemy.position.x - this.player.position.x,
                        0,
                        enemy.position.z - this.player.position.z
                    ).normalize();

                    const playerForward = new THREE.Vector3(
                        Math.sin(this.player.rotation),
                        0,
                        Math.cos(this.player.rotation)
                    );

                    const dot = toEnemy.dot(playerForward);
                    const angleToEnemy = Math.acos(Math.max(-1, Math.min(1, dot)));
                    const halfArc = (attackArc * Math.PI / 180) / 2;

                    if (angleToEnemy <= halfArc) {
                        enemiesInArc.push({ enemy, dist });
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestEnemy = enemy;
                        }
                    }
                }

                // Blade hits only closest enemy, scythe hits all in arc
                const enemiesToHit = currentWeapon === 'scythe' ?
                    enemiesInArc.map(e => e.enemy) :
                    (closestEnemy ? [closestEnemy] : []);

                for (const enemy of enemiesToHit) {
                    // Calculate damage (bonus if enemy is vulnerable)
                    let damage = hitbox.damage;

                    // V2 - Scythe does its own damage
                    if (currentWeapon === 'scythe') {
                        damage = CONFIG.weapons.scythe.damage;
                    }

                    if (enemy.isVulnerable && enemy.isVulnerable()) {
                        damage *= 1.5;
                    }

                    // Apply damage - returns false if already hit this frame, true if hit, 'killed' if killed
                    const result = enemy.takeDamage(damage, this.hitFrame);

                    if (result === 'killed') {
                        // Enemy killed
                        this.onEnemyKilled(enemy);
                    } else if (result === true) {
                        // Enemy hit but not killed
                        this.onEnemyHit(enemy);
                    }
                    // result === false means already hit this frame, do nothing
                }
            }
        }

        // Check enemy attacks hitting player
        if (!this.player.isDashing) {
            for (const enemy of this.enemies) {
                if (!enemy.isAlive) continue;

                if (enemy.checkAttackHit && enemy.checkAttackHit(this.player.position)) {
                    this.onPlayerHit(enemy.damage);
                }
            }
        }
    }

    onEnemyHit(enemy) {
        const prevCombo = this.combo;

        // Add to combo
        this.combo++;
        this.comboTimer = CONFIG.comboDecayTime;

        // V2.8 Check combo milestones and play sound
        const milestones = [10, 25, 50, 100];
        for (let i = 0; i < milestones.length; i++) {
            if (prevCombo < milestones[i] && this.combo >= milestones[i]) {
                audioManager.playComboMilestone(i + 1);
                break;
            }
        }

        // Track max combo
        if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
        }

        // Add temporal charge
        this.player.addCharge(CONFIG.chargePerHit);

        // Screen effects - small hitstop and shake
        this.screenEffects.hitstop(0.03);
        this.screenEffects.shake(0.1, 0.08);

        // V2.7 Spawn hit sparks at enemy position
        this.spawnHitSparks(enemy.position, 8);

        // Play hit sound
        audioManager.playHit(25);

        // Animate combo display
        this.animateComboHit();
    }

    // V2.7 Spawn hit spark particles
    spawnHitSparks(position, count = 8) {
        // Safety check - ensure position is valid
        if (!position || isNaN(position.x) || isNaN(position.y) || isNaN(position.z)) return;

        for (let i = 0; i < count; i++) {
            const spark = new THREE.Mesh(
                new THREE.SphereGeometry(0.08, 4, 4),
                new THREE.MeshBasicMaterial({
                    color: Math.random() > 0.5 ? 0xd4af37 : 0x4a90b8,
                    transparent: true,
                    opacity: 1
                })
            );

            spark.position.set(position.x, position.y + 1 + Math.random() * 0.5, position.z);

            // Random velocity
            spark.userData.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 8,
                Math.random() * 6 + 2,
                (Math.random() - 0.5) * 8
            );
            spark.userData.timer = 0.4 + Math.random() * 0.2;
            spark.userData.gravity = -20;

            this.hitSparks.push(spark);
            this.scene.add(spark);
        }
    }

    // V2.7 Update hit sparks
    updateHitSparks(deltaTime) {
        for (let i = this.hitSparks.length - 1; i >= 0; i--) {
            const spark = this.hitSparks[i];

            // Apply gravity
            spark.userData.velocity.y += spark.userData.gravity * deltaTime;

            // Move
            spark.position.x += spark.userData.velocity.x * deltaTime;
            spark.position.y += spark.userData.velocity.y * deltaTime;
            spark.position.z += spark.userData.velocity.z * deltaTime;

            // Fade out
            spark.userData.timer -= deltaTime;
            spark.material.opacity = Math.max(0, spark.userData.timer / 0.5);

            // Remove if expired
            if (spark.userData.timer <= 0 || spark.position.y < 0) {
                this.scene.remove(spark);
                spark.geometry.dispose();
                spark.material.dispose();
                this.hitSparks.splice(i, 1);
            }
        }
    }

    animateComboHit() {
        const comboDisplay = document.querySelector('.combo-display');
        comboDisplay.classList.add('hit');
        setTimeout(() => comboDisplay.classList.remove('hit'), 100);
    }

    onEnemyKilled(enemy) {
        // Track wave progress
        this.waveEnemiesKilled++;

        // Track total kills
        this.totalKills++;

        // Add to combo
        this.combo += 5;
        this.comboTimer = CONFIG.comboDecayTime;

        // Track max combo
        if (this.combo > this.maxCombo) {
            this.maxCombo = this.combo;
        }

        // Add score (with combo multiplier)
        const multiplier = this.getComboMultiplier();
        this.score += Math.floor(enemy.points * multiplier);

        // Add temporal charge
        this.player.addCharge(CONFIG.chargePerKill);

        // Screen effects - bigger hitstop and slowmo
        this.screenEffects.hitstop(0.05);
        this.screenEffects.slowmo(0.7, 0.1);
        this.screenEffects.shake(0.2, 0.15);

        // Play death sound (boss vs normal)
        const isBoss = enemy.constructor.name === 'ChronophagePrime';
        audioManager.playEnemyDeath(isBoss);

        // V2.6 Chromatic aberration on kills (stronger for bosses)
        if (isBoss) {
            this.screenEffects.chromaticBurst(0.5);
        } else if (this.combo >= 25) {
            this.screenEffects.chromaticBurst(0.15);
        }

        // V2.7 Big spark burst on kill
        this.spawnHitSparks(enemy.position, isBoss ? 30 : 15);
    }

    onPlayerHit(damage) {
        // Reset combo
        this.combo = 0;
        this.comboTimer = 0;

        // Damage player
        this.player.takeDamage(damage);

        // Screen effects - red vignette and shake
        this.screenEffects.flashVignette('#ff0000', 0.5);
        this.screenEffects.shake(0.3, 0.15);

        // V2.6 Chromatic aberration burst on damage
        this.screenEffects.chromaticBurst(0.2);

        // V2.6 Check low health mode
        const maxHealth = getPlayerMaxHealth();
        const healthPercent = this.player.health / maxHealth;
        this.screenEffects.setLowHealthMode(healthPercent <= 0.3);

        // Play player hit sound
        audioManager.playPlayerHit();

        // Check for death
        if (this.player.health <= 0) {
            this.gameOver();
        }
    }

    updateCombo() {
        if (this.comboTimer > 0) {
            this.comboTimer -= this.deltaTime;
            if (this.comboTimer <= 0) {
                this.combo = 0;
            }
        }
    }

    getComboMultiplier() {
        if (this.combo >= 100) return 5.0;
        if (this.combo >= 50) return 3.0;
        if (this.combo >= 25) return 2.0;
        if (this.combo >= 10) return 1.5;
        return 1.0;
    }

    updateHUD() {
        // Update game time display
        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        document.getElementById('time-display').textContent =
            `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        // Update combo
        document.getElementById('combo-count').textContent = this.combo;

        // Style combo based on value
        const comboDisplay = document.querySelector('.combo-display');
        comboDisplay.classList.remove('high', 'max');
        if (this.combo >= 50) {
            comboDisplay.classList.add('max');
        } else if (this.combo >= 25) {
            comboDisplay.classList.add('high');
        }

        // Update score
        document.getElementById('score-display').textContent = this.score.toLocaleString();

        // Update ability cooldowns
        this.updateAbilityHUD();
    }

    updateAbilityHUD() {
        if (!this.player) return;

        const charge = this.player.temporalCharge;

        // Q - Time Fracture
        const qSlot = document.getElementById('ability-q');
        const qCooldown = document.getElementById('ability-q-cooldown');
        qSlot.classList.remove('ready', 'insufficient');
        if (this.player.timeFractureCooldown > 0) {
            const cdPercent = (this.player.timeFractureCooldown / CONFIG.timeFractureCooldown) * 100;
            qCooldown.style.height = `${cdPercent}%`;
        } else {
            qCooldown.style.height = '0%';
            if (charge >= CONFIG.timeFractureCost) {
                qSlot.classList.add('ready');
            } else {
                qSlot.classList.add('insufficient');
            }
        }

        // E - Temporal Echo
        const eSlot = document.getElementById('ability-e');
        const eCooldown = document.getElementById('ability-e-cooldown');
        eSlot.classList.remove('ready', 'active', 'insufficient');
        if (this.player.temporalEchoActive) {
            eSlot.classList.add('active');
            eCooldown.style.height = '0%';
        } else if (this.player.temporalEchoCooldown > 0) {
            const cdPercent = (this.player.temporalEchoCooldown / CONFIG.temporalEchoCooldown) * 100;
            eCooldown.style.height = `${cdPercent}%`;
        } else {
            eCooldown.style.height = '0%';
            if (charge >= CONFIG.temporalEchoCost) {
                eSlot.classList.add('ready');
            } else {
                eSlot.classList.add('insufficient');
            }
        }

        // R - Chronostasis
        const rSlot = document.getElementById('ability-r');
        const rCooldown = document.getElementById('ability-r-cooldown');
        rSlot.classList.remove('ready', 'active', 'insufficient');
        if (this.chronostasisActive) {
            rSlot.classList.add('active');
            rCooldown.style.height = '0%';
        } else if (this.player.chronostasisCooldown > 0) {
            const cdPercent = (this.player.chronostasisCooldown / CONFIG.chronostasisCooldown) * 100;
            rCooldown.style.height = `${cdPercent}%`;
        } else {
            rCooldown.style.height = '0%';
            if (charge >= CONFIG.chronostasisCost) {
                rSlot.classList.add('ready');
            } else {
                rSlot.classList.add('insufficient');
            }
        }
    }

    gameOver() {
        this.state = GameState.GAMEOVER;

        // Play game over sound
        audioManager.playGameOver();

        // Release pointer lock
        document.exitPointerLock();

        // Hide HUD
        document.getElementById('hud').classList.remove('visible');
        document.getElementById('crosshair').classList.remove('visible');

        // Check for new high score
        const isNewHighScore = this.score > this.highScore;
        if (isNewHighScore) {
            this.highScore = this.score;
            this.saveHighScore();
        }

        // V2: Check for nightmare unlock (survive 5+ waves on Hard)
        let justUnlockedNightmare = false;
        if (currentDifficulty === 'hard' && this.wave >= 5 && !nightmareUnlocked) {
            nightmareUnlocked = true;
            justUnlockedNightmare = true;
            localStorage.setItem('chronophage_nightmare_unlocked', 'true');
            // Update nightmare button on start screen
            const nightmareBtn = document.querySelector('.difficulty-btn.nightmare');
            if (nightmareBtn) {
                nightmareBtn.classList.remove('locked');
                nightmareBtn.textContent = 'NIGHTMARE';
                nightmareBtn.title = '';
            }
        }

        // Format time
        const minutes = Math.floor(this.gameTime / 60);
        const seconds = Math.floor(this.gameTime % 60);
        const timeStr = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        // Update game over screen
        document.getElementById('final-score').textContent = this.score.toLocaleString();
        document.getElementById('final-wave').textContent = this.wave;
        document.getElementById('stat-time').textContent = timeStr;
        document.getElementById('stat-kills').textContent = this.totalKills;
        document.getElementById('stat-max-combo').textContent = this.maxCombo;

        // V2: Update difficulty display
        const difficultyDisplay = document.getElementById('final-difficulty');
        difficultyDisplay.textContent = currentDifficulty.toUpperCase();
        difficultyDisplay.className = `final-difficulty ${currentDifficulty}`;

        // Show/hide new high score notice
        const highScoreNotice = document.getElementById('new-high-score');
        highScoreNotice.style.display = isNewHighScore ? 'block' : 'none';

        // V2: Show/hide nightmare unlock notice
        const nightmareUnlockNotice = document.getElementById('nightmare-unlock');
        nightmareUnlockNotice.style.display = justUnlockedNightmare ? 'block' : 'none';

        // Show game over screen
        const gameOverScreen = document.getElementById('game-over-screen');
        gameOverScreen.classList.add('visible');
    }

    restartGame() {
        // Hide game over screen
        document.getElementById('game-over-screen').classList.remove('visible');

        // Clean up old enemies
        for (const enemy of this.enemies) {
            if (enemy.mesh) {
                this.scene.remove(enemy.mesh);
            }
        }
        this.enemies = [];

        // Clean up old player
        if (this.player) {
            // V2.11 Clean up player afterimages
            for (const afterimage of this.player.dashAfterimages) {
                this.scene.remove(afterimage);
                afterimage.traverse(child => {
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) child.material.dispose();
                });
            }
            this.player.dashAfterimages = [];

            // V2.11 Clean up player projectiles
            for (const proj of this.player.projectiles) {
                this.scene.remove(proj.mesh);
                proj.mesh.geometry.dispose();
                proj.mesh.material.dispose();
            }
            this.player.projectiles = [];

            if (this.player.mesh) {
                this.scene.remove(this.player.mesh);
            }
        }
        this.player = null;

        // Start fresh game
        this.startGame();
    }

    togglePause() {
        this.isPaused = !this.isPaused;

        const pauseScreen = document.getElementById('pause-screen');
        const crosshair = document.getElementById('crosshair');
        if (this.isPaused) {
            pauseScreen.classList.add('visible');
            crosshair.classList.remove('visible');
            document.exitPointerLock();
        } else {
            pauseScreen.classList.remove('visible');
            crosshair.classList.add('visible');
            this.canvas.requestPointerLock();
        }
    }

    setupPauseMenu() {
        // Volume sliders
        const musicSlider = document.getElementById('music-volume');
        const sfxSlider = document.getElementById('sfx-volume');
        const musicValue = document.getElementById('music-volume-value');
        const sfxValue = document.getElementById('sfx-volume-value');

        // Set initial values
        musicSlider.value = audioManager.getMusicVolume() * 100;
        sfxSlider.value = audioManager.getSfxVolume() * 100;
        musicValue.textContent = Math.round(musicSlider.value) + '%';
        sfxValue.textContent = Math.round(sfxSlider.value) + '%';

        // Music volume slider
        musicSlider.addEventListener('input', (e) => {
            const vol = e.target.value / 100;
            audioManager.setMusicVolume(vol);
            musicValue.textContent = Math.round(e.target.value) + '%';
        });

        // SFX volume slider
        sfxSlider.addEventListener('input', (e) => {
            const vol = e.target.value / 100;
            audioManager.setSfxVolume(vol);
            sfxValue.textContent = Math.round(e.target.value) + '%';
        });

        // Resume button
        document.getElementById('resume-button').addEventListener('click', () => {
            this.togglePause();
        });

        // Quit button
        document.getElementById('quit-button').addEventListener('click', () => {
            this.isPaused = false;
            document.getElementById('pause-screen').classList.remove('visible');
            this.returnToMenu();
        });
    }

    returnToMenu() {
        // Clean up current game
        this.state = GameState.MENU;

        // Reset game state
        if (this.player) {
            if (this.player.mesh) this.scene.remove(this.player.mesh);
            this.player = null;
        }

        // Clear enemies
        for (const enemy of this.enemies) {
            if (enemy.mesh) this.scene.remove(enemy.mesh);
        }
        this.enemies = [];

        // Show start screen, hide gameplay UI
        document.getElementById('start-screen').style.display = 'flex';
        document.getElementById('hud').classList.remove('visible');
        document.getElementById('crosshair').classList.remove('visible');
        document.exitPointerLock();
    }

    loadHighScore() {
        try {
            const saved = localStorage.getItem('chronophage_highscore');
            return saved ? parseInt(saved, 10) : 0;
        } catch (e) {
            return 0;
        }
    }

    saveHighScore() {
        try {
            localStorage.setItem('chronophage_highscore', this.highScore.toString());
        } catch (e) {
            // localStorage not available
        }
    }

    updateHighScoreDisplay() {
        const display = document.getElementById('high-score-display');
        const value = document.getElementById('high-score-value');
        if (this.highScore > 0) {
            display.style.display = 'block';
            value.textContent = this.highScore.toLocaleString();
        }
    }

    updateCamera() {
        // V2 Third-person orbit camera - proper follow behavior
        if (!this.player) return;

        // Target position (player upper body)
        const targetLookAt = this.player.position.clone();
        targetLookAt.y += 1.5;

        // Dynamic distance - pull back during combat for better visibility
        const nearbyEnemies = this.enemies.filter(e =>
            e.isAlive &&
            e.mesh.position.distanceTo(this.player.position) < 15
        ).length;

        const targetDistance = nearbyEnemies > 0
            ? this.cameraDistance * CONFIG.cameraCombatPullback
            : this.cameraDistance;

        // Smooth the combat distance transition
        this.cameraCombatDistance = THREE.MathUtils.lerp(
            this.cameraCombatDistance,
            targetDistance,
            this.deltaTime * 3
        );

        // Calculate camera position using spherical coordinates
        // Camera orbits around player based on yaw (horizontal) and pitch (vertical)
        const horizontalDistance = Math.cos(this.cameraPitch) * this.cameraCombatDistance;
        const verticalDistance = Math.sin(this.cameraPitch) * this.cameraCombatDistance;

        const cameraOffset = new THREE.Vector3(
            Math.sin(this.cameraYaw) * horizontalDistance,
            verticalDistance + CONFIG.cameraHeight,
            Math.cos(this.cameraYaw) * horizontalDistance
        );

        // Target camera position
        const targetCameraPos = this.player.position.clone().add(cameraOffset);

        // Smooth camera movement with proper lerp factor
        const lerpFactor = Math.min(1, CONFIG.cameraSmoothness * 60 * this.deltaTime);
        this.cameraActualPosition.lerp(targetCameraPos, lerpFactor);

        // Apply camera position
        this.camera.position.copy(this.cameraActualPosition);

        // Apply screen shake (with recovery)
        if (this.cameraShakeOffset.lengthSq() > 0.0001) {
            this.camera.position.add(this.cameraShakeOffset);
            // Recover from shake
            this.cameraShakeOffset.multiplyScalar(1 - CONFIG.cameraShakeRecovery * this.deltaTime);
        }

        // Apply screen effects shake on top
        this.screenEffects.applyToCamera(this.camera);

        // Smooth look target
        this.cameraTarget.lerp(targetLookAt, lerpFactor);
        this.camera.lookAt(this.cameraTarget);
    }

    // V2 Camera shake that recovers smoothly
    addCameraShake(intensity, duration = 0.1) {
        const shakeX = (Math.random() - 0.5) * intensity;
        const shakeY = (Math.random() - 0.5) * intensity;
        const shakeZ = (Math.random() - 0.5) * intensity;
        this.cameraShakeOffset.set(shakeX, shakeY, shakeZ);
    }
}

// ‚îÄ‚îÄ‚îÄ ARENA CLASS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
class Arena {
    constructor(scene) {
        this.scene = scene;
        this.floorClock = null;
        this.clockHands = [];
        this.temporalStreams = [];
        this.floatingDebris = [];
        this.particles = [];
        this.pillars = [];
        this.torches = [];
        this.torchLights = [];

        this.createFloor();
        this.createClockPattern();
        this.createPillarsAndTorches();
        this.createTemporalStreams();
        this.createFloatingDebris();
        this.createAmbientParticles();
        this.createSkybox();
    }

    createFloor() {
        // Main arena floor - circular platform
        const floorGeometry = new THREE.CylinderGeometry(
            CONFIG.arenaRadius,
            CONFIG.arenaRadius + 2,
            2,
            64
        );

        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a2e,
            roughness: 0.7,
            metalness: 0.3
        });

        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.position.y = -1;
        floor.frustumCulled = false; // Prevent disappearing at certain camera angles
        this.scene.add(floor);
        this.floor = floor; // Store reference

        // Floor edge glow ring
        const edgeGeometry = new THREE.TorusGeometry(CONFIG.arenaRadius + 0.5, 0.3, 8, 64);
        const edgeMaterial = new THREE.MeshBasicMaterial({
            color: 0x4a90b8,
            transparent: true,
            opacity: 0.6,
            depthWrite: false
        });
        const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
        edge.rotation.x = Math.PI / 2;
        edge.position.y = 0.1;
        edge.frustumCulled = false;
        this.scene.add(edge);

        // Inner glow ring
        const innerEdgeGeometry = new THREE.TorusGeometry(CONFIG.arenaRadius - 1, 0.15, 8, 64);
        const innerEdgeMaterial = new THREE.MeshBasicMaterial({
            color: 0xd4af37,
            transparent: true,
            opacity: 0.4,
            depthWrite: false
        });
        const innerEdge = new THREE.Mesh(innerEdgeGeometry, innerEdgeMaterial);
        innerEdge.rotation.x = Math.PI / 2;
        innerEdge.position.y = 0.1;
        innerEdge.frustumCulled = false;
        this.scene.add(innerEdge);
    }

    createClockPattern() {
        // Clock face pattern on the floor
        const clockGroup = new THREE.Group();

        // Center hub
        const hubGeometry = new THREE.CylinderGeometry(3, 3, 0.3, 32);
        const hubMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.3,
            metalness: 0.8,
            roughness: 0.2
        });
        const hub = new THREE.Mesh(hubGeometry, hubMaterial);
        hub.position.y = 0.15;
        clockGroup.add(hub);

        // Roman numerals positions (12 positions around the clock)
        const numerals = ['XII', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX', 'X', 'XI'];
        const numeralRadius = CONFIG.arenaRadius - 5;

        for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI * 2) / 12 - Math.PI / 2;
            const x = Math.cos(angle) * numeralRadius;
            const z = Math.sin(angle) * numeralRadius;

            // Numeral marker (glowing circle)
            const markerGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.2, 16);
            const markerMaterial = new THREE.MeshStandardMaterial({
                color: 0x4a90b8,
                emissive: 0x4a90b8,
                emissiveIntensity: 0.4,
                transparent: true,
                opacity: 0.8,
                depthWrite: false
            });
            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.set(x, 0.1, z);
            clockGroup.add(marker);

            // Connecting line from center
            const lineGeometry = new THREE.BoxGeometry(0.2, 0.1, numeralRadius - 5);
            const lineMaterial = new THREE.MeshBasicMaterial({
                color: 0x2a4a6a,
                transparent: true,
                opacity: 0.5,
                depthWrite: false
            });
            const line = new THREE.Mesh(lineGeometry, lineMaterial);
            line.position.set(
                Math.cos(angle) * (numeralRadius / 2 - 1),
                0.05,
                Math.sin(angle) * (numeralRadius / 2 - 1)
            );
            line.rotation.y = -angle + Math.PI / 2;
            clockGroup.add(line);
        }

        // Hour tick marks (60 small marks)
        for (let i = 0; i < 60; i++) {
            const angle = (i * Math.PI * 2) / 60 - Math.PI / 2;
            const isHourMark = i % 5 === 0;
            const markRadius = CONFIG.arenaRadius - 8;
            const markLength = isHourMark ? 2 : 1;

            const markGeometry = new THREE.BoxGeometry(0.15, 0.1, markLength);
            const markMaterial = new THREE.MeshBasicMaterial({
                color: isHourMark ? 0xd4af37 : 0x3a5a7a,
                transparent: true,
                opacity: isHourMark ? 0.8 : 0.4,
                depthWrite: false
            });
            const mark = new THREE.Mesh(markGeometry, markMaterial);
            mark.position.set(
                Math.cos(angle) * markRadius,
                0.05,
                Math.sin(angle) * markRadius
            );
            mark.rotation.y = -angle + Math.PI / 2;
            clockGroup.add(mark);
        }

        // Clock hands (decorative, slowly moving)
        // Hour hand
        const hourHandGeometry = new THREE.BoxGeometry(1, 0.3, 15);
        const hourHandMaterial = new THREE.MeshStandardMaterial({
            color: 0xd4af37,
            emissive: 0xd4af37,
            emissiveIntensity: 0.2,
            metalness: 0.9,
            roughness: 0.1
        });
        const hourHand = new THREE.Mesh(hourHandGeometry, hourHandMaterial);
        hourHand.position.set(0, 0.2, 7.5);

        const hourHandPivot = new THREE.Group();
        hourHandPivot.add(hourHand);
        hourHandPivot.position.y = 0;
        this.clockHands.push({ pivot: hourHandPivot, speed: 0.01 });
        clockGroup.add(hourHandPivot);

        // Minute hand
        const minuteHandGeometry = new THREE.BoxGeometry(0.6, 0.25, 22);
        const minuteHandMaterial = new THREE.MeshStandardMaterial({
            color: 0x7eb8da,
            emissive: 0x4a90b8,
            emissiveIntensity: 0.3,
            metalness: 0.9,
            roughness: 0.1
        });
        const minuteHand = new THREE.Mesh(minuteHandGeometry, minuteHandMaterial);
        minuteHand.position.set(0, 0.35, 11);

        const minuteHandPivot = new THREE.Group();
        minuteHandPivot.add(minuteHand);
        minuteHandPivot.position.y = 0;
        minuteHandPivot.rotation.y = Math.PI / 3;
        this.clockHands.push({ pivot: minuteHandPivot, speed: 0.12 });
        clockGroup.add(minuteHandPivot);

        // Concentric rings
        for (let r = 10; r < CONFIG.arenaRadius - 2; r += 8) {
            const ringGeometry = new THREE.TorusGeometry(r, 0.1, 8, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: 0x2a4a6a,
                transparent: true,
                opacity: 0.3,
                depthWrite: false
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = Math.PI / 2;
            ring.position.y = 0.05;
            clockGroup.add(ring);
        }

        // Disable frustum culling on all clock pattern elements to prevent disappearing
        clockGroup.traverse((child) => {
            if (child.isMesh) {
                child.frustumCulled = false;
            }
        });

        this.scene.add(clockGroup);
        this.floorClock = clockGroup;
    }

    createPillarsAndTorches() {
        // 12 pillars at clock positions around the arena edge
        const pillarRadius = CONFIG.arenaRadius - 3;

        for (let i = 0; i < 12; i++) {
            const angle = (i * Math.PI * 2) / 12 - Math.PI / 2;
            const x = Math.cos(angle) * pillarRadius;
            const z = Math.sin(angle) * pillarRadius;

            // Create pillar group
            const pillarGroup = new THREE.Group();
            pillarGroup.position.set(x, 0, z);
            pillarGroup.rotation.y = -angle;

            // Pillar materials
            const stoneMaterial = new THREE.MeshStandardMaterial({
                color: 0x2a2a3e,
                roughness: 0.8,
                metalness: 0.2
            });

            const goldMaterial = new THREE.MeshStandardMaterial({
                color: 0xd4af37,
                emissive: 0xd4af37,
                emissiveIntensity: 0.2,
                metalness: 0.9,
                roughness: 0.2
            });

            // Base
            const baseGeom = new THREE.BoxGeometry(2.5, 0.5, 2.5);
            const base = new THREE.Mesh(baseGeom, stoneMaterial);
            base.position.y = 0.25;
            base.castShadow = true;
            base.receiveShadow = true;
            pillarGroup.add(base);

            // Main column
            const columnGeom = new THREE.CylinderGeometry(0.8, 1, 8, 8);
            const column = new THREE.Mesh(columnGeom, stoneMaterial);
            column.position.y = 4.5;
            column.castShadow = true;
            pillarGroup.add(column);

            // Column details - rings
            for (let r = 0; r < 3; r++) {
                const ringGeom = new THREE.TorusGeometry(0.9, 0.1, 8, 16);
                const ring = new THREE.Mesh(ringGeom, goldMaterial);
                ring.position.y = 2 + r * 2.5;
                ring.rotation.x = Math.PI / 2;
                pillarGroup.add(ring);
            }

            // Capital (top decorative piece)
            const capitalGeom = new THREE.BoxGeometry(2, 0.8, 2);
            const capital = new THREE.Mesh(capitalGeom, stoneMaterial);
            capital.position.y = 8.9;
            pillarGroup.add(capital);

            // Clock face on pillar
            const clockFaceGeom = new THREE.CircleGeometry(0.6, 16);
            const clockFaceMat = new THREE.MeshBasicMaterial({
                color: 0xeeeedd,
                side: THREE.DoubleSide
            });
            const clockFace = new THREE.Mesh(clockFaceGeom, clockFaceMat);
            clockFace.position.set(0, 5, 0.85);
            pillarGroup.add(clockFace);

            // Clock face rim
            const clockRimGeom = new THREE.TorusGeometry(0.65, 0.08, 8, 16);
            const clockRim = new THREE.Mesh(clockRimGeom, goldMaterial);
            clockRim.position.set(0, 5, 0.85);
            pillarGroup.add(clockRim);

            // Torch holder
            const holderGeom = new THREE.BoxGeometry(0.3, 0.8, 0.5);
            const holder = new THREE.Mesh(holderGeom, goldMaterial);
            holder.position.set(0, 7, 1.2);
            pillarGroup.add(holder);

            // Torch bowl
            const bowlGeom = new THREE.CylinderGeometry(0.3, 0.2, 0.4, 8);
            const bowl = new THREE.Mesh(bowlGeom, goldMaterial);
            bowl.position.set(0, 7.5, 1.2);
            pillarGroup.add(bowl);

            // Torch flame (animated glow sphere)
            const flameGeom = new THREE.SphereGeometry(0.25, 8, 8);
            const flameMat = new THREE.MeshBasicMaterial({
                color: 0xff6600,
                transparent: true,
                opacity: 0.9
            });
            const flame = new THREE.Mesh(flameGeom, flameMat);
            flame.position.set(0, 7.8, 1.2);
            pillarGroup.add(flame);

            // Torch light
            const torchLight = new THREE.PointLight(0xff6600, 0.8, 12);
            torchLight.position.set(0, 8, 1.2);
            pillarGroup.add(torchLight);

            this.scene.add(pillarGroup);
            this.pillars.push(pillarGroup);
            this.torches.push(flame);
            this.torchLights.push(torchLight);
        }
    }

    createTemporalStreams() {
        // Golden energy streams rising from the void at arena edge
        const streamCount = 16;

        for (let i = 0; i < streamCount; i++) {
            const angle = (i * Math.PI * 2) / streamCount;
            const x = Math.cos(angle) * (CONFIG.arenaRadius + 3);
            const z = Math.sin(angle) * (CONFIG.arenaRadius + 3);

            // Stream particles (vertical line of glowing points)
            const streamGroup = new THREE.Group();
            streamGroup.position.set(x, 0, z);

            const particleCount = 20;
            for (let j = 0; j < particleCount; j++) {
                const particleGeometry = new THREE.SphereGeometry(0.3, 8, 8);
                const particleMaterial = new THREE.MeshBasicMaterial({
                    color: 0xd4af37,
                    transparent: true,
                    opacity: 0.6 - (j / particleCount) * 0.4
                });
                const particle = new THREE.Mesh(particleGeometry, particleMaterial);
                particle.position.y = j * 2 - 10;
                particle.userData.baseY = particle.position.y;
                particle.userData.offset = Math.random() * Math.PI * 2;
                streamGroup.add(particle);
            }

            this.temporalStreams.push(streamGroup);
            this.scene.add(streamGroup);
        }
    }

    createFloatingDebris() {
        // Floating clock gears and fragments in the background
        const debrisTypes = [
            { geometry: new THREE.TorusGeometry(2, 0.3, 8, 16), color: 0x8b7355 }, // Gear
            { geometry: new THREE.TorusGeometry(1.5, 0.2, 8, 12), color: 0x6b5344 }, // Small gear
            { geometry: new THREE.BoxGeometry(3, 0.5, 0.5), color: 0xd4af37 }, // Clock hand fragment
            { geometry: new THREE.CylinderGeometry(0.8, 0.8, 0.3, 16), color: 0x4a90b8 }, // Clock face fragment
        ];

        for (let i = 0; i < 30; i++) {
            const type = debrisTypes[Math.floor(Math.random() * debrisTypes.length)];
            const material = new THREE.MeshStandardMaterial({
                color: type.color,
                metalness: 0.6,
                roughness: 0.4,
                transparent: true,
                opacity: 0.7
            });

            const debris = new THREE.Mesh(type.geometry.clone(), material);

            // Random position in the void around the arena
            const angle = Math.random() * Math.PI * 2;
            const distance = CONFIG.arenaRadius + 15 + Math.random() * 40;
            const height = -10 + Math.random() * 50;

            debris.position.set(
                Math.cos(angle) * distance,
                height,
                Math.sin(angle) * distance
            );

            debris.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );

            debris.userData.rotationSpeed = {
                x: (Math.random() - 0.5) * 0.2,
                y: (Math.random() - 0.5) * 0.2,
                z: (Math.random() - 0.5) * 0.2
            };
            debris.userData.floatSpeed = 0.3 + Math.random() * 0.3;
            debris.userData.floatOffset = Math.random() * Math.PI * 2;
            debris.userData.baseY = debris.position.y;

            this.floatingDebris.push(debris);
            this.scene.add(debris);
        }
    }

    createAmbientParticles() {
        // Tiny golden motes floating in the air
        const particleCount = 200;
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * CONFIG.arenaRadius;
            const height = Math.random() * 20;

            positions[i * 3] = Math.cos(angle) * distance;
            positions[i * 3 + 1] = height;
            positions[i * 3 + 2] = Math.sin(angle) * distance;

            // Gold/white colors
            const isGold = Math.random() > 0.3;
            if (isGold) {
                colors[i * 3] = 0.83;     // R
                colors[i * 3 + 1] = 0.69; // G
                colors[i * 3 + 2] = 0.22; // B
            } else {
                colors[i * 3] = 0.8;
                colors[i * 3 + 1] = 0.85;
                colors[i * 3 + 2] = 0.9;
            }
        }

        const particleGeometry = new THREE.BufferGeometry();
        particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.15,
            vertexColors: true,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending
        });

        const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
        particleSystem.userData.velocities = [];

        for (let i = 0; i < particleCount; i++) {
            particleSystem.userData.velocities.push({
                x: (Math.random() - 0.5) * 0.5,
                y: (Math.random() - 0.5) * 0.3,
                z: (Math.random() - 0.5) * 0.5,
                frozen: false,
                freezeTimer: 0
            });
        }

        this.particles.push(particleSystem);
        this.scene.add(particleSystem);
    }

    createSkybox() {
        // Create a dark gradient skybox/background
        const skyGeometry = new THREE.SphereGeometry(200, 32, 32);
        const skyMaterial = new THREE.ShaderMaterial({
            uniforms: {
                topColor: { value: new THREE.Color(0x0a0a1a) },
                bottomColor: { value: new THREE.Color(0x000005) },
                offset: { value: 0 },
                exponent: { value: 0.6 }
            },
            vertexShader: `
                varying vec3 vWorldPosition;
                void main() {
                    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                    vWorldPosition = worldPosition.xyz;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 topColor;
                uniform vec3 bottomColor;
                uniform float offset;
                uniform float exponent;
                varying vec3 vWorldPosition;
                void main() {
                    float h = normalize(vWorldPosition + offset).y;
                    gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
                }
            `,
            side: THREE.BackSide
        });

        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        this.scene.add(sky);

        // Add a massive gear in the sky (The Great Gear)
        const greatGearGeometry = new THREE.TorusGeometry(50, 5, 8, 32);
        const greatGearMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a3a,
            metalness: 0.8,
            roughness: 0.3,
            transparent: true,
            opacity: 0.4
        });
        const greatGear = new THREE.Mesh(greatGearGeometry, greatGearMaterial);
        greatGear.position.set(60, 80, -60);
        greatGear.rotation.x = Math.PI / 4;
        greatGear.rotation.z = Math.PI / 6;
        this.floatingDebris.push(greatGear);
        greatGear.userData.rotationSpeed = { x: 0, y: 0.02, z: 0 };
        greatGear.userData.floatSpeed = 0;
        greatGear.userData.baseY = greatGear.position.y;
        this.scene.add(greatGear);

        // Add gear teeth to great gear
        const teethCount = 24;
        for (let i = 0; i < teethCount; i++) {
            const angle = (i * Math.PI * 2) / teethCount;
            const toothGeometry = new THREE.BoxGeometry(8, 8, 5);
            const tooth = new THREE.Mesh(toothGeometry, greatGearMaterial.clone());
            tooth.position.set(
                Math.cos(angle) * 55,
                Math.sin(angle) * 55,
                0
            );
            tooth.rotation.z = angle;
            greatGear.add(tooth);
        }
    }

    update(deltaTime, elapsedTime) {
        // Rotate clock hands
        for (const hand of this.clockHands) {
            hand.pivot.rotation.y -= hand.speed * deltaTime;
        }

        // Animate torch flames and lights
        for (let i = 0; i < this.torches.length; i++) {
            const torch = this.torches[i];
            const light = this.torchLights[i];

            // Flickering flame scale
            const flicker = 0.8 + Math.sin(elapsedTime * 15 + i) * 0.15 +
                           Math.sin(elapsedTime * 23 + i * 2) * 0.1;
            torch.scale.setScalar(flicker);

            // Flickering light intensity
            light.intensity = 0.6 + Math.sin(elapsedTime * 12 + i) * 0.2 +
                             Math.sin(elapsedTime * 19 + i * 1.5) * 0.15;

            // Slight color variation
            const hue = 0.08 + Math.sin(elapsedTime * 8 + i) * 0.02;
            light.color.setHSL(hue, 1, 0.5);
        }

        // Animate temporal streams
        for (const stream of this.temporalStreams) {
            stream.children.forEach((particle, index) => {
                particle.position.y = particle.userData.baseY +
                    Math.sin(elapsedTime * 2 + particle.userData.offset) * 0.5 +
                    (elapsedTime * 3) % 40 - 20;

                // Wrap particles
                if (particle.position.y > 30) {
                    particle.position.y = -10;
                }
            });
        }

        // Animate floating debris
        for (const debris of this.floatingDebris) {
            debris.rotation.x += debris.userData.rotationSpeed.x * deltaTime;
            debris.rotation.y += debris.userData.rotationSpeed.y * deltaTime;
            debris.rotation.z += debris.userData.rotationSpeed.z * deltaTime;

            if (debris.userData.floatSpeed > 0) {
                debris.position.y = debris.userData.baseY +
                    Math.sin(elapsedTime * debris.userData.floatSpeed + debris.userData.floatOffset) * 2;
            }
        }

        // Animate ambient particles with occasional "time stutters"
        for (const particleSystem of this.particles) {
            const positions = particleSystem.geometry.attributes.position.array;
            const velocities = particleSystem.userData.velocities;

            for (let i = 0; i < velocities.length; i++) {
                const vel = velocities[i];

                // Random freeze (time stutter effect)
                if (!vel.frozen && Math.random() < 0.001) {
                    vel.frozen = true;
                    vel.freezeTimer = 0.3 + Math.random() * 0.5;
                }

                if (vel.frozen) {
                    vel.freezeTimer -= deltaTime;
                    if (vel.freezeTimer <= 0) {
                        vel.frozen = false;
                    }
                    continue;
                }

                // Move particles
                positions[i * 3] += vel.x * deltaTime;
                positions[i * 3 + 1] += vel.y * deltaTime;
                positions[i * 3 + 2] += vel.z * deltaTime;

                // Boundary check - wrap around arena
                const x = positions[i * 3];
                const z = positions[i * 3 + 2];
                const dist = Math.sqrt(x * x + z * z);

                if (dist > CONFIG.arenaRadius) {
                    const angle = Math.random() * Math.PI * 2;
                    const newDist = Math.random() * CONFIG.arenaRadius * 0.5;
                    positions[i * 3] = Math.cos(angle) * newDist;
                    positions[i * 3 + 2] = Math.sin(angle) * newDist;
                }

                // Height wrap
                if (positions[i * 3 + 1] > 20) {
                    positions[i * 3 + 1] = 0;
                } else if (positions[i * 3 + 1] < 0) {
                    positions[i * 3 + 1] = 20;
                }
            }

            particleSystem.geometry.attributes.position.needsUpdate = true;
        }
    }
}

// ‚îÄ‚îÄ‚îÄ INITIALIZATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let game;

window.addEventListener('load', () => {
    game = new Game();
});

    </script>
</body>
</html>
